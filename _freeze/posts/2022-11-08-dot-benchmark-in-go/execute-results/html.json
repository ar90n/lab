{
  "hash": "cf1b9a87023afbd6e424563867b843d1",
  "result": {
    "markdown": "---\ntitle: Goによるdot積のベンチマーク\ndate: '2022-11-08'\ncategories:\n  - Go\n  - 線形代数\nimage: /_freeze/posts/2022-11-08-dot-benchmark-in-go/figure-html/cell-14-output-1.png\nformat:\n  html:\n    code-fold: false\nnocite: |\n  @tokyo2021go\n---\n\n\n\n## はじめに\nGoにて[類似ベクトル検索](https://github.com/ar90n/countrymaam)を実装したところ、dot積の速度がパフォーマンスの律速となりました。\nそこで、Goにてドット積のベンチマークを行い、各種実装方法の速度を比較してみました。\n\n## やったこと\n* Goでベクトルのdot積を計算する関数を実装\n* 各種実装方法のベンチマークを取得\n\n## 対象コード\n単純なループによる実装\n\n::: {.cell execution_count=3}\n``` {.go .cell-code}\nfunc CalcDot(a, b []float64, size int) float64 {\n    dot := 0.0\n    for i := 0; i < size; i++ {\n        dot += a[i] * b[i]\n    }\n    return dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=2）\n\n::: {.cell execution_count=4}\n``` {.go .cell-code}\nfunc CalcDotUnroll2(a, b []float64, size int) float64 {\n    const N = 2\n\tdot := 0.0\n\n\ti := 0\n\tfor ; i < size % N; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tdot += mul0 + mul1\n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=4）\n\n::: {.cell execution_count=5}\n``` {.go .cell-code}\nfunc CalcDotUnroll4(a, b []float64, size int) float64 {\n    const N = 4\n\tdot := 0.0\n\n\ti := 0\n\tfor ; i < size % N; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tmul2 := a[i+2] * b[i+2]\n\t\tmul3 := a[i+3] * b[i+3]\n\t\tdot += mul0 + mul1 + mul2 + mul3\n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=8）\n\n::: {.cell execution_count=6}\n``` {.go .cell-code}\nfunc CalcDotUnroll8(a, b []float64, size int) float64 {\n    const N = 8\n\tdot := 0.0\n\n\ti := 0\n\tfor ; i < size % N; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tmul2 := a[i+2] * b[i+2]\n\t\tmul3 := a[i+3] * b[i+3]\n\t\tmul4 := a[i+4] * b[i+4]\n\t\tmul5 := a[i+5] * b[i+5]\n\t\tmul6 := a[i+6] * b[i+6]\n\t\tmul7 := a[i+7] * b[i+7]\n\t\tdot += mul0 + mul1 + mul2 + mul3 + mul4 + mul5 + mul6 + mul7 \n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nGonumによる実装\n\n::: {.cell execution_count=7}\n``` {.go .cell-code}\nimport (\n    \"gonum.org/v1/gonum/mat\"\n)\n\nfunc CalcDotByGonum(a, b []float64, size int) float64 {\n    av := mat.NewVecDense(size, a[:size])\n    bv := mat.NewVecDense(size, b[:size])\n    return mat.Dot(av, bv)\n}\n```\n:::\n\n\nGonumによる実装（blas）\n\n::: {.cell execution_count=8}\n``` {.go .cell-code}\nimport (\n    \"gonum.org/v1/gonum/blas/blas64\"\n)\n\nfunc CalcDotByGonumBlas(a, b []float64, size int) float64 {\n    av := blas64.Vector{\n        N: size,\n        Inc:  1,\n        Data: a,\n    }\n    bv := blas64.Vector{\n        N: size,\n        Inc:  1,\n        Data: b,\n    }\n    return blas64.Dot(av, bv)\n}\n```\n:::\n\n\n\n\n## ベンチマーク\n実行環境\n\n::: {.cell execution_count=10}\n``` {.go .cell-code}\n$lscpu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nAddress sizes:                   43 bits physical, 48 bits virtual\nCPU(s):                          32\nOn-line CPU(s) list:             0-31\nThread(s) per core:              2\nCore(s) per socket:              16\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       AuthenticAMD\nCPU family:                      23\nModel:                           113\nModel name:                      AMD Ryzen 9 3950X 16-Core Processor\nStepping:                        0\nFrequency boost:                 enabled\nCPU MHz:                         3500.000\nCPU max MHz:                     4761.2300\nCPU min MHz:                     2200.0000\nBogoMIPS:                        6986.90\nVirtualization:                  AMD-V\nL1d cache:                       512 KiB\nL1i cache:                       512 KiB\nL2 cache:                        8 MiB\nL3 cache:                        64 MiB\nNUMA node0 CPU(s):               0-31\nVulnerability Itlb multihit:     Not affected\nVulnerability L1tf:              Not affected\nVulnerability Mds:               Not affected\nVulnerability Meltdown:          Not affected\nVulnerability Mmio stale data:   Not affected\nVulnerability Retbleed:          Mitigation; untrained return thunk; SMT enabled with STIBP protection\nVulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl and seccomp\nVulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization\nVulnerability Spectre v2:        Mitigation; Retpolines, IBPB conditional, STIBP always-on, RSB filling\nVulnerability Srbds:             Not affected\nVulnerability Tsx async abort:   Not affected\nFlags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba ibpb stibp vmmcall fsgsbase bmi1 avx2 smep bmi2 cqm rdt_a rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local clzero irperf xsaveerptr rdpru wbnoinvd arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif v_spec_ctrl umip rdpid overflow_recov succor smca sme sev sev_es\n```\n:::\n:::\n\n\n検証用データ生成\n\n::: {.cell execution_count=11}\n``` {.go .cell-code}\nimport (\n    \"math/rand\"\n)\n\nN := 2048\nveca := make([]float64, N)\nvecb := make([]float64, N)\nfor i := 0; i < N; i++ {\n    veca[i] = rand.Float64()\n    vecb[i] = rand.Float64()\n}\n```\n:::\n\n\nベンチマークコード\n\n::: {.cell execution_count=12}\n``` {.go .cell-code}\nimport (\n    \"testing\"\n    \"reflect\"\n    \"runtime\"\n)\n\nfunc bench(f func(a, b []float64, size int) float64, size int) func(b *testing.B) {\n    return func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            f(veca, vecb, size)\n        }\n    }\n}\n\ntype Result struct {\n    Size int\n    Benchmark map[string]testing.BenchmarkResult\n}\n\nresults := []Result{}\nfor _, size := range []int{32, 256, 2048} {\n    type BenchmarkFunc struct {\n        Name string\n        Func func(a, b []float64, size int) float64\n    }\n\n    bs := map[string]testing.BenchmarkResult{}\n    for _, e := range []BenchmarkFunc{\n        {Name: \"CalcDot\",            Func: CalcDot},\n        {Name: \"CalcDotUnroll2\",     Func: CalcDotUnroll2},\n        {Name: \"CalcDotUnroll4\",     Func: CalcDotUnroll4},\n        {Name: \"CalcDotUnroll8\",     Func: CalcDotUnroll8},\n        {Name: \"CalcDotByGonum\",     Func: CalcDotByGonum},\n        {Name: \"CalcDotByGonumBlas\", Func: CalcDotByGonumBlas},\n    } {\n        bs[e.Name] = testing.Benchmark(bench(e.Func, size))\n    }\n    results = append(results, Result{Size: size, Benchmark: bs})\n}\n```\n:::\n\n\nベンチマーク結果\n\n::: {.cell execution_count=13}\n``` {.go .cell-code code-fold=\"true\"}\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc calcNsPerOp(b *testing.BenchmarkResult) uint64 {\n    return uint64(b.T) / uint64(b.N)\n}\n\nfunc makeRow(funcName string, benchmark *testing.BenchmarkResult) string {\n    nsPerOp := calcNsPerOp(benchmark)\n    return fmt.Sprintf(\"<tr><td>%s</td><td>%d</td><td>%d</td><td>%d</td></tr>\", funcName,  benchmark.N, benchmark.T, nsPerOp)\n}\n\nfunc makeTable(results map[string]testing.BenchmarkResult, size int) string {\n    var rows []string\n    for name, result := range results {\n        rows = append(rows, makeRow(name, &result))\n    }\n    sort.Strings(rows)\n    return fmt.Sprintf(`<table class=\"dataframe\"><caption>size=%d</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr>%s</table>`, size, strings.Join(rows, \"\\n\"))\n}\n\ntables := []string{}\nfor _, r := range results {\n    tables = append(tables, makeTable(r.Benchmark, r.Size))\n}\ndisplay.HTML(strings.Join(tables, \"\\n\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```{=html}\n<table class=\"dataframe\"><caption>size=32</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>257150</td><td>1172960235</td><td>4561</td></tr>\n<tr><td>CalcDotByGonum</td><td>154552</td><td>1262189639</td><td>8166</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>186232</td><td>1031773081</td><td>5540</td></tr>\n<tr><td>CalcDotUnroll2</td><td>252372</td><td>1247609758</td><td>4943</td></tr>\n<tr><td>CalcDotUnroll4</td><td>269863</td><td>1246890684</td><td>4620</td></tr>\n<tr><td>CalcDotUnroll8</td><td>264232</td><td>1220492800</td><td>4619</td></tr></table>\n<table class=\"dataframe\"><caption>size=256</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>75538</td><td>1128265829</td><td>14936</td></tr>\n<tr><td>CalcDotByGonum</td><td>136138</td><td>1091619136</td><td>8018</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>197648</td><td>1163284407</td><td>5885</td></tr>\n<tr><td>CalcDotUnroll2</td><td>60063</td><td>1143204405</td><td>19033</td></tr>\n<tr><td>CalcDotUnroll4</td><td>70314</td><td>1041701688</td><td>14814</td></tr>\n<tr><td>CalcDotUnroll8</td><td>73861</td><td>1120812558</td><td>15174</td></tr></table>\n<table class=\"dataframe\"><caption>size=2048</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>12385</td><td>1223137585</td><td>98759</td></tr>\n<tr><td>CalcDotByGonum</td><td>134955</td><td>1221132298</td><td>9048</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>319032</td><td>1985753111</td><td>6224</td></tr>\n<tr><td>CalcDotUnroll2</td><td>8714</td><td>1126122663</td><td>129231</td></tr>\n<tr><td>CalcDotUnroll4</td><td>11245</td><td>1151313155</td><td>102384</td></tr>\n<tr><td>CalcDotUnroll8</td><td>12462</td><td>1148902713</td><td>92192</td></tr></table>\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.go .cell-code code-fold=\"true\"}\nimport (\n    \"math\"\n    \"bytes\"\n    \"gonum.org/v1/plot\"\n    \"gonum.org/v1/plot/plotter\"\n    \"gonum.org/v1/plot/plotutil\"\n    \"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\nfunc displayPlot(p *plot.Plot) {\n    var buf bytes.Buffer\n    c, err := p.WriterTo(6*vg.Inch, 6*vg.Inch, \"png\")\n    if err != nil {\n        panic(err)\n    }\n    if _, err := c.WriteTo(&buf); err != nil {\n        panic(err)\n    }\n    Display(display.PNG(buf.Bytes()))\n}\n\n\np := plot.New()\np.Title.Text = \"Benchmark of dot product\"\np.X.Label.Text = \"Function\"\np.Y.Label.Text = \"Duration per op[ns]\"\np.X.Tick.Label.Rotation = math.Pi / 2.5\np.X.Tick.Label.XAlign = draw.XRight\np.Legend.Top = true\n\nnames := []string{}\nfor name, _ := range results[0].Benchmark {\n    names = append(names, name)\n}\nsort.Strings(names)\np.NominalX(names...)\n\n\nfor i, r := range results {\n    var values plotter.Values\n    for _, name := range names {\n        b := r.Benchmark[name]\n        values = append(values, float64(calcNsPerOp(&b)))\n    }\n    bar, _ := plotter.NewBarChart(values, vg.Points(20))\n    bar.LineStyle.Width = vg.Length(0)\n    bar.Color = plotutil.Color(i)\n    bar.Offset = vg.Points(float64(i - 1) * 20)\n    p.Add(bar)\n    p.Legend.Add(fmt.Sprintf(\"size=%d\", r.Size), bar)\n}\n\ndisplayPlot(p)\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-11-08-dot-benchmark-in-go_files/figure-html/cell-14-output-1.png){}\n:::\n:::\n\n\n## まとめ\nベクトルが小さい場合(size=32)は単純にループして計算するのが一番速い。しかしながら、ベクトルが一定サイス(size=128)を超えるとgonumを使用したほうが高速となる。\nループのアンローリングは効果がない。gonumを使用する場合は、blasを使用するとより高速になる。\n\n## 参考 \n::: {#refs}\n:::\n\n",
    "supporting": [
      "2022-11-08-dot-benchmark-in-go_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}