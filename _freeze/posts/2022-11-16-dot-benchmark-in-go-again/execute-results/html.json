{
  "hash": "568c6fb1564549c2d969c9e4cedc6197",
  "result": {
    "markdown": "---\ntitle: 続・Goによるdot積のベンチマーク\ndate: '2022-11-16'\ncategories:\n  - Go\n  - 線形代数\nimage: /_freeze/posts/2022-11-16-dot-benchmark-in-go-again/figure-html/cell-14-output-1.png\nformat:\n  html:\n    code-fold: false\nnocite: |\n  @tokyo2021go, @Weaviate\n---\n\n\n\n## はじめに\n[Weaviate](https://github.com/semi-technologies/weaviate)というGo実装の類似ベクトル検索エンジンで使用しているdot積が非常に早そうだったので再度ベンチマークを取ってみました。\n\n## やったこと\n* Weaviateのdot積をベンチマーク対象に追加\n* ベンチマーク条件変更\n  * データ型をfloat32に変更\n  * GOMAXPROCSを1に設定\n\n\n## Weaviateのdot積について\nWeaviateの[dot積](https://github.com/semi-technologies/weaviate/blob/master/adapters/repos/db/vector/hnsw/distancer/asm/dot_amd64.s)、[avo]()に生成されたアセンブリコードとして提供されています。\n動作環境はAVX2がサポートされている必要がありますが、環境では非常に高速な動作が期待できます。\n\n## 対象コード\n単純なループによる実装\n\n::: {#d1cc3125 .cell execution_count=3}\n``` {.go .cell-code}\nfunc CalcDot(a, b []float32) float32 {\n    var dot float32 = 0.0\n    size := len(a)\n    for i := 0; i < size; i++ {\n        dot += a[i] * b[i]\n    }\n    return dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=2）\n\n::: {#4a1fe5bf .cell execution_count=4}\n``` {.go .cell-code}\nfunc CalcDotUnroll2(a, b []float32) float32 {\n    const N = 2\n    var dot float32 = 0.0\n\n\ti := 0\n    size := len(a)\n    prologue_size := size % N\n\tfor ; i < prologue_size; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tdot += mul0 + mul1\n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=4）\n\n::: {#e542d3e3 .cell execution_count=5}\n``` {.go .cell-code}\nfunc CalcDotUnroll4(a, b []float32) float32 {\n    const N = 4\n    var dot float32 = 0.0\n\n\ti := 0\n    size := len(a)\n    prologue_size := size % N\n\tfor ; i < prologue_size; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tmul2 := a[i+2] * b[i+2]\n\t\tmul3 := a[i+3] * b[i+3]\n\t\tdot += mul0 + mul1 + mul2 + mul3\n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nループアンロールによる実装（N=8）\n\n::: {#d2d35b02 .cell execution_count=6}\n``` {.go .cell-code}\nfunc CalcDotUnroll8(a, b []float32) float32 {\n    const N = 8\n    var dot float32 = 0.0\n\n\ti := 0\n    size := len(a)\n    prologue_size := size % N\n\tfor ; i < prologue_size; i++ {\n\t\tdot += a[i] * b[i]\n\t}\n\n\tfor ; i < size; i += N {\n\t\tmul0 := a[i+0] * b[i+0]\n\t\tmul1 := a[i+1] * b[i+1]\n\t\tmul2 := a[i+2] * b[i+2]\n\t\tmul3 := a[i+3] * b[i+3]\n\t\tmul4 := a[i+4] * b[i+4]\n\t\tmul5 := a[i+5] * b[i+5]\n\t\tmul6 := a[i+6] * b[i+6]\n\t\tmul7 := a[i+7] * b[i+7]\n\t\tdot += mul0 + mul1 + mul2 + mul3 + mul4 + mul5 + mul6 + mul7 \n\t}\n\n\treturn dot\n}\n```\n:::\n\n\nGonumによる実装（blas）\n\n::: {#27bb81f6 .cell execution_count=7}\n``` {.go .cell-code}\nimport (\n    \"gonum.org/v1/gonum/blas/blas32\"\n)\n\nfunc CalcDotByGonumBlas(a, b []float32) float32 {\n    size := len(a)\n    av := blas32.Vector{\n        N: size,\n        Inc:  1,\n        Data: a,\n    }\n    bv := blas32.Vector{\n        N: size,\n        Inc:  1,\n        Data: b,\n    }\n    return blas32.Dot(av, bv)\n}\n```\n:::\n\n\nWeaviateによる実装（asm）\n\n::: {#de3ce235 .cell execution_count=8}\n``` {.go .cell-code}\nimport (\n    \"github.com/semi-technologies/weaviate/adapters/repos/db/vector/hnsw/distancer/asm\"\n)\n\nfunc CalcDotByWeaviateAsm(a, b []float32) float32 {\n    return asm.Dot(a, b)\n}\n```\n:::\n\n\n\n\n## ベンチマーク\n実行環境\n\n::: {#39a611a2 .cell execution_count=10}\n``` {.go .cell-code}\n$lscpu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nAddress sizes:                   43 bits physical, 48 bits virtual\nCPU(s):                          32\nOn-line CPU(s) list:             0-31\nThread(s) per core:              2\nCore(s) per socket:              16\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       AuthenticAMD\nCPU family:                      23\nModel:                           113\nModel name:                      AMD Ryzen 9 3950X 16-Core Processor\nStepping:                        0\nFrequency boost:                 enabled\nCPU MHz:                         2680.379\nCPU max MHz:                     4761.2300\nCPU min MHz:                     2200.0000\nBogoMIPS:                        6986.90\nVirtualization:                  AMD-V\nL1d cache:                       512 KiB\nL1i cache:                       512 KiB\nL2 cache:                        8 MiB\nL3 cache:                        64 MiB\nNUMA node0 CPU(s):               0-31\nVulnerability Itlb multihit:     Not affected\nVulnerability L1tf:              Not affected\nVulnerability Mds:               Not affected\nVulnerability Meltdown:          Not affected\nVulnerability Mmio stale data:   Not affected\nVulnerability Retbleed:          Mitigation; untrained return thunk; SMT enabled with STIBP protection\nVulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl and seccomp\nVulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization\nVulnerability Spectre v2:        Mitigation; Retpolines, IBPB conditional, STIBP always-on, RSB filling\nVulnerability Srbds:             Not affected\nVulnerability Tsx async abort:   Not affected\nFlags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba ibpb stibp vmmcall fsgsbase bmi1 avx2 smep bmi2 cqm rdt_a rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local clzero irperf xsaveerptr rdpru wbnoinvd arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif v_spec_ctrl umip rdpid overflow_recov succor smca sme sev sev_es\n```\n:::\n:::\n\n\n検証用データ生成\n\n::: {#3db48532 .cell execution_count=11}\n``` {.go .cell-code}\nimport (\n    \"math/rand\"\n)\n\nN := 2048\nveca := make([]float32, N)\nvecb := make([]float32, N)\nfor i := 0; i < N; i++ {\n    veca[i] = rand.Float32()\n    vecb[i] = rand.Float32()\n}\n```\n:::\n\n\nベンチマークコード\n\n::: {#d2e423b1 .cell execution_count=12}\n``` {.go .cell-code}\nimport (\n    \"testing\"\n    \"reflect\"\n    \"runtime\"\n)\n\nruntime.GOMAXPROCS(1)\n\nfunc bench(f func() float32) func(b *testing.B) {\n    return func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            f()\n        }\n    }\n}\n\ntype Result struct {\n    Size int\n    Benchmark map[string]testing.BenchmarkResult\n}\n\nresults := []Result{}\nfor _, size := range []int{32, 256, 2048} {\n    type BenchmarkFunc struct {\n        Name string\n        Func func(a, b []float32) float32\n    }\n\n    curVeca := veca[:size]\n    curVecb := vecb[:size]\n    bs := map[string]testing.BenchmarkResult{}\n    for _, e := range []BenchmarkFunc{\n        {Name: \"CalcDot\",            Func: CalcDot},\n        {Name: \"CalcDotUnroll2\",     Func: CalcDotUnroll2},\n        {Name: \"CalcDotUnroll4\",     Func: CalcDotUnroll4},\n        {Name: \"CalcDotUnroll8\",     Func: CalcDotUnroll8},\n        {Name: \"CalcDotByGonumBlas\", Func: CalcDotByGonumBlas},\n        {Name: \"CalcDotByWeaviateAsm\", Func: CalcDotByWeaviateAsm},\n    } {\n        bs[e.Name] = testing.Benchmark(bench(func() float32 {\n            e.Func(curVeca, curVecb)\n        }))\n    }\n    results = append(results, Result{Size: size, Benchmark: bs})\n}\n```\n:::\n\n\nベンチマーク結果\n\n::: {#d82ead74 .cell execution_count=13}\n``` {.go .cell-code code-fold=\"true\"}\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc calcNsPerOp(b *testing.BenchmarkResult) uint64 {\n    return uint64(b.T) / uint64(b.N)\n}\n\nfunc makeRow(funcName string, benchmark *testing.BenchmarkResult) string {\n    nsPerOp := calcNsPerOp(benchmark)\n    return fmt.Sprintf(\"<tr><td>%s</td><td>%d</td><td>%d</td><td>%d</td></tr>\", funcName,  benchmark.N, benchmark.T, nsPerOp)\n}\n\nfunc makeTable(results map[string]testing.BenchmarkResult, size int) string {\n    var rows []string\n    for name, result := range results {\n        rows = append(rows, makeRow(name, &result))\n    }\n    sort.Strings(rows)\n    return fmt.Sprintf(`<table class=\"dataframe\"><caption>size=%d</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr>%s</table>`, size, strings.Join(rows, \"\\n\"))\n}\n\ntables := []string{}\nfor _, r := range results {\n    tables = append(tables, makeTable(r.Benchmark, r.Size))\n}\ndisplay.HTML(strings.Join(tables, \"\\n\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<table class=\"dataframe\"><caption>size=32</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>346974</td><td>1179908231</td><td>3400</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>336958</td><td>1204222744</td><td>3573</td></tr>\n<tr><td>CalcDotByWeaviateAsm</td><td>457072</td><td>1118602599</td><td>2447</td></tr>\n<tr><td>CalcDotUnroll2</td><td>319407</td><td>1289024805</td><td>4035</td></tr>\n<tr><td>CalcDotUnroll4</td><td>353758</td><td>1322124380</td><td>3737</td></tr>\n<tr><td>CalcDotUnroll8</td><td>375663</td><td>1259082336</td><td>3351</td></tr></table>\n<table class=\"dataframe\"><caption>size=256</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>92368</td><td>1205821911</td><td>13054</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>341826</td><td>1239509464</td><td>3626</td></tr>\n<tr><td>CalcDotByWeaviateAsm</td><td>458673</td><td>1126861958</td><td>2456</td></tr>\n<tr><td>CalcDotUnroll2</td><td>72632</td><td>1251829756</td><td>17235</td></tr>\n<tr><td>CalcDotUnroll4</td><td>86812</td><td>1227783225</td><td>14143</td></tr>\n<tr><td>CalcDotUnroll8</td><td>93368</td><td>1228300326</td><td>13155</td></tr></table>\n<table class=\"dataframe\"><caption>size=2048</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr><tr><td>CalcDot</td><td>13098</td><td>1214307203</td><td>92709</td></tr>\n<tr><td>CalcDotByGonumBlas</td><td>320077</td><td>1216720203</td><td>3801</td></tr>\n<tr><td>CalcDotByWeaviateAsm</td><td>439030</td><td>1119375941</td><td>2549</td></tr>\n<tr><td>CalcDotUnroll2</td><td>9525</td><td>1176658556</td><td>123533</td></tr>\n<tr><td>CalcDotUnroll4</td><td>12124</td><td>1188543785</td><td>98032</td></tr>\n<tr><td>CalcDotUnroll8</td><td>13207</td><td>1200212236</td><td>90876</td></tr></table>\n```\n:::\n:::\n\n\n::: {#79eda677 .cell execution_count=14}\n``` {.go .cell-code code-fold=\"true\"}\nimport (\n    \"math\"\n    \"bytes\"\n    \"gonum.org/v1/plot\"\n    \"gonum.org/v1/plot/plotter\"\n    \"gonum.org/v1/plot/plotutil\"\n    \"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\nfunc displayPlot(p *plot.Plot) {\n    var buf bytes.Buffer\n    c, err := p.WriterTo(6*vg.Inch, 6*vg.Inch, \"png\")\n    if err != nil {\n        panic(err)\n    }\n    if _, err := c.WriteTo(&buf); err != nil {\n        panic(err)\n    }\n    Display(display.PNG(buf.Bytes()))\n}\n\n\np := plot.New()\np.Title.Text = \"Benchmark of dot product\"\np.X.Label.Text = \"Function\"\np.Y.Label.Text = \"Duration per op[ns]\"\np.X.Tick.Label.Rotation = math.Pi / 2.5\np.X.Tick.Label.XAlign = draw.XRight\np.Legend.Top = true\n\nnames := []string{}\nfor name, _ := range results[0].Benchmark {\n    names = append(names, name)\n}\nsort.Strings(names)\np.NominalX(names...)\n\n\nfor i, r := range results {\n    var values plotter.Values\n    for _, name := range names {\n        b := r.Benchmark[name]\n        values = append(values, float64(calcNsPerOp(&b)))\n    }\n    bar, _ := plotter.NewBarChart(values, vg.Points(20))\n    bar.LineStyle.Width = vg.Length(0)\n    bar.Color = plotutil.Color(i)\n    bar.Offset = vg.Points(float64(i - 1) * 20)\n    p.Add(bar)\n    p.Legend.Add(fmt.Sprintf(\"size=%d\", r.Size), bar)\n}\n\ndisplayPlot(p)\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-11-16-dot-benchmark-in-go-again_files/figure-html/cell-14-output-1.png){}\n:::\n:::\n\n\n## まとめ\nすべての測定でWeaviateのアセンブリ実装が最速であることがわかりました。\n\n## 参考 \n::: {#refs}\n:::\n\n",
    "supporting": [
      "2022-11-16-dot-benchmark-in-go-again_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}