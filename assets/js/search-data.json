{
  
    
        "post0": {
            "title": "cargo-editが上手く動かない時の回避策",
            "content": "はじめに . cargo-edit v0.8.0が上手く動かなかったので，その対処法についてのメモです． . やったこと . ssh-agentに秘密鍵を登録 | v0.7.0にダウングレード | . error authenticating: no auth sock variable; class=Ssh (23) でcargo-editをインストールすることができない . 単純に cargo install cargo-edit をすると，以下の様にssh-agentとの連携に失敗してエラーとなりました． . $ cargo install cargo-edit Updating crates.io index error: failed to fetch `https://github.com/rust-lang/crates.io-index` Caused by: failed to authenticate when downloading repository: ssh://git@github.com/rust-lang/crates.io-index * attempted ssh-agent authentication, but no usernames succeeded: `git` if the git CLI succeeds then `net.git-fetch-with-cli` may help here https://doc.rust-lang.org/cargo/reference/config.html#netgit-fetch-with-cli Caused by: error authenticating: no auth sock variable; class=Ssh (23) . 対処法はエラーメッセージの中に書いてあるので，以下の様にssh-agentの起動と秘密鍵の登録を行います． . $ eval `ssh-agent -s` Agent pid 1756 $ ssh-add Identity added: &lt;path to home&gt;/.ssh/id_rsa (&lt;mail address&gt;) . 再度，cargo install cargo-edit を実行すると無事にインストールできました． . $ cargo install cargo-edit Updating crates.io index Downloaded cargo-edit v0.8.0 Downloaded 1 crate (61.1 KB) in 0.40s Installing cargo-edit v0.8.0 ... Compiling crates-index v0.17.0 Compiling cargo-edit v0.8.0 Finished release [optimized] target(s) in 1m 05s Installing /usr/local/cargo/bin/cargo-add Installing /usr/local/cargo/bin/cargo-rm Installing /usr/local/cargo/bin/cargo-set-version Installing /usr/local/cargo/bin/cargo-upgrade Installed package `cargo-edit v0.8.0` (executables `cargo-add`, `cargo-rm`, `cargo-set-version`, `cargo-upgrade`) . Command failed due to unhandled error: authentication required but no callback set; class=Ssh (23); code=Auth (-16) で cargo add できない . cargo add でクレートを追加しようとすると，以下の様にエラーが発生します． . $ cargo add anyhow Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index Command failed due to unhandled error: authentication required but no callback set; class=Ssh (23); code=Auth (-16) . こちらやこちらなど，同様のエラーに関する報告はちらほら上がっているようです．しかしながら，それらの回避策は私の環境では有効性を発揮しませんでした． 従って，cargo-edit のバージョンを v0.7.0 にダウンロードすることとしました． . $ cargo install --version 0.7.0 cargo-edit Downloaded cargo-edit v0.7.0 Downloaded 1 crate (57.6 KB) in 0.69s Updating crates.io index Installing cargo-edit v0.7.0 ... Replacing /usr/local/cargo/bin/cargo-upgrade Removing executable `/usr/local/cargo/bin/cargo-set-version` from previous version cargo-edit v0.8.0 Replaced package `cargo-edit v0.8.0` with `cargo-edit v0.7.0` (executables `cargo-add`, `cargo-rm`, `cargo-upgrade`) . この結果，以下の様に cargo add が動作する様になりました． . $ cargo add anyhow Updating &#39;https://github.com/rust-lng/crates.io-index&#39; index Adding anyhow v1.0.53 to dependenciesa . 参考 . cargo add no longer works with Git using SSH in 0.8.0 #515 | SSH support #333 | .",
            "url": "https://lab.ar90n.net/rust/2022/01/30/cargo-edit-workaround.html",
            "relUrl": "/rust/2022/01/30/cargo-edit-workaround.html",
            "date": " • Jan 30, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "AWS Amplifyのメモ",
            "content": "はじめに . AWS Amplifyを使ってみて個人的にハマったことのメモです． . やったこと . コンテナ（Fargate）に対して，環境に応じた環境変数を設定する | ロールに対して任意のポリシーを追加する | コンテナが配置されたVPCにリソースを配置する | . コンテナ（Fargate）に対して，環境に応じた環境変数を設定する . AWS AmplifyではAPIを実装するリソースとしてコンテナ（Fargate）がサポートされています．ですが，現状ではデプロイ環境（devやprodなど）に応じた環境変数を設定することができないようです．（少なくとも，私には見つけることができませんでした） . 最初は，CloudFormationの定義ファイルを手動で書き換えることで実現できると考えていました．ですが，実際に作業を進めるとこのファイルはamplify pushのたびにdocker-compose.yamlから生成されることが判明しました．そこで， . dev環境向けにdocker-compose.yaml.devを，prod環境向けにdocker-compose.yaml.prodをそれぞれ作成 | コマンドフックを利用して，amplify pushのタイミングでdocker-compose.yaml.devまたはdocker-compose.yaml.prodをdocker-compose.yamlにコピー | . という対応を採用しました． . ロールに対して任意のポリシーを追加する . カスタムリソースを追加した場合など，Lambdaに任意のポリシーを追加したい場合があると思います．そのような場合は，custom-policies.jsonを利用するのが楽です． 一応，ここやここなど，AWSの公式ドキュメントにも記載されているようですが，目立つところには記載されていないため気がつくまでに時間がかかりました． . コンテナが配置されたVPCにリソースを配置する . コンテナの配置されるVPCは, amplify/backend/backend-config.json中に記述されているNetworkStackというリソースによって作成されれます．NetworkStackは . CloudMapNamespaceId | ClusterName | Igw | SubnetIds | VpcCidrBlock | VpcId | VpcLinkId | . を出力します．必要なパラメータはリソースによって異なると思いますが，SubnetIdsやVpcIdなどを参照することでコンテナと同じVPC内にリソースを配置することができると思います． . 上記パラメータを参照するためには， . amplify/backend/backend-config.jsonにおいて，上記パラメータを参照するリソースのdependsOnにNetworkStackを追加 ... &quot;dependsOn&quot;: [ { &quot;category&quot;: &quot;&quot;, &quot;resourceName&quot;: &quot;NetworkStack&quot;, &quot;attributes&quot;: [ &quot;VpcId&quot;, &quot;SubnetIds&quot; ] } ] ... . | 上述のリソースのCloudFormationの設定ファイルにパラメータの設定を追加.この際，パラメータ名はNetworkStack&lt;Attribute名&gt;となります ... &quot;Parameters&quot;: { ... &quot;NetworkStackVpcId&quot;: { &quot;Type&quot;: &quot;String&quot; }, &quot;NetworkStackSubnetIds&quot;: { &quot;Type&quot;: &quot;CommaDelimitedList&quot; }, ... }, ... . | amplify env checkout &lt;env&gt;を実行して環境のチェックアウトを行う | 参考 . AWS CDKまたはCloudFormationを使用し、カスタムAWSリソースでAmplifyバックエンドを拡張する新機能「カスタム」のご紹介 | Amplify Docs | .",
            "url": "https://lab.ar90n.net/aws/web/cloud/amplify/2022/01/03/aws-amplify-tips.html",
            "relUrl": "/aws/web/cloud/amplify/2022/01/03/aws-amplify-tips.html",
            "date": " • Jan 3, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "RustによるシンプルなGuidedFilterの実装",
            "content": "&#12399;&#12376;&#12417;&#12395; . 高速なエッジ保持平滑化フィルタとしてGuidedFilter(He et al., 2012)が広く知られています．この記事では輝度信号に限定したシンプルな実装を紹介します．なお，実装にはRustとimageクレートを用いました． . &#12420;&#12387;&#12383;&#12371;&#12392; . GuidedFilterを用いたエッジ保持平滑化フィルタを実装 | . GuidedFilter&#12395;&#12388;&#12356;&#12390; . GuidedFilterはガイド信号$ bf{I}$の１次式で入力信号$ bf{p}$を近似することで出力信号$ bf{q}$を得ます．また，このガイド信号の選択により様々な応用が考案されています．今回紹介するエッジ保持平滑化フィルタはその中の一つです． . それでは，実際に出力信号を得るための方法について述べていきます．まず，$ bf{q}$と$ bf{I}$との関係を以下のように定義します． . $$ begin{aligned} q_{i} &amp; = a_{k} I_{i} + b_{k} , forall i in omega_{k} end{aligned} $$ここで，$i$は画素のインデックスを，$k$はウィンドウ中心画素のインデックスを，$ omega_{k}$はウィンドウをそれぞれ表します． . 次に，$p$と$q$との関係について考えます．ここでノイズ$n$を用いると以下のように表現することができます． . $$ begin{aligned} q_{i} &amp; = p_{i} - n_{i} &amp; = a_{k} I_{i} + b_{k} end{aligned} $$そして，$q$で$p$をより良く近似するため，以下の評価関数の最小化を考えます． . $$ begin{aligned} E left(a_{k}, b_{k} right) &amp; = sum_{i in omega_{k}} left( left(a_{k}I_{i} + b_{k} - p_{i} right)^{2} + epsilon a_{k}^{2} right) end{aligned} $$この式において，$ epsilon a_{k}^{2}$で表される項は，$a_{k}$の正則化を目的としたものです．この項はリッジ回帰に用いられる正則化項と同様のモチベーションで導入されています． . それでは，$E left(a_{k}, b_{k} right)$を$a_{k}$および$b_{k}$で偏微分して最適な$a_{k}$と$b_{k}$を求めていきます．最初に$b_{k}$について考えます． . $$ begin{aligned} frac{ partial}{ partial b_{k}} E left(a_{k}, b_{k} right) &amp; = 2 sum_{i in omega_{k}} left(a_{k}I_{i} + b_{k} - p_{i} right) &amp;= 0 b_{k} &amp;= frac{1}{ left| omega_{k} right|} sum_{i in omega_{k}} p_{i} - frac{a_{k}}{ left| omega_{k} right|} sum_{i in omega_{k}} I_{i} end{aligned} $$ここで，$ bar{p_{k}} = frac{1}{ left| omega_{k} right|} sum_{i in omega_{k}} p_{i}$, $ mu_{k} = frac{1}{ left| omega_{k} right|} sum_{i in omega_{k}} I_{i}$ とすると， . $$ begin{aligned} b_{k} &amp;= bar{p_{k}} - a_{k} mu_{k} end{aligned} $$次に$a_{k}$について考えます． . $$ begin{aligned} frac{ partial}{ partial a_{k}} E left(a_{k}, b_{k} right) &amp; = frac{ partial}{ partial a_{k}} sum_{i in omega_{k}} left( left(a_{k}I_{i} + b_{k} - p_{i} right)^{2} + epsilon a_{k}^{2} right) &amp;= frac{ partial}{ partial a_{k}} sum_{i in omega_{k}} left( left(a_{k}I_{i} + bar{p_{k}} - a_{k} mu_{k} - p_{i} right)^{2} + epsilon a_{k}^{2} right) &amp;= frac{ partial}{ partial a_{k}} sum_{i in omega_{k}} left( left(a_{k} left( I_{i} - mu_{k} right) + bar{p_{k}} - p_{i} right)^{2} + epsilon a_{k}^{2} right) &amp;= 2 sum_{i in omega_{k}} left( left(a_{k} left( I_{i} - mu_{k} right) + bar{p_{k}} - p_{i} right) left( I_{i} - mu_{k} right) + epsilon a_{k} right) &amp;= 2a_{k} sum_{i in omega_{k}} left( I_{i} - mu_{k} right)^{2} - 2 sum_{i in omega_{k}} p_{i}I_{i} + 2 mu_{k} sum_{i in omega_{k}} p_{i} + 2 bar{p_{k}} sum_{i in omega_{k}} I_{i} -2 bar{p_{k}} mu_{k} left| omega_{k} right| + 2 epsilon a_{k} left| omega_{k} right| &amp;= 2a_{k} sigma_{k}^{2} left| omega_{k} right| - 2 sum_{i in omega_{k}} p_{i}I_{i} + 2 mu_{k} bar{p_{k}} left| omega_{k} right| + 2 bar{p_{k}} mu_{k} left| omega_{k} right| -2 bar{p_{k}} mu_{k} left| omega_{k} right| + 2 epsilon a_{k} left| omega_{k} right| &amp;= 0 a_{k} &amp;= frac{ frac{1}{ left| omega_{k} right|} sum_{i in omega_{k}} p_{i}I_{i} - bar{p_{k}} mu_{k} }{ sigma_{k}^{2} + epsilon } end{aligned} $$ここで，再度$q_{i}$について考えます．$q_{i}$は$a_{k}$及び$b_{k}$に依存していますが，これらの値はウィンドウ$ omega_{k}$の中心座標$k$に対して変化します．従って，$q_{i}$を一意に定めることはできません．そこで，$q_{i}$に影響を及ぼす$ omega_{k}$対して平均値を計算します． . $$ begin{aligned} q_{i} &amp; = frac{1}{ left| omega_{i} right|} sum_{k in omega_{i}} left(a_{k} I_{i} + b_{k} right) &amp;= left( frac{1}{ left| omega_{i} right|} sum_{k in omega_{i}}a_{k} right)I_{i} + frac{1}{ left| omega_{i} right|} sum_{k in omega_{i}}b_{k} &amp;= bar{a_{i}} I_{I} + bar{b_{i}} end{aligned} $$ Rust&#12395;&#12424;&#12427;&#23455;&#35013; . それでは，実際にRustでGuidedFilterを実装していきます．今回，以下のクレートを使用します． . image | num-traits | base64 | . image は画像の読み書き及びデータ表現に，num-traits は画像データ型から計算用のデータ型への変換に，base64はNotebook上への画像出力にそれぞれ用いました． . まず初めに必要なクレートを導入します． . :dep image :dep num-traits :dep base64 //above line is magic for adding crate use image::{GenericImageView, ImageBuffer, Luma, Pixel, Primitive}; use num_traits::NumCast; . 次にNotebook上への画像出力機能を実装します．詳細は以前の記事を参考にしてください． . extern crate image; extern crate base64; pub trait EvcxrResult {fn evcxr_display(&amp;self);} impl EvcxrResult for ImageBuffer&lt;Luma&lt;u8&gt;, Vec&lt;u8&gt;&gt; { fn evcxr_display(&amp;self) { let mut buffer = Vec::new(); image::codecs::jpeg::JpegEncoder::new(&amp;mut buffer).encode(&amp;**self, self.width(), self.height(), image::ColorType::L8).unwrap(); let img = base64::encode(&amp;buffer); println!(&quot;EVCXR_BEGIN_CONTENT image/png n{} nEVCXR_END_CONTENT&quot;, img); } } . 次にあると便利な雑多な関数を実装します．ここでは，所望のデータ型をSubpixelとしたPixel型を取得するcast_subpixel と スケールを調整した$ epsilon$ を計算するcalc_eps を実装します．論文中では画像データを$0 sim 1$に正規化した状態で取り扱っています．今回の実装では，画像データを$0 sim 255$ の範囲で取り扱うため，calc_eps で$ epsilon$の値を適切にスケーリングします． . fn cast_subpixel&lt;S, T&gt;(pixel: &amp;Luma&lt;S&gt;) -&gt; Luma&lt;T&gt; where S: Primitive, T: Primitive, { let Luma([data]) = *pixel; Luma([NumCast::from(data).unwrap(); 1]) } fn cals_eps(eps: f64) -&gt; f64 { let eps = 255.0 * eps; eps * eps } . 次に２次元平滑化処理を行うmean2d を実装します．2次元平滑化処理は . x方向移動平均フィルタ | 転置 | x方向移動平均フィルタ | 転置 | という処理で実現しています． . fn mean2d&lt;I, S&gt;(image: &amp;I, r: u32) -&gt; ImageBuffer&lt;Luma&lt;f64&gt;, Vec&lt;f64&gt;&gt; where I: GenericImageView&lt;Pixel = Luma&lt;S&gt;&gt;, S: Primitive + &#39;static, { fn get_luma_as_f64&lt;I, S&gt;(image: &amp;I, x: u32, y: u32) -&gt; f64 where I: GenericImageView&lt;Pixel = Luma&lt;S&gt;&gt;, S: Primitive + &#39;static, { let Luma(data) = image.get_pixel(x, y); NumCast::from(data[0]).unwrap() } fn calc_mean(head_value: f64, tail_value: f64, r: u32) -&gt; f64 { let den = 2.0 * r as f64 + 1.0; let num = head_value - tail_value; num / den } fn meand2d_tr&lt;I, S&gt;(image: &amp;I, r: u32) -&gt; ImageBuffer&lt;Luma&lt;f64&gt;, Vec&lt;f64&gt;&gt; where I: GenericImageView&lt;Pixel = Luma&lt;S&gt;&gt;, S: Primitive + &#39;static, { let (width, height) = image.dimensions(); let mut result = ImageBuffer::new(height, width); for y in 0..height { let mut head_x: u32 = 0; let mut mid_x: u32 = 0; let mut tail_x: u32 = 0; let mut acc_head_x: f64 = 0.0; let mut acc_tail_x: f64 = 0.0; while mid_x &lt; width { if head_x &lt; width { acc_head_x += get_luma_as_f64(image, head_x, y); head_x += 1; } if r &lt; mid_x { acc_tail_x += get_luma_as_f64(image, tail_x, y); tail_x += 1; } if r &lt;= head_x { let pixel = Luma([calc_mean(acc_head_x, acc_tail_x, r); 1]); result.put_pixel(y, mid_x, pixel); mid_x += 1; } } } result } meand2d_tr(&amp;meand2d_tr(image, r), r) } . 実際にGuidedFilterの処理を行う関数guided_filterです．今回はエッジ保持平滑化フィルタのみを対象としているため，$I = p$（ガイド信号は入力信号と等しい）としています．また，rはウィンドウ領域の半径を，epsは$ epsilon$をそれぞれ表します． . fn guided_filter&lt;I, S&gt;(image: &amp;I, r: u32, eps: f64) -&gt; ImageBuffer&lt;Luma&lt;u8&gt;, Vec&lt;u8&gt;&gt; where I: GenericImageView&lt;Pixel = Luma&lt;S&gt;&gt;, S: Primitive + &#39;static, { let eps = cals_eps(eps); let i = image; let mean_i = mean2d(i, r); let (w, h) = i.dimensions(); let ii = ImageBuffer::from_fn(w, h, |x, y| { cast_subpixel(&amp;i.get_pixel(x, y)).map(|v: f64| v * v) }); let corr_i = mean2d(&amp;ii, r); let var_i = ImageBuffer::from_fn(w, h, |x, y| { mean_i .get_pixel(x, y) .map2(corr_i.get_pixel(x, y), |m, c| c - m * m) }); let a = ImageBuffer::from_fn(w, h, |x, y| { var_i.get_pixel(x, y).map_without_alpha(|v| v / (v + eps)) }); let b = ImageBuffer::from_fn(w, h, |x, y| { mean_i .get_pixel(x, y) .map2(a.get_pixel(x, y), |m, a| (1.0 - a) * m) }); let mean_a = mean2d(&amp;a, r); let mean_b = mean2d(&amp;b, r); let q = ImageBuffer::from_fn(w, h, |x, y| { let i_v: f64 = { let Luma([data]) = i.get_pixel(x, y); NumCast::from(data).unwrap() }; mean_a .get_pixel(x, y) .map2(mean_b.get_pixel(x, y), |a, b| a * i_v + b) }); ImageBuffer::from_fn(w, h, |x, y| -&gt; Luma&lt;u8&gt; { cast_subpixel(q.get_pixel(x, y)) }) } . &#23455;&#34892;&#32080;&#26524; . 入力信号は以下のとおりです． . let img = image::open(&quot;/data/assets/img/2021-09-30-simple-guided-filter-rs/media/input.jpg&quot;).unwrap().to_luma8(); img . r=18, eps=0.1^2 . guided_filter(&amp;img, 18, 0.1) . r=18, eps=0.4^2 . guided_filter(&amp;img, 18, 0.4) . r=18, eps=0.8^2 . guided_filter(&amp;img, 18, 0.8) . &#21442;&#32771; . He, K., Sun, J., &amp; Tang, X. (2012). Guided image filtering. IEEE Transactions on Pattern Analysis and Machine Intelligence, 35(6), 1397–1409. | .",
            "url": "https://lab.ar90n.net/rust/imaceprocessing/2021/09/30/simple-guided-filter-rs.html",
            "relUrl": "/rust/imaceprocessing/2021/09/30/simple-guided-filter-rs.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "USB to TTLx4ケーブルの作成",
            "content": "はじめに . USBハブとUSBシリアルコンバータとを組み合わせることで，USB(1ch) to TTL(4ch) の変換ケーブルを作成しました． . やったこと . type-cコネクタ，USBハブコントローラ基板，USBシリアルコンバータを組み合わせてUSB(1ch) to TTL(4ch)変換ケーブルを作成 | . 回路設計 . 特別なことは特に何もしていません．CH330のデータシートに従って単純に部品を繋いで行きました．type-cコネクタはVCC端子より5vを取得するため， ccを5.1kΩでプルダウンしています． . 今回，EasyEDAを使って回路図を起こしてみたのですが中々使い勝手がよかったです．ブラウザ内で全てが完結するので環境構築が非常に簡単です．私は使用しませんでしたがPCBエディタとの連携機能もあるようです．また，各種ボード(USB1とHUB1)とケーブル(TTL1からTTL4)のピン番号はシステムの都合上割り当てています．そのため，実際にはピン番号はありません．何か良い方法があると良いのですが． . . 実装 . 可能な限りケーブルの様に使いたかったので，USBハブコントローラ背面にカプトンテープを貼り，その上にUSBシリアルコンバータを実装しました． . . 次にケーブルを取り付け全体をグルーガンで固定します． . . 最後に熱収縮ケーブルで全体をさらに固定して完成です． . . 動作確認 . lsusbコマンドを実行すると以下のデバイスを確認できました．意図した通りに動作しているようです． . Bus 020 Device 018: ID 1a40:0101 TERMINUS TECHNOLOGY INC. USB 2.0 Hub Bus 020 Device 021: ID 1a86:7523 1a86 USB2.0-Serial Bus 020 Device 029: ID 1a86:7523 1a86 USB2.0-Serial Bus 020 Device 024: ID 1a86:7523 1a86 USB2.0-Serial Bus 020 Device 010: ID 1a86:7523 1a86 USB2.0-Serial . 後から気が付いたこと . 今回はUSBハブとUSBシリアルコンバータとを組み合わせて所望の機能を実現しました．しかしながら，調べてみると同様の機能をワンチップで実現するICがあるようです．次に同様のものを作る時はこちらを使いたいですね． . 参考 . USB 转串口芯片 CH330 | 組込み技術ラボ | .",
            "url": "https://lab.ar90n.net/hardware/2021/08/26/make-usb-to-ttlx4.html",
            "relUrl": "/hardware/2021/08/26/make-usb-to-ttlx4.html",
            "date": " • Aug 26, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "k3sクラスタ on Raspberry Pi 4",
            "content": "はじめに . Raspberry Pi 4+k3sで構築したクラスタに関するメモです． . やったこと . PC(master) + Raspberry Pi 4(worker)という構成でk3sクラスタを構築 | grafana + ptometheus + loki + node-exporter + promtailという構成で監視基盤を構築 | . Role関連の設定 . クラスタの監視を行うためには適切にサービスディスカバリを行う必要があります．そこで，サービスディスカバリに必要な権限を持つClusterRoleと対応するServiceAccountを定義します． /metricsにアクセスするためにはRoleではなくClusterRoleである必要があるようです．(monitoringネームスペース外にアクセスするから？) . apiVersion: v1 kind: Namespace metadata: name: monitoring apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: monitoring rules: - apiGroups: [&quot;&quot;] resources: - nodes - nodes/proxy - services - endpoints - pods verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] - apiGroups: - extensions resources: - ingresses verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] - nonResourceURLs: [&quot;/metrics&quot;] verbs: [&quot;get&quot;] apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: monitoring roleRef: kind: ClusterRole name: monitoring apiGroup: rbac.authorization.k8s.io subjects: - kind: ServiceAccount name: monitoring namespace: monitoring apiVersion: v1 kind: ServiceAccount metadata: name: monitoring namespace: monitoring . promtailの導入　 . とりあえず，ホストのログ(/var/log/*log)をmasterで稼働しているlokiに送信します．各podのログ収集については中途半端な設定となっています．（多分動かない） 各ログにはhostnameタグにホスト名を設定しています．これは，spec.nodeNameを環境変数NODE_NAMEに設定し，起動引数に--client.external-labels=hostname=$(NODE_NAME)を追加することで実現しています． . lokiはk3sクラスタ内ではなく，master上のDockerコンテナとしてホストされています．また，promtailはworkerとmaster両ノードにデプロイされます． そのため，両環境下からk3s-masterの名前解決を行うため，dnsPolicyをNoneとして明示的にdnsサーバーを設定しています． これは，ClusterFirstではクラスタ外にあるk3s-masterの名前解決を行うことができず，Defaultではworkerとmasterとで共通の舐め解決設定を作り出すことができなかったためです． . apiVersion: v1 kind: ConfigMap metadata: name: promtail-config namespace: monitoring data: config.yaml: | server: http_listen_port: 9080 grpc_listen_port: 0 positions: filename: /tmp/positions.yaml clients: - url: http://k3s-master:3100/loki/api/v1/push scrape_configs: - job_name: system static_configs: - targets: - localhost labels: job: varlogs __path__: /var/log/*log - job_name: kubernetes-pods-app kubernetes_sd_configs: - role: pod apiVersion: apps/v1 kind: DaemonSet metadata: name: promtail namespace: monitoring spec: selector: matchLabels: app: promtail template: metadata: labels: app: promtail spec: dnsPolicy: None dnsConfig: nameservers: - 10.0.100.1 serviceAccountName: monitoring containers: - name: promtail image: grafana/promtail:latest env: - name: TZ value: Asia/Tokyo - name: NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName args: - --config.file=/etc/promtail/config.yaml - --client.external-labels=hostname=$(NODE_NAME) ports: - name: webui containerPort: 9080 volumeMounts: - name: config-volume mountPath: /etc/promtail - name: varlog mountPath: /var/log - name: secret-volume mountPath: /var/run/secrets - name: run mountPath: /run/promtail volumes: - name: config-volume configMap: name: promtail-config - name: varlog hostPath: path: /var/log - name: secret-volume hostPath: path: /var/run/secrets - name: run hostPath: path: /run/promtail . node-exporterの導入 . node-exporterもworkerとmaster両環境にデプロイされます． . apiVersion: apps/v1 kind: DaemonSet metadata: name: node-exporter namespace: monitoring spec: selector: matchLabels: app: node-exporter template: metadata: labels: app: node-exporter annotations: prometheus.io/scrape: &#39;true&#39; prometheus.io/port: &#39;9100&#39; prometheus.io/path: /metrics spec: dnsPolicy: Default serviceAccountName: monitoring containers: - name: node-exporter image: prom/node-exporter:latest env: - name: TZ value: Asia/Tokyo - name: NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName args: - --path.procfs=/host/proc - --path.sysfs=/host/sys - --collector.filesystem.ignored-mount-points - ^/(sys|proc|dev|host|etc|rootfs/var/lib/docker/containers|rootfs/var/lib/docker/overlay2|rootfs/run/docker/netns|rootfs/var/lib/docker/aufs)($$|/) ports: - containerPort: 9100 name: http volumeMounts: - name: proc mountPath: /host/proc - name: sys mountPath: /host/sys - name: rootfs mountPath: /rootfs volumes: - name: proc hostPath: path: /proc - name: sys hostPath: path: /sys - name: rootfs hostPath: path: /rootfs . loki，prometheus，grafanaの導入 . これらのソフトウェアはDockerコンテナとしてホストされています．docker-compose.ymlは以下の通りです． . version: &quot;3.2&quot; networks: monitoring: services: loki: image: grafana/loki:latest ports: - &quot;3100:3100&quot; command: -config.file=/etc/loki/local-config.yaml volumes: - type: bind source: ./loki/local-config.yml target: /etc/loki/local-config.yaml networks: - monitoring restart: always grafana: image: grafana/grafana:latest ports: - &quot;3000:3000&quot; volumes: - type: bind source: ./grafana/provisioning target: /etc/grafana/provisioning - type: volume source: grafana_data target: /var/lib/grafana networks: - monitoring restart: always volumes: grafana_data: . local-config.yamlは以下の通りです．デフォルトから特に変更していなかったと思います． . auth_enabled: false server: http_listen_port: 3100 ingester: lifecycler: address: 127.0.0.1 ring: kvstore: store: inmemory replication_factor: 1 final_sleep: 0s chunk_idle_period: 1h # Any chunk not receiving new logs in this time will be flushed max_chunk_age: 1h # All chunks will be flushed when they hit this age, default is 1h chunk_target_size: 1048576 # Loki will attempt to build chunks up to 1.5MB, flushing first if chunk_idle_period or max_chunk_age is reached first chunk_retain_period: 30s # Must be greater than index read cache TTL if using an index cache (Default index read cache TTL is 5m) max_transfer_retries: 0 # Chunk transfers disabled schema_config: configs: - from: 2020-10-24 store: boltdb-shipper object_store: filesystem schema: v11 index: prefix: index_ period: 24h storage_config: boltdb_shipper: active_index_directory: /loki/boltdb-shipper-active cache_location: /loki/boltdb-shipper-cache cache_ttl: 24h # Can be increased for faster performance over longer query periods, uses more disk space shared_store: filesystem filesystem: directory: /loki/chunks compactor: working_directory: /loki/boltdb-shipper-compactor shared_store: filesystem limits_config: reject_old_samples: true reject_old_samples_max_age: 168h chunk_store_config: max_look_back_period: 0s table_manager: retention_deletes_enabled: false retention_period: 0s ruler: storage: type: local local: directory: /loki/rules rule_path: /loki/rules-temp alertmanager_url: http://localhost:9093 ring: kvstore: store: inmemory enable_api: true . 参考 . Lokiとpromtailことはじめ | Kubernetesの全NodeをPrometheusで監視する方法 | .",
            "url": "https://lab.ar90n.net/kubernetes/2021/08/21/k3s-cluster-on-rp4.html",
            "relUrl": "/kubernetes/2021/08/21/k3s-cluster-on-rp4.html",
            "date": " • Aug 21, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Pythonでpingの実装してみる",
            "content": "&#12399;&#12376;&#12417;&#12395; . ネットワークの疎通確認を行う際など，pingコマンドにお世話になっている方は多いと思います．私も勿論その一人です． ですが，実際pingは何をしているのか？という点は前々理解していませんでした．そこで，pythonにてpingのサブセット（エコー要求とエコー応答のみ）を実装してみました． . &#12420;&#12387;&#12383;&#12371;&#12392; . Pythonでpingコマンドのサブセットを実装 | エコー要求に対してエコー応答が返信されることを確認 | . ICMP&#12395;&#12388;&#12356;&#12390; . ICMPとはInternet Control Message Protocolの略称です．名前の通り，インターネットの通信に関する情報の送信に用いられます． pingコマンドは，このプロトコルのエコー要求とエコー応答という二つのメッセージをやりとりすることで，端末間の疎通確認を行います． . エコー要求とエコー応答のパケットフォーマットは以下の通りです． . . なお，これらのメッセージはIPデータグラムのペイロードとして送受信されます． . Python&#12395;&#12424;&#12427;&#23455;&#35013; . &#12456;&#12467;&#12540;&#35201;&#27714;&#12392;&#12456;&#12467;&#12540;&#24540;&#31572;&#12395;&#23550;&#24540;&#12377;&#12427;&#12487;&#12540;&#12479;&#27083;&#36896; . 上述のパケットフォーマットにおけるTypeは，エコー要求では8が，エコー応答では0が設定されます． 従って，以下のようにICMPTypeとして定義することができます． . from enum import Enum class ICMPType(Enum): ECHOREPLY = 0 ECHO = 8 def __int__(self): return self.value . また，パケットフォーマットからチェックサムフィールドを確認することができます． このチェックサムは以下の手順で計算します． . チェックサムフィールドを0で埋める | パケットを16ビット単位で区切る（パケット長が奇数バイトである場合は0x00を末尾に追加） | 16ビット単位で区切ったデータを1の補数で加算していき合計値を求める | 加算結果の1の補数を最終結果とする．この時，0の表現としては0xffffを用いる． | 以上の手順でチェックサムを計算する関数calc_checksumを以下のように定義します． . def calc_checksum(data: bytes) -&gt; int: if len(data) % 2 == 1: data += b&quot; x00&quot; u16_counts = len(data) // 2 checksum = sum(struct.unpack(f&quot;!{u16_counts}H&quot;, data)) while 0xFFFF &lt; checksum: checksum = (checksum &amp; 0xFFFF) + (checksum &gt;&gt; 16) if checksum != 0xFFFF: checksum = ~checksum return checksum &amp; 0xFFFF . 以下に示すICMPEchoがエコー要求とエコー応答を表現するデータ構造となります．checksumがコンストラクタ引数として指定されなかった場合は，calc_checksumにて計算します． . ICMPEchoはネットワークを通して送受信されます．従って，シリアライズを行うto_bytesと，デシリアライズを行うfrom_bytesを実装しています． . from dataclasses import dataclass from typing import Optional import struct @dataclass(frozen=True) class ICMPEcho: type: ICMPType code: int id: int seq: int data: bytes checksum: Optional[int] = None def __post_init__(self): if self.checksum is None: object.__setattr__(self, &quot;checksum&quot;, 0) object.__setattr__(self, &quot;checksum&quot;, calc_checksum(self.to_bytes())) def to_bytes(self) -&gt; bytes: return struct.pack( f&quot;!BBHHH{len(self.data)}s&quot;, int(self.type), self.code, self.checksum, self.id, self.seq, self.data, ) @classmethod def from_bytes(cls, packed: bytes) -&gt; &quot;ICMPEcho&quot;: _type, code, checksum, id, seq = struct.unpack(&quot;!BBHHH&quot;, packed[:8]) type = ICMPType(_type) data = packed[8:] return ICMPEcho(type, code, id, seq, data, checksum=checksum) . Raw&#12477;&#12465;&#12483;&#12488;&#12398;&#20316;&#25104; . TCPやUDPを用いた時と同様，ICMPでもソケットを用いてネットワークプログラミングを行います． しかしながら，ICMPパケットはIPデータグラムのペイロードとするため，IPデータグラムを操作する必要があります． . IPデータグラムの操作はRawソケットを用いることで実現できます．そこで，ソケットを作成する関数raw_socketを以下のように定義しました． socket.socketの第２引数にはsocket.SOCK_RAWを第３引数にはsocket.IPPROTO_ICMPを指定します．これは，RawソケットをICMPから利用することを表していいます． . import socket from contextlib import contextmanager @contextmanager def raw_socket(): sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP) try: yield sock finally: sock.close() . IP&#12487;&#12540;&#12479;&#12464;&#12521;&#12512;&#12398;&#12497;&#12540;&#12473; . Rawソケットによって受信したデータはIPデータグラムです．従って，これを適切にパースし，エコー応答をペイロードとして取り出す必要があります． 今回，以下のようにIPヘッダを表現するIPHeaderと，IPデータグラムをパースするparse_ip_datagram関数を実装しました． parse_ip_datagram関数では，受信したデータの先頭２０バイトからIPHeaderインスタンスを作成し，残りのデータをペイロードとします． . from typing import Tuple @dataclass(frozen=True) class IPHeader: v: int hl: int tos: int len: int id: int off: int ttl: int p: int sum: int src: str dst: str @staticmethod def from_bytes(packed: bytes) -&gt; &quot;IPHeader&quot;: v_hl, tos, len, id, off, ttl, p, sum, src, dst = struct.unpack( &quot;!BBHHHBBHII&quot;, packed ) v = v_hl &gt;&gt; 4 hl = v_hl &amp; 0x0F return IPHeader( v, hl, tos, len, id, off, ttl, p, sum, socket.inet_ntoa(src.to_bytes(4, byteorder=&quot;big&quot;)), socket.inet_ntoa(dst.to_bytes(4, byteorder=&quot;big&quot;)), ) def parse_ip_datagram(data: bytes) -&gt; Tuple[IPHeader, bytes]: ip_header = IPHeader.from_bytes(data[:20]) payload = data[20:] return (ip_header, payload) . &#12456;&#12467;&#12540;&#35201;&#27714;&#12398;&#36865;&#20449;&#12392;&#12456;&#12467;&#12540;&#24540;&#31572;&#12398;&#21463;&#20449; . これまで実装してきた関数とデータ構造を用いて，エコー要求を送信しエコー応答を受信する関数pingを実装しました． 以下に示されるように，エコー要求をソケットに書き込み，ソケットから読み取ったエコー応答とIPヘッダを出力します． . def print_response(ip_header: IPHeader, echo_reply: ICMPEcho) -&gt; None: print( f&quot;ping echo reply from {ip_header.src}: icmp_seq={echo_reply.seq} ttl={ip_header.ttl}&quot; ) def ping(host: str, seq: int) -&gt; None: with raw_socket() as sock: packet = ICMPEcho(ICMPType.ECHO, 0, 0, seq, b&quot; xff&quot;).to_bytes() sock.sendto(packet, (host, 0)) ip_header, payload = parse_ip_datagram(sock.recvfrom(4096)[0]) echo_reply = ICMPEcho.from_bytes(payload) print_response(ip_header, echo_reply) . &#23455;&#34892;&#32080;&#26524; . 実際に8.8.8.8に対してpingを呼び出した結果を以下に示します． エコー要求に対して適切なエコー応答が帰ってきていることが確認できます． . import time for i in range(10): ping(&quot;8.8.8.8&quot;, i) time.sleep(1) . ping echo reply from 8.8.8.8: icmp_seq=0 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=1 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=2 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=3 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=4 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=5 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=6 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=7 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=8 ttl=37 ping echo reply from 8.8.8.8: icmp_seq=9 ttl=37 . &#21442;&#32771; . 村山公保，2004年，基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版），オーム社 | .",
            "url": "https://lab.ar90n.net/python/network/2021/08/01/writing-simple-ping-example.html",
            "relUrl": "/python/network/2021/08/01/writing-simple-ping-example.html",
            "date": " • Aug 1, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "paaaaathによる統一的なファイルアクセス",
            "content": "&#12399;&#12376;&#12417;&#12395; . 以前の記事で，smart_openによって統一的にファイルアクセスが可能であることを紹介しました． しかしながら，//を適切に扱うことができないため，URLを扱うには問題がありました． そこで，この問題を解決しsmart_openをラップしたpaaaaathを作成しました． . &#12420;&#12387;&#12383;&#12371;&#12392; . paaaaathの導入 | paaaaathによるクラウドストレージ上のファイルを操作 | . paaaaath&#12395;&#12388;&#12356;&#12390; . paaaaathはローカルマシン上のファイルパスのみでは無く，http, s3, gcsといったプロトコルのURLもpathlib.Pathと同様に取り扱うことができます．ファイルの読み書きはsmart_openに処理を委譲することで実現します．また，s3, gcsについては，mkdir, iterdirs, exitsといった処理にも対応しています．サポートしている機能の詳細については，リポジトリを確認してくさい． . 以下にpipを用いたpaaaaathの導入方法を示します．ここでは，extrasとしてallを指定しました．ほかにも，http, gcs,s3 が指定可能です．allはこれら全てを指定することと同義です． . $ pip install paaaaath[all] . &#12463;&#12521;&#12454;&#12489;&#12473;&#12488;&#12524;&#12540;&#12472;&#65292;Web&#12363;&#12425;&#12501;&#12449;&#12452;&#12523;&#12434;&#35501;&#12415;&#36796;&#12416; . smart_openによるサンプルをpaaaaathを用いて書き直しました．Pathlikeオブジェクトとして取り扱うことができるので，全体的にシンプルになっていることが確認できると思います．こちらも，事前に適切な認証情報を設定しておく必要があります． . from paaaaath import Path import matplotlib.pyplot as plt import imageio sources = { &quot;S3&quot;: &quot;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;HTTP&quot;: &quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;FILESYSTEM&quot;: &quot;/tmp/LC80030172015001LGN00_BQA.TIF&quot; } for protocol, url in sources.items(): img = imageio.imread(Path(url).read_bytes()) plt.figure() plt.title(f&quot;from {protocol}&quot;) plt.imshow(img, cmap=&#39;gray&#39;) . &#12463;&#12521;&#12454;&#12489;&#12473;&#12488;&#12524;&#12540;&#12472;&#19978;&#12398;&#12501;&#12449;&#12452;&#12523;&#12434;&#25805;&#20316;&#12377;&#12427; . paaaaathを用いてクラウドストレージ上のファイルを読み書きする例を以下に示します． . sample_path = Path(&quot;s3://paaaaath-examples/sample.txt&quot;) sample_path.write_text(&quot;paaaaath example&quot;) assert sample_path.read_text() == &quot;paaaaath example&quot; . また，paaaaathはPathlikeオブジェクトを提供します．そのため，単純なファイルの読み書きだけでは無く，より多くの機能を提供することが可能です．以下に，iterdirを用いてクラウドストレージ上のファイル一覧を取得する例を示します． . paths = list(Path(sources[&quot;S3&quot;]).parent.iterdir()) assert paths[0].exists() paths . [S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B1.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B1.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B10.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B10.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B11.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B11.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B2.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B2.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B3.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B3.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B4.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B4.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B5.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B5.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B6.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B6.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B7.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B7.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B8.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B8.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B9.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B9.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF.ovr&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_MTL.json&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_MTL.txt&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_thumb_large.jpg&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_thumb_small.jpg&#39;), S3Path(&#39;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/index.html&#39;)] . &#21442;&#32771; . smart_open | .",
            "url": "https://lab.ar90n.net/cloud/python/aws/gcp/2021/06/06/accessing-file-wiht-unified-pythonic-api2.html",
            "relUrl": "/cloud/python/aws/gcp/2021/06/06/accessing-file-wiht-unified-pythonic-api2.html",
            "date": " • Jun 6, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
            "content": "&#12399;&#12376;&#12417;&#12395; . 多峰性のある分布表現する方法として，ガウス分布の線形結合を用いる混合ガウスモデルが広く知られています． しかしがなら，観測したサンプルから混合ガウスモデルのパラメータを解析的の求めることはできません． そのため，EMアルゴリズム等を用いて数値計算的にパラメータを推定します． . EMアルゴリズムを用いた混合ガウスモデルのパラメータ推定は多くの資料で解説されています． これらの資料を読み解こうと何度か挑戦しましたが，どうもしっくりと来ませんでした． ですが，参考[1]述べられている，線形結合の重みとしてソフトマックス関数を用いる方法がとても理解しやすかったので，自分なりの理解をまとめました． . &#12420;&#12387;&#12383;&#12371;&#12392; . 線形結合の重みとしてソフトマックス関数を用いた場合における各パラメータの導関数を計算 | 勾配法によって混合ガウスモデルのパラメータを推定 | EMアルゴリズムによって混合ガウスモデルのパラメータを推定 | . &#28151;&#21512;&#12460;&#12454;&#12473;&#12514;&#12487;&#12523;&#12395;&#12388;&#12356;&#12390; . 平均を$ mu$，標準偏差を$ sigma$としたとき，ガウス分布$ phi left(x; mu, sigma right)$は以下の様に表されます． . $$ begin{aligned} phi left(x; mu, sigma right) &amp; = frac{1}{ sqrt{2 pi sigma^{2}}} exp{ left(- frac{ left(x - mu right)^{2}}{2 sigma^{2}} right)} end{aligned} $$この時，ガウス分布の線形結合からなる混合ガウスモデル$q left(x; vec{ theta} right)$は以下の様に表すことができます． . $$ begin{aligned} q left(x; vec{ theta} right) &amp;= sum_{l=1}^{m} w_{l} phi left(x; mu_{l}, sigma_{l} right) end{aligned} $$ここで，$ vec{ theta} = left(w_{1}, dots, w_{m}, mu_{1}, dots, mu_{m}, sigma_{1}, dots, sigma_{m} right)$であり，$w_{l}$は線形結合の重みを，$ mu_{l}$は各ガウス分布の平均を，$ sigma_{l}$は各ガウス分布の標準偏差をそれぞれ表します． . $q left(x; vec{ theta} right)$ が分布であるためには，$x$に対して . $$ begin{aligned} q left(x; vec{ theta} right) &amp; geq 0 int q left(x; vec{ theta} right) &amp;= 1 end{aligned} $$である必要があります．従って，$w_{1}, dots, w_{m}$は以下の条件を満たす必要があります． . $$ begin{aligned} w_{1} dots w_{m} &amp; geq 0 sum_{l=1}^{m} w_{l} &amp;= 1 end{aligned} $$次に最尤推定によってパラメータ$ vec{ theta}$を推定します．ここでは，尤度関数$L left( vec{ theta} right)$を以下の様に定義します． . $$ begin{aligned} L left( vec{ theta} right) &amp;= prod _{i=1}^{n} q left(x_{i}; vec{ theta} right) end{aligned} $$また，$w_{l}$に対する拘束条件を考慮しなくてはなりません．従って，最尤推定量$ vec{ theta}$は以下の様に表されます． . $$ begin{aligned} hat{ vec{ theta}} &amp;= argmax_{ vec{ theta}} L left( vec{ theta} right) &amp; text{subject to } begin{cases} w_{1} dots w_{m} &amp; geq 0 sum_{l=1}^{m} w_{l} &amp;= 1 end{cases} end{aligned} $$拘束条件付きの最適化にはラグランジュの未定乗数法が多く用いられていると思います．今回のケースにおいても同様です． . しかしながら，ラグランジュの未定乗数法を用いる方法はあまりしっくり来きませんでした．（理解できなかった） そこで，ここでは参考[1]にある$w_{l}$としてソフトマック関数を用いる方法を採用します．従って$w_{l}$は$ gamma_{l}$を用いて . $$ begin{aligned} w_{l} &amp;= frac{ exp{ left( gamma_{l} right)}}{ sum_{l&#39; = 1}^{m} exp{ left( gamma_{l’} right)}} end{aligned} $$と表現することにします．ソフトマックス関数は上述の拘束条件を満たすため，拘束条件を考えることなく最適化を行うことができます．また，ここでは１次元の混合ガウスモデルについて述べましたが，多次元の場合も同様です． . &#21246;&#37197;&#27861;&#12395;&#12424;&#12427;&#12497;&#12521;&#12513;&#12540;&#12479;&#12398;&#25512;&#23450; . それでは，対数尤度関数$ log L left( vec{ theta} right)$の各パラメータに対する導関数を計算していきます．まずは，$ gamma_{l}$についてです． . $$ begin{aligned} frac{ partial w_{k}}{ partial gamma_{l}} &amp;= frac{ partial}{ partial gamma_{l}} frac{ exp{ left( gamma_{k} right)}}{ sum_{k&#39;=1}^{m} exp{ left( gamma_{k&#39;} right)}} &amp;= frac{ exp{ left( gamma_{k} right)}}{ sum_{k&#39;=1}^{m} exp{ left( gamma_{k&#39;} right)}} delta_{k,l} - frac{ exp{ left( gamma_{k} right)} exp{ left( gamma_{l} right)}}{ left( sum_{k&#39;=1}^{m} exp{ left( gamma_{k&#39;} right)} right)^{2}} &amp;= frac{ exp{ left( gamma_{k} right)}}{ sum_{k&#39;=1}^{m} exp{ left( gamma_{k&#39;} right)}} left( delta_{k,l} - frac{ exp{ left( gamma_{l} right)}}{ sum_{k&#39;=1}^{m} exp{ left( gamma_{k&#39;} right)}} right) &amp;= w_{k} left( delta_{k,l} - w_{l} right) frac{ partial}{ partial gamma_{l}} log L left( vec{ theta} right) &amp;= frac{ partial}{ partial gamma_{l}} sum_{i=1}^{n} log sum_{k}^{m} w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} sum_{k=1}^{m} phi left(x_{i}; mu_{k}, sigma_{k} right) frac{ partial w_{k}}{ partial gamma_{l}} &amp;= sum_{i=1}^{n} frac{ sum_{k=1}^{m} w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} -w_{l} sum_{k=1}^{m} w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} &amp;= sum_{i=1}^{n} frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} - w_{l} end{aligned} $$次に，$ mu_{l}$についてです． . $$ begin{aligned} frac{ partial}{ partial mu_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= frac{1}{ sqrt{2 pi sigma_{k}^{2}}} frac{ partial}{ partial mu_{l}} exp{ left(- frac{ left(x_{i} - mu_{k} right)^{2}}{2 sigma_{k}^{2}} right)} &amp;= frac{1}{ sqrt{2 pi sigma_{k}^{2}}} exp{ left(- frac{ left(x_{i} - mu_{k} right)^{2}}{2 sigma_{k}^{2}} right)} frac{x_{i} - mu_{k}}{ sigma_{k}^{2}} delta_{k,l} &amp;= frac{x_{i} - mu_{k}}{ sigma_{k}^{2}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} frac{ partial}{ partial mu_{l}} log L left( vec{ theta} right) &amp;= frac{ partial}{ partial mu_{l}} sum_{i=1}^{n} log sum_{k}^{m} w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} sum_{k=1}^{m} w_{k} frac{ partial}{ partial mu_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} sum_{k=1}^{m} w_{k} frac{x_{i} - mu_{k}}{ sigma_{k}^{2}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} w_{l} frac{x_{i} - mu_{l}}{ sigma_{l}^{2}} phi left(x_{i}; mu_{l}, sigma_{l} right) &amp;= frac{1}{ sigma_{l}^{2}} sum_{i=1}^{n} left(x_{i} - mu_{l} right) frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right) }{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} end{aligned} $$最後に，$ sigma_{l}$についてです． . $$ begin{aligned} frac{ partial}{ partial sigma_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= frac{1}{ sqrt{2 pi}} frac{ partial}{ partial sigma_{l}} sigma_{k}^{-1} exp{ left(- frac{ left(x_{i} - mu_{k} right)^{2}}{2 sigma_{k}^{2}} right)} &amp;= - frac{1}{ sqrt{2 pi} sigma_{k}^{2}} exp{ left(- frac{ left(x - mu_{k} right)^{2}}{2 sigma_{k}^{2}} right)} delta_{k,l} + frac{ left(x_{i} - mu_{k} right)^{2}}{ sqrt{2 pi} sigma_{k}^{4}} exp{ left(- frac{ left(x - mu_{k} right)^{2}}{2 sigma_{k}^{2}} right)} delta_{k,l} &amp;= frac{ left(x_{i} - mu_{k} right)^{2} - sigma_{k}^{2}}{ sigma_{k}^{3}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} frac{ partial}{ partial sigma_{l}} log L left( vec{ theta} right) &amp;= frac{ partial}{ partial sigma_{l}} sum_{i=1}^{n} log sum_{k}^{m} w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} sum_{k=1}^{m} w_{k} frac{ partial}{ partial sigma_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} frac{1}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} sum_{k=1}^{m} w_{k} frac{ left(x_{i} - mu_{k} right)^{2} - sigma_{k}^{2}}{ sigma_{k}^{3}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} &amp;= frac{1}{ sigma_{l}^{3}} sum_{i=1}^{n} left( left(x_{i} - mu_{l} right)^{2} - sigma_{l}^{2} right) frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} end{aligned} $$ここで， . $$ begin{aligned} eta_{i,l} &amp;= frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{ sum_{k&#39;=1}^{m} w_{k&#39;} phi left(x_{i}; mu_{k&#39;}, sigma_{k&#39;} right)} end{aligned} $$と置きます．すると最終的な導関数は以下の様に表されます． . $$ begin{aligned} frac{ partial}{ partial gamma_{l}} log L left( vec{ theta} right) &amp;= sum_{i=1}^{n} eta_{i,l} - w_{l} frac{ partial}{ partial mu_{l}} log L left( vec{ theta} right) &amp;= frac{1}{ sigma_{l}^{2}} sum_{i=1}^{n} left(x_{i} - mu_{l} right) eta_{i,l} frac{ partial}{ partial sigma_{l}} log L left( vec{ theta} right) &amp;= frac{1}{ sigma_{l}^{3}} sum_{i=1}^{n} left( left(x_{i} - mu_{l} right)^{2} - sigma_{l}^{2} right) eta_{i,l} end{aligned} $$次に勾配法を用いてパラメータの推定を行っていきます．具体的な手順は以下の通りです． . $ hat{ gamma_{l}}$, $ hat{ mu_{l}}$, $ hat{ sigma_{l}}$をランダムな値で初期化 | 以下に示す様にパラメータを更新 $$ begin{aligned} hat{ gamma_{l}} &amp;= hat{ gamma_{l}} + epsilon frac{ partial}{ partial gamma_{l}} log L left( vec{ theta} right) hat{ mu_{l}} &amp;= hat{ mu_{l}} + epsilon frac{ partial}{ partial mu_{l}} log L left( vec{ theta} right) hat{ sigma_{l}} &amp;= hat{ sigma_{l}} + epsilon frac{ partial}{ partial sigma_{l}} log L left( vec{ theta} right) end{aligned} $$ | 一定回数または収束するまで2.を繰り返す | 実際にパラメータ推定に関するコードを記述する前に，推定を行うデータを作成します． 今回，$ vec{ mu} = left(3.1, -1.3, 0.5 right)$, $ vec{ sigma} = left(0.8, 1.0, 0.5 right)$, $ vec{w} = left(0.25, 0.25, 0.5 right)$として，2048個の標本をサンプリングすることで検証用のデータを作成しました． . import numpy as np np.random.seed(99) mus = np.array([3.1, -1.3, 0.5]) sigmas = np.array([0.8, 1.0, 0.5]) ns = np.array([512, 512, 1024]) N = np.sum(ns) ws = ns / N data = [np.random.normal(m, s, n) for n, m, s in zip(ns, mus, sigmas)] all_data = np.hstack(data) . 勾配法によるパラメータ推定を行います．train_grad が上述したパラメータ推定の根幹になります． ここでは，$ epsilon = 0.0001$とし，パラメータの変化量の絶対値和が一定値以下となる場合を収束と判定しています． . def phi(xs, mus, sigmas): num = np.exp(-0.5 * ((xs - mus[:,np.newaxis]) / sigmas[:,np.newaxis]) ** 2.0) den = np.sqrt(2 * np.pi) * sigmas[:,np.newaxis] return num / den def eta(xs, ws, mus, sigmas): num = ws[:, np.newaxis] * phi(xs, mus, sigmas) den = np.sum(num, axis=0) return num / den def softmax(gammas): num = np.exp(gammas) den = np.sum(num, axis=0) return num / den def grad_gamma(etas, ws): return np.sum(etas, axis=1) - etas.shape[1] * ws def grad_mu(xs, etas, mus, sigmas): num = np.sum((xs - mus[:, np.newaxis]) * etas, axis=1) den =sigmas ** 2.0 return num / den def grad_sigma(xs, etas, mus, sigmas): num = np.sum((((xs - mus[:, np.newaxis]) / sigmas[:,np.newaxis]) ** 2.0 - 1.0) * etas, axis=1) den = sigmas return num / den def train_grad(xs): mus_hat = 2 * np.max(np.abs(xs)) * (np.random.rand(3) - 0.5) sigmas_hat = np.random.rand(3) gammas_hat = np.random.rand(3) eps = 0.0001 loss = float(&#39;inf&#39;) criteria = 1e-10 iter = 0; while iter &lt; 30000: ws_hat = softmax(gammas_hat) etas_hat = eta(xs, ws_hat, mus_hat, sigmas_hat) delta_gammas = eps * grad_gamma(etas_hat, ws_hat) delta_mus = eps * grad_mu(xs, etas_hat, mus_hat, sigmas_hat) delta_sigmas = eps * grad_sigma(xs, etas_hat, mus_hat, sigmas_hat) gammas_hat += delta_gammas mus_hat += delta_mus sigmas_hat += delta_sigmas loss = np.sum(np.abs(np.hstack([delta_gammas, delta_mus, delta_sigmas]))) if loss &lt; criteria: break iter += 1 ws_hat = softmax(gammas_hat) return loss, iter, (ws_hat, mus_hat, sigmas_hat) loss, iter, (ws_hat_grad, mus_hat_grad, sigmas_hat_grad) = train_grad(all_data) print(f&quot;loss: {loss}, iterations: {iter}&quot;) . loss: 9.995055674503072e-08, iterations: 16943 . 最後に推定したパラメータws_hat_grad, mus_hat_grad, sigmas_hat_grad を用いた分布と，訓練データとをプロットして比較します． 勾配法による推定は，パラメータの並びについて曖昧さがあります．これは，$ hat{w_{l}}$と$w_{l}$とが必ずしも対応するとは限らないことを意味します．（他のパラメータも同様） . そこで，プロットに先立ちws_hat_grad, mus_hat_grad, sigmas_hat_gradとws, mus, sigmasとを比較して，並び順を入れ変えることでこの問題に対応します． この処理はpermute にて行われます． . import altair as alt import pandas as pd def permute(ws, mus, sigmas, ws_hat, mus_hat, sigmas_hat): preds = np.vstack([ws_hat, mus_hat, sigmas_hat]) acts = np.vstack([ws, mus, sigmas]) corr = preds.T @ acts / (np.linalg.norm(preds, axis=0)[:, np.newaxis] @ np.linalg.norm(acts, axis=0)[np.newaxis,:]) perm = np.argmax(corr, axis=0) ws_hat = ws_hat[perm] mus_hat = mus_hat[perm] sigmas_hat = sigmas_hat[perm] return (ws_hat, mus_hat, sigmas_hat) def plot(data, ws_hat, mus_hat, sigmas_hat): bins = np.linspace(-6, 6, 128) hists = {f&quot;Class {i}&quot;: (128 / (12 * N)) * np.histogram(d, bins=bins)[0] for i, d in enumerate(data)} bin_centers = (bins[:-1] + bins[1:]) / 2 bars = alt.Chart(pd.DataFrame({ &quot;Bin&quot;: bin_centers, **hists, })).transform_fold( fold=[f&quot;Class {i}&quot; for i in range(len(data))], as_=[&quot;Class&quot;, &quot;Probability&quot;] ).mark_bar(opacity=0.5).encode( alt.X(&quot;Bin:Q&quot;), alt.Y(&quot;Probability:Q&quot;), alt.Color(&#39;Class:N&#39;) ) envelopes = {f&quot;Class {i}&quot;: v for i, v in enumerate(ws_hat[:, np.newaxis] * phi(bin_centers, mus_hat, sigmas_hat))} lines = alt.Chart( pd.DataFrame({ &quot;Bin&quot;: bin_centers, **envelopes, })).transform_fold( fold=[f&quot;Class {i}&quot; for i in range(len(data))], as_=[&quot;Class&quot;, &quot;Probability&quot;] ).mark_line(size=3).encode( alt.X(&quot;Bin:Q&quot;), alt.Y(&quot;Probability:Q&quot;), alt.Color(&#39;Class:N&#39;) ) return bars + lines ws_hat_grad, mus_hat_grad, sigmas_hat_grad = permute(ws, mus, sigmas, ws_hat_grad, mus_hat_grad, sigmas_hat_grad) plot(data, ws_hat_grad, mus_hat_grad, sigmas_hat_grad) . 以上の結果より，適切に推定できていることが確認できました．しかしながら，勾配法による方法は . 初期値によっては推定に失敗する場合がある | $ epsilon$の選択によっては推定に失敗する場合がある | 収束が遅い | . という問題があります．これらの問題に対応するため，EMアルゴリズムによるパラメータ推定を以下に述べます． . EM&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;&#12395;&#12424;&#12427;&#12497;&#12521;&#12513;&#12540;&#12479;&#12398;&#25512;&#23450; . 次にEMアルゴリズムによるパラメータの推定を行います．EMアルゴリズムは混合ガウスモデルのパラメータ推定以外にも利用可能な汎用的なアルゴリズムです．しかしながら，ここではあまり深入りせずに混合ガウスモデルのパラメータ推定方法の一つとして取り扱います． . EMアルゴリズムはEステップとMステップを交互に繰り返すことで実現します．両ステップについての詳細を以下に述べます． . E&#12473;&#12486;&#12483;&#12503; . Eステップでは，対数尤度関数$ log L left( vec{ theta} right)$に対して，現在の推定値$ hat{ vec{ theta}}$で接する下界$b left( vec{ theta} right)$を求めます．すなわち，$b left( vec{ theta} right)$は以下の関係を満たす必要があります． . $$ begin{aligned} b left( vec{ theta} right) &amp; leq log L left( vec{ theta} right) b left( hat{ vec{ theta}} right) &amp;= log L left( hat{ vec{ theta}} right) end{aligned} $$下界$b left( vec{ theta} right)$を求めると聞くと非常に複雑そうに思えます．しかしながら，混合ガウスモデルのパラメータ推定という用途に限定するとそこまで複雑でもありません．まず，対数尤度関数$ log L left( vec{ theta} right)$に対してイェンセンの不等式を適用し，下界$b&#39; left( vec{ theta}; bf{A} right)$を求めていきます．ここで，$ bf{A} = left {a_{i,l} right }$であり，$b left( vec{ theta} right) = b&#39; left( vec{ theta}; hat{ bf{A}} right)$であるとします． . $$ begin{aligned} log L left( vec{ theta} right) &amp;= sum_{i=1}^{n} log sum_{l}^{m} w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right) &amp;= sum_{i=1}^{n} log sum_{l}^{m} a_{i,l} frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{a_{i,l}} &amp; geq sum_{i=1}^{n} sum_{l}^{m} a_{i,l} log frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{a_{i,l}} &amp;= b&#39; left( vec{ theta}; bf{A} right) end{aligned} $$次に，$b&#39; left( hat{ vec{ theta}}; hat{ bf{A}} right) = log L left( hat{ vec{ theta}} right)$となる$ hat{ bf{A}}$を求めます． $$ begin{aligned} b&#39; left( hat{ vec{ theta}}; bf{A} right)　&amp;= sum_{i=1}^{n} sum_{l}^{m} a_{i,l} log frac{ hat{w_{l}} phi left(x_{i}; hat{ mu_{l}}, hat{ sigma_{l}} right)}{a_{i,l}} &amp; text{ここで$ hat{ vec{ theta}}$に対する$ eta_{i,l} $である$ hat{ eta}_{i,l}$を考えます} hat{ eta}_{i,l} &amp;= frac{ hat{w}_{l} phi left(x_{i}; hat{ mu}_{l}, hat{ sigma}_{l} right)}{ sum_{k&#39;=1}^{m} hat{w}_{k&#39;} phi left(x_{i}; hat{ mu}_{k&#39;}, hat{ sigma}_{k&#39;} right)} &amp; text{そして$a_{i,l} = hat{ eta}_{i,l}$とすると} b&#39; left( hat{ vec{ theta}}; bf{A} right)　&amp;= sum_{i=1}^{n} sum_{l}^{m} hat{ eta}_{i,l} log frac{ hat{w_{l}} phi left(x_{i}; hat{ mu_{l}}, hat{ sigma_{l}} right)}{ hat{ eta}_{i,l}} &amp;= sum_{i=1}^{n} sum_{l}^{m} hat{ eta}_{i,l} log sum_{l&#39;=1}^{m} hat{w}_{l&#39;} phi left(x_{i}; hat{ mu}_{l&#39;}, hat{ sigma}_{l&#39;} right) &amp;= left( sum_{l}^{m} hat{ eta}_{i,l} right) sum_{i=1}^{n} log sum_{l&#39;=1}^{m} hat{w}_{l&#39;} phi left(x_{i}; hat{ mu}_{l&#39;}, hat{ sigma}_{l&#39;} right) &amp;= sum_{i=1}^{n} log sum_{l&#39;=1}^{m} hat{w}_{l&#39;} phi left(x_{i}; hat{ mu}_{l&#39;}, hat{ sigma}_{l&#39;} right) &amp;= log L left( vec{ theta} right) end{aligned} $$ . 従って，$ hat{ bf{A}} = left { hat{ eta}_{i,l} right }$とすると， . $$ begin{aligned} b left( vec{ theta} right) &amp;= b&#39; left( vec{ theta}; hat{ bf{A}} right) &amp;= sum_{i=1}^{n} sum_{l}^{m} hat{ eta}_{i,l} log frac{w_{l} phi left(x_{i}; mu_{l}, sigma_{l} right)}{ hat{ eta}_{i,l}} end{aligned} $$以上の様に，下界$b left( vec{ theta} right)$を求めることは，現在の推定値$ hat{ vec{ theta}}$を用いて$ hat{ eta}_{i,l}$を求めることで実現します． . M&#12473;&#12486;&#12483;&#12503; . Mステップでは，$b left( vec{ theta} right)$が最大となる$ hat{ theta}&#39;$を求めます．$ hat{ theta}&#39;$は$b left( vec{ theta} right)$の各パラメータに対する導関数が$0$となる$ theta$を採用します．まずは， $ gamma_{l}$についてです . $$ begin{aligned} frac{ partial}{ partial gamma_{l}} b left( vec{ theta} right) &amp;= frac{ partial}{ partial gamma_{l}} sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} log frac{w_{k} phi left(x_{i}; mu_{k}, { sigma_{k}} right)}{ hat{ eta}_{i,k}} &amp;= sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} frac{ hat{ eta}_{i,k}}{w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)} frac{ phi left(x_{i}; mu_{k}, sigma_{k} right)}{ gamma_{l}} frac{ partial w_{k}}{ partial gamma_{l}} &amp;= sum_{i=1}^{n} sum_{k}^{m} frac{ hat{ eta}_{i,k}}{w_{k}} w_{k} left( delta_{k,l} - w_{l} right) &amp;= sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} delta_{k,l} - w_{l} hat{ eta}_{i,k} &amp;= sum_{i=1}^{n} hat{ eta}_{i,l} - w_{l} left( sum_{k}^{m} hat{ eta}_{i,k} right) &amp;= sum_{i=1}^{n} hat{ eta}_{i,l} - w_{l} &amp; text{$ frac{ partial}{ partial gamma_{l}} b left( hat{ vec{ theta}} right) = 0$より} sum_{i=1}^{n} hat{w}_{l} &amp;= sum_{i=1}^{n} hat{ eta}_{i,l} n hat{w}_{l} &amp;= sum_{i=1}^{n} hat{ eta}_{i,l} hat{w}_{l} &amp;= frac{1}{n} sum_{i=1}^{n} hat{ eta}_{i,l} end{aligned} $$次に，$ mu_{l}$についてです． . $$ begin{aligned} frac{ partial}{ partial mu_{l}} b left( vec{ theta} right) &amp;= frac{ partial}{ partial mu_{l}} sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} log frac{w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)}{ hat{ eta}_{i,k}} &amp;= sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} frac{ hat{ eta}_{i,k}}{w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)} frac{ w_{k}}{ hat{ eta}_{i,k} } frac{ partial }{ partial mu_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} sum_{k}^{m} frac{ hat{ eta}_{i,k}}{ phi left(x_{i}; mu_{k}, sigma_{k} right)} frac{x_{i} - mu_{k}}{ sigma_{k}^{2}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} &amp;= frac{1}{ sigma_{l}^{2}} sum_{i=1}^{n} hat{ eta}_{i,l}x_{i} - hat{ eta}_{i,l} mu_{l} &amp; text{$ frac{ partial}{ partial mu_{l}} b left( hat{ vec{ theta}} right) = 0$より} hat{ mu}_{l} sum_{i=1}^{n} hat{ eta}_{i,l}&amp;= sum_{i=1}^{n} hat{ eta}_{i,l}x_{i} hat{ mu}_{l} &amp;= frac{ sum_{i=1}^{n} hat{ eta}_{i,l}x_{i} }{ sum_{i=1}^{n} hat{ eta}_{i,l}} end{aligned} $$最後に，$ sigma_{l}$についてです． . $$ begin{aligned} frac{ partial}{ partial sigma_{l}} b left( vec{ theta} right) &amp;= frac{ partial}{ partial sigma_{l}} sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} log frac{w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)}{ hat{ eta}_{i,k}} &amp;= sum_{i=1}^{n} sum_{k}^{m} hat{ eta}_{i,k} frac{ hat{ eta}_{i,k}}{w_{k} phi left(x_{i}; mu_{k}, sigma_{k} right)} frac{ w_{k}}{ hat{ eta}_{i,k} } frac{ partial }{ partial sigma_{l}} phi left(x_{i}; mu_{k}, sigma_{k} right) &amp;= sum_{i=1}^{n} sum_{k}^{m} frac{ hat{ eta}_{i,k}}{ phi left(x_{i}; mu_{k}, sigma_{k} right)} frac{ left(x_{i} - mu_{k} right)^{2} - sigma_{k}^{2}}{ sigma_{k}^{3}} phi left(x_{i}; mu_{k}, sigma_{k} right) delta_{k,l} &amp;= frac{1}{ sigma_{l}^{3}} sum_{i=1}^{n} hat{ eta}_{i,l} left(x_{i} - mu_{l} right)^{2} - hat{ eta}_{i,l} sigma_{l}^{2} &amp; text{$ frac{ partial}{ partial mu_{l}} b left( hat{ vec{ theta}} right) = 0$より} hat{ sigma}_{l}^{2} sum_{i=1}^{n} hat{ eta}_{i,l}&amp;= sum_{i=1}^{n} hat{ eta}_{i,l} left(x_{i} - mu_{l} right)^{2} hat{ sigma}_{l} &amp;= sqrt{ frac{ sum_{i=1}^{n} hat{ eta}_{i,l} left(x_{i} - mu_{l} right)^{2}}{ sum_{i=1}^{n} hat{ eta}_{i,l}}} end{aligned} $$まとめると，Mステップでは以下の様にパラメータを更新します． . $$ begin{aligned} hat{w}_{l} &amp;= frac{1}{n} sum_{i=1}^{n} hat{ eta}_{i,l} hat{ mu}_{l} &amp;= frac{ sum_{i=1}^{n} hat{ eta}_{i,l}x_{i} }{ sum_{i=1}^{n} hat{ eta}_{i,l}} hat{ sigma}_{l} &amp;= sqrt{ frac{ sum_{i=1}^{n} hat{ eta}_{i,l} left(x_{i} - mu_{l} right)^{2}}{ sum_{i=1}^{n} hat{ eta}_{i,l}}} end{aligned} $$次にEMアルゴリズムを用いてパラメータの推定を行っていきます．具体的な手順は以下の通りです． . $ hat{ gamma_{l}}$, $ hat{ mu_{l}}$, $ hat{ sigma_{l}}$をランダムな値で初期化 | $ hat{ eta_{i,l}}$を更新し，下界$b left( vec{ theta} right)$を求める（Eステップ） $$ begin{aligned} hat{ eta_{i,l}} &amp;= frac{ hat{w}_{l} phi left(x_{i}; hat{ mu}_{l}, hat{ sigma}_{l} right)}{ sum_{k&#39;=1}^{m} hat{w}_{k&#39;} phi left(x_{i}; hat{ mu}_{k&#39;}, hat{ sigma}_{k&#39;} right)} end{aligned} $$ | 下界$b left( vec{ theta} right)$を最大化する$ hat{ vec{ theta}}&#39;$を求める（Mステップ） $$ begin{aligned} hat{w}_{l} &amp;= frac{1}{n} sum_{i=1}^{n} hat{ eta}_{i,l} hat{ mu}_{l} &amp;= frac{ sum_{i=1}^{n} hat{ eta}_{i,l}x_{i} }{ sum_{i=1}^{n} hat{ eta}_{i,l}} hat{ sigma}_{l} &amp;= sqrt{ frac{ sum_{i=1}^{n} hat{ eta}_{i,l} left(x_{i} - mu_{l} right)^{2}}{ sum_{i=1}^{n} hat{ eta}_{i,l}}} end{aligned} $$ | 一定回数または収束するまで2〜3を繰り返す | EMアルゴリズムによるパラメータ推定を行うコードは以下の通りです．勾配法の時と同様にtrain_em が上述したパラメータ推定の根幹になります． そして，全パラメータの変化量の絶対値和が一定値以下となる場合を収束と判定しています．また，入力については勾配法で用いたものを再度使用します． . def opt_w(etas): return np.average(etas, axis=1) def opt_mu(xs, etas): num = np.sum(etas * xs, axis=1) den = np.sum(etas, axis=1) return num / den def opt_sigma(xs, etas, mus): num = np.sum((xs - mus[:, np.newaxis]) ** 2 * etas, axis=1) den = np.sum(etas, axis=1) return np.sqrt(num / den) def train_em(xs): mus_hat = 2 * np.max(np.abs(xs)) * (np.random.rand(3) - 0.5) sigmas_hat = np.random.rand(3) ws_hat = np.random.rand(3) loss = float(&#39;inf&#39;) criteria = 1e-10 iter = 0; while iter &lt; 10000: # E step etas_hat = eta(xs, ws_hat, mus_hat, sigmas_hat) # M Step delta_ws = ws_hat delta_mus = mus_hat delta_sigmas = sigmas_hat ws_hat = opt_w(etas_hat) mus_hat = opt_mu(xs, etas_hat) sigmas_hat = opt_sigma(xs, etas_hat, mus_hat) delta_ws -= ws_hat delta_mus -= mus_hat delta_sigmas -= sigmas_hat loss = np.sum(np.abs(np.hstack([delta_ws, delta_mus, delta_sigmas]))) if loss &lt; criteria: break iter += 1 return loss, iter, (ws_hat, mus_hat, sigmas_hat) loss, iter, (ws_hat_em, mus_hat_em, sigmas_hat_em) = train_em(all_data) print(f&quot;loss: {loss}, iterations: {iter}&quot;) print(ws_hat_em, mus_hat_em, sigmas_hat_em) . loss: 9.965148151103165e-11, iterations: 1254 [0.47878854 0.27353509 0.24767637] [ 0.51716133 -1.10900049 3.16175044] [0.51084106 1.06776561 0.76372732] . 勾配法と比較して，イテレーション回数が10分の1程度であることが確認できます． 勾配法の時と同様に訓練データと推定したパラメータによる分布とをプロットして確認します． . ws_hat_em, mus_hat_em, sigmas_hat_em = permute(ws, mus, sigmas, ws_hat_em, mus_hat_em, sigmas_hat_em) plot(data, ws_hat_em, mus_hat_em, sigmas_hat_em) . 以上の結果より，適切に推定できていることが確認できました．EMアルゴリズムの勾配法に対する利点としては， . $ epsilon$を設定する必要がない | 勾配法よりも高速に収束する | . という点があげられます．しかしながら， . 初期値によっては推定に失敗する場合がある | . という問題は継続して存在します．したがって，実用を考えると複数の初期値でパラメータを推定するなどの工夫が必要になるかもしれません． . &#21442;&#32771;&#25991;&#29486; . 杉山将，統計的機械学習 : 生成モデルに基づくパターン認識，オーム社，2009 |",
            "url": "https://lab.ar90n.net/machinelearning/signalprocessing/python/2021/05/30/gaussian-mixture-model-with-softmax.html",
            "relUrl": "/machinelearning/signalprocessing/python/2021/05/30/gaussian-mixture-model-with-softmax.html",
            "date": " • May 30, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
            "content": "はじめに . 普段SSHで管理しているサーバーが，ネットワーク関連のトラブルに見舞われると，いつも通りにログインできず色々と大変です． そこで，Ubuntu 20.04をシリアルコンソール経由で操作する環境を構築します． . やったこと . USB-TTLケーブルによる代用シリアルケーブルの作成 | udevによるケーブル挿入をトリガーとしたシリアルコンソールの有効化 | . ケーブル作成 . 特殊なケースを除くと，最近のPCにはシリアルポートが付属していません． そこで，２本のUSB-TTL変換ケーブルを直結することでシリアルケーブルの代用とします． 今回，安価に購入可能なこちらのケーブルを使用しました． 代用ケーブルの作成は，両ケーブルのピンソケットを切断し，以下の様に緑と白を交差して結線します． . &lt;赤&gt; - &lt;赤&gt; &lt;緑&gt; - /- &lt;緑&gt; &lt;白&gt; -/ - &lt;白&gt; &lt;黒&gt; - &lt;黒&gt; . 作成したケーブルの動作確認は両端をUSBポートに挿入し，接続したマシンで以下の様にcuコマンドを実行します． 接続が適切に行われると，一方の端末で入力した文字列が他方の端末に表示されると思います． （同一マシンでも可能です） . $ sudo cu -l /dev/ttyUSB0 # &lt;- ttyUSB0の部分は環境によります . シリアルコンソールの有効化 . 代用ケーブルを接続したマシンにて，以下のコマンド実行するとシリアルコンソールを有効化することができます． . $ sudo systemctl enable serial-getty@ttyUSB0.service # &lt;- ttyUSB0の部分は環境によります $ sudo systemctl start serial-getty@ttyUSB0.service # &lt;- ttyUSB0の部分は環境によります . その後，もう一方を接続したマシンにて，cuコマンドを用いて接続します．すると，以下の様にログインプロンプトが確認できます．(slimeはホスト名です) . $ sudo cu -l /dev/ttyUSB0 # &lt;- ttyUSB0の部分は環境によります Password: Connected. slime login: . udevによるシリアルコンソールの自動起動 . 常時ケーブルを刺しっぱなしにするのは不便なので，ケーブルを挿入したタイミングで，シリアルコンソールが有効化されるように設定します． ですが，普通にUSB-TTL変換ケーブルを使いたい時もあるので，単純にttyUSB0を関しするだけでは都合が悪そうです． そこで，特定のVendor IDとProduct IDを持つUSB-Serialデバイスが接続された場合のみシリアルコンソールを有効化します． Vendor IDとProduct IDは以下のコマンドで確認します． . $ udevadm test-builtin usb_id /sys/class/tty/ttyUSB0 Load module index Parsed configuration file /usr/lib/systemd/network/99-default.link Parsed configuration file /usr/lib/systemd/network/73-usb-net-by-mac.link Created link configuration context. ID_VENDOR=Prolific_Technology_Inc. ID_VENDOR_ENC=Prolific x20Technology x20Inc. ID_VENDOR_ID=067b ID_MODEL=USB-Serial_Controller ID_MODEL_ENC=USB-Serial x20Controller ID_MODEL_ID=2303 ID_REVISION=0300 ID_SERIAL=Prolific_Technology_Inc._USB-Serial_Controller ID_TYPE=generic ID_BUS=usb ID_USB_INTERFACES=:ff0000: ID_USB_INTERFACE_NUM=00 ID_USB_DRIVER=pl2303 Unload module index Unloaded link configuration context. . ID_VENDOR_ID=067b および ID_MODEL_ID=2303 とあるので，Vendor IDが067bかつProduct IDが2303であることが確認できます． これは，今回使用するケーブルはPL2303を使っているためです.従って，PL2303が接続されるとシリアルコンソールが有効化されることになります． . 以上の結果を元に，以下の様にudevの設定を追加します． . $ cat /etc/udev/rules.d/65-serial-console.rules ACTION==&quot;remove&quot;, GOTO=&quot;serial_end&quot; SUBSYSTEM!=&quot;tty&quot;, GOTO=&quot;serial_end&quot; ENV{ID_VENDOR_ID}==&quot;067b&quot;, ENV{ID_MODEL_ID}==&quot;2303&quot;, ENV{SYSTEMD_WANTS}+=&quot;serial-getty@ttyUSB$env{.ID_PORT}.service&quot; LABEL=&quot;serial_end&quot; . 1,2行目は，USB-TTLケーブル挿入時以外は処理をスキップすることを表しています． 4行目はVendor IDが067bかつProduct IDが2303である場合，対応するttyUSBに対してserial-gettyサービスを有効化することを表しています． . 設定後，以下のコマンドでケーブル挿入の前後でserial-getty@ttyUSB0.serviceが有効化されていることを確認できます． . ケーブル挿入前 | . $sudo systemctl status serial-getty@ttyUSB0.service ● serial-getty@ttyUSB0.service - Serial Getty on ttyUSB0 Loaded: loaded (/lib/systemd/system/serial-getty@.service; enabled; vendor preset: enabled) Active: inactive (dead) since Sun 2021-05-23 03:26:14 UTC; 2s ago Docs: man:agetty(8) man:systemd-getty-generator(8) http://0pointer.de/blog/projects/serial-console.html Process: 3803 ExecStart=/sbin/agetty -o -p -- u --keep-baud 115200,38400,9600 ttyUSB0 $TERM (code=killed, signal=HUP) Main PID: 3803 (code=killed, signal=HUP) May 23 03:26:14 slime systemd[1]: Stopped Serial Getty on ttyUSB0. . ケーブル挿入後 | . $ sudo systemctl status serial-getty@ttyUSB0.service ● serial-getty@ttyUSB0.service - Serial Getty on ttyUSB0 Loaded: loaded (/lib/systemd/system/serial-getty@.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2021-05-23 03:26:21 UTC; 1s ago Docs: man:agetty(8) man:systemd-getty-generator(8) http://0pointer.de/blog/projects/serial-console.html Main PID: 4494 (agetty) Tasks: 1 (limit: 76982) Memory: 348.0K CGroup: /system.slice/system-serial x2dgetty.slice/serial-getty@ttyUSB0.service └─4494 /sbin/agetty -o -p -- u --keep-baud 115200,38400,9600 ttyUSB0 vt220 May 23 03:26:21 slime systemd[1]: Started Serial Getty on ttyUSB0. . 参考 . Ubuntu 15.10 でシリアルコンソールを有効にする | Ubuntu Weekly Recipe 第555回　いま，あらためてudev | Raspberry Pi 2 + systemd + udevで、USBデバイス挿入時にサービスを起動する | .",
            "url": "https://lab.ar90n.net/ubuntu/2021/05/26/use-serial-console-in-ubuntu.html",
            "relUrl": "/ubuntu/2021/05/26/use-serial-console-in-ubuntu.html",
            "date": " • May 26, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Rustでレイトレーシングをしてみる",
            "content": "はじめに . Rustの勉強を兼ねて，こちらを参考にレイトレーシングを写経してみました． . メモ . 十分な数のRayを計算しなければ綺麗な画像は得られない．レイトレーシング結果のサンプルで，画素が黒く欠損しているのは十分な数のRayを計算していないから | Rayによってランダムにサンプリングすることで，ブラーやボケやアンチエイリアシングを表現する | 思っていたよりも単純 | . 結果 . 1週目 . | 2週目 . | . 参考 . Ray Tracing in One Weekend | Ray Tracing: the Next Week |",
            "url": "https://lab.ar90n.net/rust/computergraphics/2021/03/30/ray-tracing-in-weekend.html",
            "relUrl": "/rust/computergraphics/2021/03/30/ray-tracing-in-weekend.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "glutinに入門してみる",
            "content": "はじめに . glutin に入門した記録です． Objファイルをロードして，スタンフォードバニーを表示するサンプルプログラムを作成します． . glutinとは . Rustで記述されたOpenGLのラッパーライブラリです． OpenGLのラッパーライブラリには抽象度が高いものから低いものまで様々あります． 本ライブラリは，それらの中でも抽象度が低い，低レベルな機能を提供することを目的としたライブラリです． したがって，OpenGL相当の非常にプリミティブな機能しか提供されていません． . glutinの実装の興味深い点に，ユーザが指定したAPIのバインディングをビルド時に動的に生成する点が挙げられます． この機能の利用方法については， サンプルプログラムの動作を通じて後述します． . サンプルプログラムの解析 . サンプルプログラムの実行 . リポジトリページにある手順に従ってサンプルプログラムを実行します． . $ git clone https://github.com/rust-windowing/glutin $ cd glutin $ cargo run --example window . すると，以下のようなウィンドウが表示されます． . . gl_bindings.rsの生成 . それでは，このサンプルプログラムの詳細をみていきます． . まず，Cargo.tomlを見てみます．すると，以下のようにbuild.rsがbuild scriptが設定されていることが確認できます． . [package] name = &quot;glutin_examples&quot; ... build = &quot;build.rs&quot; ... [build-dependencies] gl_generator = &quot;0.14&quot; . build.rsを確認すると，１２行目から１４行目において，GLES 2.0のバインディングを生成していることが確認できます． この処理は，gl_generatorを用いて実現されています． . use gl_generator::{Api, Fallbacks, Profile, Registry}; use std::env; use std::fs::File; use std::path::PathBuf; fn main() { let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } . 次に，実際にどのようあファイルが生成されているかを確認します． 環境変数OUT_DIRはcargoによって設定されてしまうため，任意の値を設定することができません． そこで，以下のように環境変数名を変更します． . $ git diff diff --git a/glutin_examples/build.rs b/glutin_examples/build.rs index 77f6fa5..4ff7c4e 100644 a/glutin_examples/build.rs +++ b/glutin_examples/build.rs @@ -4,7 +4,7 @@ use std::fs::File; use std::path::PathBuf; fn main() { - let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); + let dest = PathBuf::from(&amp;env::var(&quot;TMP_OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); . そして，ビルドするとgl_bindings.rsというファイルが作成されていることが確認できます． ファイルの内容を確認すると，GLES 2.0に利用されるデータ構造のバインディングか確認できます． . $ TMP_OUT_DIR=`pwd` cargo build --example window $ ls gl_bindings.rs gl_bindings.rs $ head -n 32 gl_bindings.rs mod __gl_imports { pub use std::mem; pub use std::marker::Send; pub use std::os::raw; } pub mod types { #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)] // Common types from OpenGL 1.1 pub type GLenum = super::__gl_imports::raw::c_uint; pub type GLboolean = super::__gl_imports::raw::c_uchar; pub type GLbitfield = super::__gl_imports::raw::c_uint; pub type GLvoid = super::__gl_imports::raw::c_void; pub type GLbyte = super::__gl_imports::raw::c_char; pub type GLshort = super::__gl_imports::raw::c_short; pub type GLint = super::__gl_imports::raw::c_int; pub type GLclampx = super::__gl_imports::raw::c_int; pub type GLubyte = super::__gl_imports::raw::c_uchar; pub type GLushort = super::__gl_imports::raw::c_ushort; pub type GLuint = super::__gl_imports::raw::c_uint; pub type GLsizei = super::__gl_imports::raw::c_int; pub type GLfloat = super::__gl_imports::raw::c_float; pub type GLclampf = super::__gl_imports::raw::c_float; pub type GLdouble = super::__gl_imports::raw::c_double; pub type GLclampd = super::__gl_imports::raw::c_double; pub type GLeglImageOES = *const super::__gl_imports::raw::c_void; pub type GLchar = super::__gl_imports::raw::c_char; pub type GLcharARB = super::__gl_imports::raw::c_char; . 次に，ターゲットのAPIをApi::Glに変更して&#39;gl_bindings.rsを生成してみます. すると，先ほど生成したgl_bindings.rsとは内容が異なることが確認できます． このように，ターゲットや機能に合わせて，バックエンドを静的に切り替えて使用することが可能です． . $ mv gl_bindings.rs gl_bindings_gles2.rs $ git diff diff --git a/glutin_examples/build.rs b/glutin_examples/build.rs index 77f6fa5..7e149bd 100644 a/glutin_examples/build.rs +++ b/glutin_examples/build.rs @@ -4,12 +4,12 @@ use std::fs::File; use std::path::PathBuf; fn main() { - let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); + let dest = PathBuf::from(&amp;env::var(&quot;TMP_OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); - Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, []) + Registry::new(Api::Gl, (3, 3), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } $ TMP_OUT_DIR=`pwd` cargo build --example window $ diff gl_bindings.rs gl_bindings_gles2.rs | head -n 32 121a122 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_ATOMIC_COUNTER_BUFFERS: types::GLenum = 0x92D9; 123a125,126 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_PROGRAM: types::GLenum = 0x8259; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_RESOURCES: types::GLenum = 0x92F5; 128a132 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_VARIABLES: types::GLenum = 0x9305; 129a134,136 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALIASED_POINT_SIZE_RANGE: types::GLenum = 0x846D; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALL_BARRIER_BITS: types::GLenum = 0xFFFFFFFF; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALL_SHADER_BITS: types::GLenum = 0xFFFFFFFF; 130a138 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS: types::GLenum = 0x0D55; 133,135d140 &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND: types::GLenum = 0x1501; &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND_INVERTED: types::GLenum = 0x1504; &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND_REVERSE: types::GLenum = 0x1502; 136a142 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ANY_SAMPLES_PASSED_CONSERVATIVE: types::GLenum = 0x8D6A; 138a145,152 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_SIZE: types::GLenum = 0x92FB; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_STRIDE: types::GLenum = 0x92FE; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BARRIER_BIT: types::GLenum = 0x00001000; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER: types::GLenum = 0x92C0; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_BINDING: types::GLenum = 0x92C1; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_INDEX: types::GLenum = 0x9301; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_SIZE: types::GLenum = 0x92C3; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_START: types::GLenum = 0x92C2; 141,146d154 &lt; #[allow(dead_code, non_upper_case_globals)] pub const BACK_LEFT: types::GLenum = 0x0402; &lt; #[allow(dead_code, non_upper_case_globals)] pub const BACK_RIGHT: types::GLenum = 0x0403; &lt; #[allow(dead_code, non_upper_case_globals)] pub const BGR: types::GLenum = 0x80E0; . ウィンドウの表示とポリゴンの描画 . 先ほど実行したサンプルプログラムに対応するコードはこちらになります． それでは，こちらの内容を先頭から紹介していきます． . まずは，supportモジュールと利用するglutinのモジュールのインポートです． supportモジュールは，ポリゴンの生成と描画，頂点シェーダ，フラグメントシェーダなど，サンプルプログラムに表示された三角形を描画するための処理が含まれています． . mod support; use glutin::event::{Event, WindowEvent}; use glutin::event_loop::{ControlFlow, EventLoop}; use glutin::window::WindowBuilder; use glutin::ContextBuilder; . 次にmain関数です．main関数では，まず初めにイベントループ，ウィンドウ，このウインドウと紐づいたGLコンテキストを作成します． コード中のwindowed_contextとは，ウインドウとこのウィンドウに紐づいたGLコンテキストとを表現する構造体になります． . fn main() { let el = EventLoop::new(); let wb = WindowBuilder::new().with_title(&quot;A fantastic window!&quot;); let windowed_context = ContextBuilder::new().build_windowed(wb, &amp;el).unwrap(); let windowed_context = unsafe { windowed_context.make_current().unwrap() }; println!(&quot;Pixel format of the window&#39;s GL context: {:?}&quot;, windowed_context.get_pixel_format()); ... } . 次にコンテキストの取得を行います．この処理は，support::loadによって実現します． support::loadでは，以下のような処理が実行されます． . 頂点シェーダとフラグメントシェーダのコンパイル | シェーダプログラムの作成 | 三角形のポリゴンを表す頂点バッファオブジェクトと頂点配列オブジェクトの作成 | 上記各種リソースのGLコンテキストへの割り当て | . このコンテキストは上述のGLコンテキストを内部に持ち，各種描画処理を移譲します． . let gl = support::load(&amp;windowed_context.context()); . 最後にイベントハンドラです．このイベントハンドラは先ほど作成したイベントループ渡され，何かイベントが発生するたびに呼び出されます． 従って，イベントハンドラでは，発生したイベントの識別とそのイベントに対応する振る舞いを記述する必要があります． 各イベントに対する振る舞いについては，コード中にコメントとして追記しました． . el.run(move |event, _, control_flow| { println!(&quot;{:?}&quot;, event); *control_flow = ControlFlow::Wait; match event { Event::LoopDestroyed =&gt; return, // イベントループか破棄されたのでインベントハンドラから抜ける Event::WindowEvent { event, .. } =&gt; match event { WindowEvent::Resized(physical_size) =&gt; windowed_context.resize(physical_size), // ウインドウをリサイズ WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit, // ウインドウを閉じる _ =&gt; (), }, Event::RedrawRequested(_) =&gt; { gl.draw_frame([1.0, 0.5, 0.7, 1.0]); // ポリゴンの描画． windowed_context.swap_buffers().unwrap(); // オフスクリーンに描画した結果を表示する } _ =&gt; (), } }); . スタンフォードバニーを表示する . Objファイルを読み取り，スタンフォードバニーを描画するサンプルプログラムを作成しました． このサンプルを実行すると，以下のような画面が表示されます． . . 全体の構成は，glutinのサンプルプログラムを大きく変更はありません， 従って，比較的容易に読み取ることが可能かと思います． しかしながら，幾つか新しい試みを行っているため，それらについて紹介します． . gl_bindings.rsのソースツリーへの取り込み . 前述した通り，gl_bindings.rsはビルド時に動的に生成されます．従って，これらが提供する型を編集時に取得することはできません． そのため，このままではコード補完や静的解析を行うことができません． Rustによる開発では，これらのツールは非常に重要であるため，このままでは非常に辛い開発が強いられます． . そこで，gl_buildings.rsをソースツリーに取り込んでしまうことにしました． 具体的には，以下のようにgl_bindings.rsの保存先を変更します． . fn main() { let mut dest = PathBuf::from(env!(&quot;CARGO_MANIFEST_DIR&quot;)); dest.push(&quot;src&quot;); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); Registry::new(Api::Gl, (3, 1), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } . この変更により，初回のビルド以降は以下のようにgl_bindings.rsがソースツリー内に存在します． 従って，コード補完や静的解析が適切に動作します． . $ ls ./src context.rs gl_bindings.rs main.rs obj.rs shader.rs . 注意点としては，gl_bindings.rsは動的に生成されるものなのでリポジトリに含んではいけないことです． 従って，以下のように.gitignoreに追加します． . $ cat .gitignore src/gl_bindings.rs target . Objファイルについて . Objファイルと呼ばれるファイルフォーマットには様々なものがあります． ここで使用するのは，3Dモデルを表現するために用いられるObjファイルです． また，Objファイルは頂点，面，法線など様々なデータを格納することができます． ここでは，以下のように頂点とそれらによって構成される面のみを対象とします． . v &lt;頂点番号1&gt; &lt;X座標1&gt; &lt;Y座標1&gt; &lt;Z座標1&gt; v &lt;頂点番号2&gt; &lt;X座標2&gt; &lt;Y座標2&gt; &lt;Z座標2&gt; ... f &lt;面番号1&gt; &lt;頂点番号i&gt; &lt;頂点番号j&gt; &lt;頂点番号k&gt; ... . 参考 . glutin |",
            "url": "https://lab.ar90n.net/rust/glutin/opengl/computergraphics/2021/02/01/getting-started-with-glutin.html",
            "relUrl": "/rust/glutin/opengl/computergraphics/2021/02/01/getting-started-with-glutin.html",
            "date": " • Feb 1, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "starshipの導入",
            "content": "Cicaを導入する . startshipを使用するためには，事前にNerdFontを導入する必要があります． そこで，今回はCicaを使用しました． 導入はリリースページから配布されているアーカイブをダウンロードしttfファイルをダブルクリックで完了です． . startshipを導入する . brewを使ってstartshipを導入します． . $ brew install starship . 以下のように良い感じです． . .",
            "url": "https://lab.ar90n.net/tool/2021/01/06/install-starship.html",
            "relUrl": "/tool/2021/01/06/install-starship.html",
            "date": " • Jan 6, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "型レベル整数ライブラリtypenumの紹介",
            "content": "&#12399;&#12376;&#12417;&#12395; . 型レベル整数とは，型によって整数を表現する方法です．この型とは整数を表すi32や文字列を表すStringと同様のものです．すなわち，１を表す型や，2を表す型を定義し，それらによって整数を型レベルで表現します． . 型レベル整数の嬉しい点として，型レベル整数による式はコンパイル時に評価されることが挙げられます．これによって，各種定数を容易に設定することが可能となります． . Rustにて型レベル整数の実装として，typenumというクレートがあります．ここでは，このtypenumの簡単な使用方法を紹介します． . &#12420;&#12387;&#12383;&#12371;&#12392; . typenumによる型レベル整数の定義 | typenumによってサポートされる演算の評価 | . &#23455;&#38555;&#12395;&#22411;&#12524;&#12505;&#12523;&#25972;&#25968;&#12434;&#20351;&#12387;&#12390;&#12415;&#12427; . それでは，実際にtypenumを使用して整数の演算を行っていきます．まず，1+2を計算する例を以下に示します． ここで，P1とP2はそれぞれ1と2を，Sumは加算を表します．また，to_i32()は型レベル整数が示す値をi32へ変換する処理です． . :dep typenum //above line is magic for adding crate use typenum::*; type A = Sum&lt;P1, P2&gt;; // A is P3 assert_eq!(A::to_i32(), 3); // A::to_i32() == 3 . 以上の結果より，適切に型レベルで1+2が計算出来たことがわかります．　次はもう少し複雑な例について考えます．以下に示すコードは，型レベル整数を用いて，((1 + 2 ) * 3 - 4) / 5を計算します．ここで，Quotは除算を，Diffは減算を，Prodは乗算を表します． . use typenum::*; type A = Quot&lt;Diff&lt;Prod&lt;Sum&lt;P1, P2&gt;, P3&gt;, P4&gt;, P5&gt;; // A is P1 assert_eq!(A::to_i32(), 1); // A::to_i32() == 1 . ここでは，最低限の演算しか紹介しませんでしたが，typenumにはこれら以外にも多くの機能が実装されています．興味のある方は，是非確認してみてください． . &#21442;&#32771; . typenum |",
            "url": "https://lab.ar90n.net/rust/2020/12/13/introduction-to-typenum.html",
            "relUrl": "/rust/2020/12/13/introduction-to-typenum.html",
            "date": " • Dec 13, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "evcxr_jupyterによるRust on Notebook",
            "content": "&#12399;&#12376;&#12417;&#12395; . Jupyter Notebookはカーネルを切り替えることにより，様々な言語で開発することができます．ここでは，Rustのカーネル実装であるevcxr_jupyterを用いて，NotebookによるRust開発に挑戦してみます． . &#12420;&#12387;&#12383;&#12371;&#12392; . evcxr_jupyterの導入 | 外部Crateの導入 | データ表示のカスタマイズ | plottersによるグラフの描画 | . evcxr_jupyter&#12398;&#23566;&#20837; . jupyter-langsのRustに関する部分をお借りしました．当該箇所を自分のDockerfileにコピペで特に問題なく動作しました．使用するだけならば，jupyter-langsを直接使うのが一番手っ取り早いと思います．それにしても，jupyter-langsはすごいですね．これだけカーネルを導入するのは色々と大変だったと思います．ありがたいです． . &#22806;&#37096;Crate&#12398;&#23566;&#20837; . 外部Crateの導入はCode Cellに以下の様な記述を追加することで実現します． . :dep Crate名 = バージョン . 初回評価時はコンパイルを行うため少し時間がかかります．以下に，base64を導入する例を示します． . :dep base64 = &quot;0.10.1&quot; //From Tour of the EvCxR Jupyter Kernel //https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb base64::encode(&amp;vec![1, 2, 3, 4]) . &#34;AQIDBA==&#34; . &#12487;&#12540;&#12479;&#34920;&#31034;&#12398;&#12459;&#12473;&#12479;&#12510;&#12452;&#12474; . evcxr_jupyterは以下のフォーマットでMIME Type と Content を標準出力に出力することで，HTMLに埋め込んで表示することが可能です． . EVCXR_BEGIN_CONTENT &lt;&lt;MIME Type&gt;&gt; &lt;&lt; Content &gt;&gt; EVCXR_END_CONTENT . 具体的には，以下の様に表を出力したり， . println!(r#&quot;EVCXR_BEGIN_CONTENT text/html &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; EVCXR_END_CONTENT&quot;#); . 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 画像を出力したりすることが可能です . println!(r#&quot;EVCXR_BEGIN_CONTENT image/png iVBORw0KGgoAAAANSUhEUgAAAJAAAACQEAQAAAAd3/ZwAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0T//xSrMc0AABKWSURBVHja7Z15eBRF+se/IeFSIkFgOTwICRIEFOQQBM8FFVHWC5afN8pyyLHoKrqgCAqIBEVAXcEbBEEQiIt4ggIKrAhClOWKhCQkIeQgIQkhJDPz/f0xsMNcSR9VXTOhP8/Tz5N0Vb/1vtXf6a6u6q6KIEnY2BiklmoHbMIbW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFFIQ3IoGICOD551V7EtqccwJaHOcWxsM5gGtH4Dx7VwB/d7n/nj4d+OneIMaOAM8sd9t7LV91ZIrgOUR5fxLwbMNIcqJ3Htc4Mn6Ydz6APNXJ396Li73zFHyjOkLrOaeuQBvv9v7/3Qhgwh/e+xY7gYPv+h/72oXe/7/RDZj8oPe+zyerjlABqhUsipymnivBJw6STv88vbP8rywAOXMqyf5kdkrg9DPbvgkk65AL3w6c3jCJ5Lf+5X61zpNn/z2qa0osNUZACw55n8yBX5DHizzpudOqFoeo7cBQT5nlF5JjbvFOf/YZ1TUllhpzC9tym/f/n90BNIwBtnUFSt8HZqRb48dzzYDjjYC9CcAF0cCb33qnr2+ruqbEEkHWjC9Tm3cAju5R7YU2XNlARAvVXoghbK5AR/sCmxYB5Uv80xy/hY94AKC0PEAM5wGb/wlk/J9q73Si+h6qhcKp3u2IWdHksZme9NwlctozbZbLsbt/nMf3ksXk/DLv9PTBqmtcO2EhoH0LAp+IsTPJH14hu30j9gS/vYZ03eEuu/Q38sGbxNpv5SLXfUJOSgicvvGk6hrXTli0gdKGAq0/sKasJjuBvGQAj3j2FZUCjaKti3fbHKD7OOvKM0NYtIHqWPjkMuAIvMQDADEF1sZb74S15ZkhPAT0onVlLR0AcIT3vsJF1sZb927zNqwiLAQUddC6ssqdwOxEwPm7+//iImBYJ2vjrbvS2vLMEDICmtXSPaodEQE8vAJYtQY4vBNwuoBlAn+RFzwPTLsU2JENlD4DpD/qn+fpGCDqSqDtbKBhI2Dlnf550icBJ6YAuw4BiTlAi0HifHwvA3AlA0c+BtZeA4zI8NTNE0vM2xeK6lb8GWQPMczbT2bFkyzwLzullz5bR9oHjuFoFLkgnazfTm4soUTIuHNle/EV3XMBufUu0jWg+vJ3axgri/kzmX+ThmB6kDvjyX77bQFZRiIFCucz8rcK/T7suC64zdjPyaIf9dtMaUb2f1VcbMPTVZ8pb0JGQNtzxFTwhgSSLuN+bB7hb7PzLLI0yVx8v4C88JT5+L7oqfpMeRMyAirJMlexkxuQ5U7zfpBk+mjyH7XJW64k3zxBOvLF2HU8Rc5NNhdn9iJ15ygQIdUTfV4ccPKQ/uO2XQd036Tae+3sTQc6/hNwLdN/rHMXUMviboWqsPwx/mhfYFNjYNt64LdNwIF4IC0NeKOPfvH0mgccc4WXeADg8lZA6Wrg3s/1Hzv5LSB9GnBgL/D7y8Avc4FN5QpH8a283PmOqpvZxvyJdITRoGNAniSnvi6uTlSM4kdZKda8LDF2pm0HnrscQD0rvZfAbOB5AM3rAMNGmzd3OBa41OIQLL2FXUagicOcjZlZwHNdAZxnpedy+dsoYOGD5u30mGe975Y3oteOAO54x9ixCfdY6akxLp4E9B4O3JgKXPUBEPMX7ce+PRAYZXAcbH4ZMKK+goCtvmdWbpLbzR9qW7e3yC9/JZ1R2urn2TXGyilZbPWZdKOkH+i9wepPrIpt/TXV143zP+T1r+uzOylBxVl0o2Q0vtcsFaWqp89W4P5+QFnr4Hlq9QCSdH4gcMNkhUFZJtUhZOkK8o8k8tqr1F8NVG7RL5M5l1RdXT9drN1eK5f7Rf3iVNKVbe0VSKqAMluRk0aTvTPVn7RQ3PK+rbr+xr5ksN31nvsLWCs+o5b3FLYbiHYCpZ0VXl5DnI49gZ0fAVEJgdNL3wei/2auDEdrIDJVXgzy2kBbgNIIeY7XBHb/B3h7cPD0BkOBmy4xVwYbyo1Baj/Qjnigm0T11xQKTwIxAXrV03YDra8wbverdUC/PnJ9l/oU1vUgkNhBbgA1gcVDAu9/zcTwxphb5IsHsKAn2rUG6LwL+P0F+cGEK5dsATKu8d5XdBRo1NyYvTqtgOISoK4F37NJ7weqNQD4+kf5gYQzh3sBZaO89y0qMW5vV11rxANYNBZWsQ+oe3ngtKmdgPGtgDqvAqnJwA2zgKxtnvR2kcDICd7H/PgosDLevF9Gxtb2r5JTR7lbgaY93X9XTgDqvOKd3vkiYFU3oOXtwKExwNVtgZLdgW0VxQANC+X46YfsfoK0E+So9YH7K9o8QTLJO/++Wv75dpd457n3oJh+mBQj/SQPkftvJQfVEdsnlPaEp4jPS/3Ti+t7u5HeNbitQRNPz5T2ra7IDCFFQMXdyU8jyNit1YzhXOF/rOOyABWyyjuPMAG9bSLI1eTcruIEVNTytN3pZNOHvdN6bQ3sQr3+VdtsmER+0FPu7LHCBbQkUXul9XrX//iC2wLnLX3Lk0eYgFLMxZq7R5yAnKfPxN55/mkRd5H0ebHfuUyf/VfzRJ9pN8Ib0aMaa8+7ZRjw/XTP/xVdgdGPBc6bc1T87Tuir7njGw0Q48fIH4Fap1ui2z72T2cS8OUc731LHq3OqjdPNxXjq79zgpm7V/+vr00R+UCXqvOURYq/Av0x1HicJPnzXEFXwpUem9s3BM83MJecv4j8yzX6yxj/qZwrkJQ20IJIsQ3Mjz/zti9MQEsNBLebzIkk32ktxodHXvKxv4zs8bTY+ntxMUlJo/TSHuOX5QD3mZyJ9I6NwPQjwJU+40UDU8U8xl9/rb78mQ8CqSPF1lPpFuB8n05E5/lA4hpgooCe5HldgbHbxfrshRxdulm70NgvZvxjZObVwe2KugKp3lKq+Szp5I/ksslk7Vhj9heaecrUiFQBkWSMjtvZ/O1k8UfV26wJAkreor0OXTPInzaRV2foK4N1ZJ9dyQLK1vjmYbMxZOVu7XbDWUD1HyLTvjRepykvk327aCtr3wSZZ9eNlLEwZxqwIB5ouVNb/oTNQNQ5MGr/yDag4E2g1W3GbbSZAMTeoS1vuxnAjD8DFZ3lxSRcQLvWA81SgZE63gNqYXDUOZzolgrM3gjUv8C8rabdtOed+ANQN7mKRfNMIlRA8zsBV/UFCnQ+PZwvqEMulNkeBzQeD6QI+LE06KX/mOtWyVm+U6iAXrrB2HERk8UHFqq0PQocMDmTBg3ORjJ9urHjqkKogOZuMXZc2V/FBxbKJHwKlD5m/PhTBn+o8yS0eIWaHLQdSPsZ6L1W33F5t4sPLNSZOkd73o1pwJf3e7Z8neOC8cOAPcuBsU4JgUh5tvsv+e9a2h9t49vrMx/Oj/Fnb3ldqo/12I3mylg0xr2QsCzkzA/UHhjgBIo7Ahf8t/rsB/cAWAlA0pNCMDZrjD7vYeDjEcDKHmLL/7ADML6aPDQxip59EGgRJ9Znfwcl02iStl9KuY6eWWHvAz2lL5Yj6eSF+eKuQNEZJAurLvOogbcb/tcTfbvssyt5coWFFwOFU7Xlzc+T/EsJxK36sje/FDjcErjsGn3HBaPkUiBvRdV5Dn9i3H5iTzF+VoU0Ac1dAAzRMaXd/p/kB+tLxC36jznvFLBA0FR9ALCnmlvUnqeM2352EjBhMIDnxPnri3gB7QemFABP6Hzt4QcJbxxWiwEBAcANOwDMFOPChszgaacOAg/HmLP/ynJg+HTAtUOMv36IvidOWmXsft2ypfYyhL1Q9qrxOBf1EdcW+i6fpM+L88eakSMGiivjoSOiz7Qb4S+UNXkWKEg0dmznxdrz7hIwKeX6x6vPE5MCdPnOf/+Bu4GEJPM+nKFeP2AUgOi2wIYkYGOGONtncOUBEU3E2hQuoG/6A/2+Eh+8ShzZQKTP25XlLYH6R1R7pp2PWwMPSpjoQngb6NYvgcpmwKa1wO01eJC0XjYQY3LuHtn0zgK+eRco7y9HPADk9wMVjiRnUH2vr5nNEeSF9Mf/rt63QNuTiWTuNNlnVlIbKBDOPwFRKvp5BBHoFgYASYnA3c+q9s6fknVAAwumdgEsmqk+9VNrgrGaLoK/0BDFnmesK0u6gCoI9JD5WYlCLrZwPXs99PgVKD5uTVnSBfR8XaDQwl+EldTKAYZIbwAYY+hPAFzyy5HaBvo+GejTWX4QsgnWBgKAQ52AuN9UexiYTxzAfZFyy5B3BWpVM8RTHa2TgVETVXsRmPujgIokuWXIE1A6EGdwVZ5w47VeQNRdqr0ITFSZXPtSb2HHmwKrC4Et7wPf/BXICNM1vqq6hZ0h6xjQZgdQbnCAVhTN2gP9XECvr4A7rwaa5Uou0JruJjeOX8n8MnLgneo72/Rszkht8RVPI4coWAek+9Nk7hKyMtnKs+lGyarNKT2Btj9rzz94HfCaia8YzFDvBaDxUH3HVJ4EctsZL/NfvYGXl2rP/0M2cKPJmVAMY71mydlL9f/K5txftc3K5WTFLhXRiGXZav11M3amOn8tF1D5W8Yv1au7um24niRzd5Ab3icnZ5Dt3vXkuc9JnmisrkIDUTCGHNuerD2ejJtFPteFXD+AzEklnYc9+Ta8YbxujikSkeUCWjbG3P2+n4aXyTo8qqYyA3GqN1m7Y9X+9rmJfLO3uXqZFa0mPkvbQK7jQGQfALJerzyL1NZA6xBY6GW1A7intjVlnVwM1HvA2vgsXfIyZRAsEQ8A7FhvZWTBWbPBurK2yfjytBosFdDFgq91LesCdweZ7vZrk1P4CiEPWBjktdnm94kvLmGRghitvmeW9iX3ZpCp68jMYjJ3Kln4JLnyZn33/FWDSDrdNstnkI/69L9E5pE8rqZdcIbi7/39njKbrDjdr1R4KXnnQ/rinl+HLMwm8+qTWa+Qhx4j9y0gC6eqiVHJY3xATpJRE7VVYseR/ocff8E/X8llakPa2dzHp0Ok02dizfzD+gTkcKqNyRcly34Hovh6wPGytry9X/TfFz3Gf98f36qNaXOa9//3PQ7U8lmZsHETIErH7P7ZyWpj8iVkBLRHx9JLyyYBLp+5iLIr/PNtvVFtTEnDvP//7HcAnbz3lXUDHDrW9volU3teKwgZAX03XHve4+8AL84FKoYDyANyZgD3BnhkX70ZKNyt3a5ISuYB63zWvajMAt7vB7DQ/X9FbWC8ztkzksrVxBMU1ffQM8QPN9iJdqj6PA8lk78+RjpbyI3BdT+5uyM5clT1Pt0yw3inYSihZDA1EBFBlgiPmqi9baSFcZ2BwWOBKy4HGgiYZaOsCNjbCFhxAph5vjg/63cDTgZ5lzw0ztj/nAkNPsp0/7rih5MvFZBbZ5DHu5M8qf8RX+sWM5p8PJZcEkP+kkEe3ksef4Us/8j9aoTjZ9KRQJ5qRxYPI7OuJncUk8tqk2OdZIsP5Pg17/QKjSVZ5PYcMpHkle3daYmSr6J6CZkrUFUU/QNo9LpqL6zj0CEgNla1F9oImUZ0VVReqNoDa6mw6KNAEYSFgCrGqfbAWso/VO2BdsJDQNvM2wgnyitVe6CdsBDQqSBfgM5eChzoAQy8U7WH+rj2C2DvVcB7gwOnl4fTxOuqW/FaKO171lNKV/dLaeVnreKcXybnaUjW9keSx/fKTeQXw8kmDk96Th/VNa6dsHgKA4ATNwOZEcBlK4BaDb3TnDuBqC6qPdRO6Qrg/IE+O0cCKRFA04uAGAmLosgibARUHa1Ohs93ZxwCIIwaylURFm0gLdy63H9fo0TgwPeAoykww6Kfyahk4NQRIOtm4IqX/NN7Z6LGiAdAeLSBtPChz9qs42uTp1ye9MKRVbdLtM6oH3NB1elpJzxlOv9NJnbwTp80WnVNiaXGCKioCRn3jvskrd8VOM/tAwKf9I8ucqcXd6haHNmnF0cJthp17NbA5W6PI5FMNthFZrZSXVNiqTEC0sKmtf4nfc587zzBVhmaH+edb+kR/zyfRqiO0HpqTCNaC47mQO2zZsSfnA9M8X0bcA9wbRqw+aw1zBqvB47GAZGx3lnfiQJGnPUlRHF3IPoc6/SUs9xTiBKVA3zdH3jgCmBUT2BKPgBfAbUHlpQCsWftWkd/8QDAcAdQvg94YQvwrwIgurq1m2og59QVSA8rugHjegEvbARGhth7yKGELSAbU9SYfiAbNdgCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU/w/IpTqp4TSsCgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMTEtMTFUMDE6MzQ6MTMrMDA6MDAnCoLDAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTExLTExVDAxOjM0OjEzKzAwOjAwVlc6fwAAAABJRU5ErkJggg== EVCXR_END_CONTENT&quot;#); . また，fn evcxr_display(&amp;self)となる関数（トレイト？）を任意の型に対して実装することで，その型をNotebookに出力することが可能となります． 以下に，image::RgbImageに対して，fn evcxr_display(&amp;self)を実装した例を示します． . :dep image = &quot;0.23&quot; //From Tour of the EvCxR Jupyter Kernel //https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb extern crate image; extern crate base64; pub trait EvcxrResult {fn evcxr_display(&amp;self);} impl EvcxrResult for image::RgbImage { fn evcxr_display(&amp;self) { let mut buffer = Vec::new(); image::png::PNGEncoder::new(&amp;mut buffer).encode(&amp;**self, self.width(), self.height(), image::ColorType::Rgb8).unwrap(); let img = base64::encode(&amp;buffer); println!(&quot;EVCXR_BEGIN_CONTENT image/png n{} nEVCXR_END_CONTENT&quot;, img); } } image::ImageBuffer::from_fn(256, 256, |x, y| { if (x as i32 - y as i32).abs() &lt; 3 { image::Rgb([0, 0, 255]) } else { image::Rgb([0, 0, 0]) } }) . The type of the variable figure was redefined, so was lost. . plotters&#12395;&#12424;&#12427;&#12464;&#12521;&#12501;&#12398;&#25551;&#30011; . plottersとはRustで記述されたグラフを描画するためのCrateです．詳細については，まだ作成途中とのことですが，こちらの資料に詳しくまとまっていました．また，日本語の資料としては，こちらの記事が大変わかりやすくまとまっていました． . 以下に，プロット機能を用いて二次関数とマンデルブロ集合を描画する礼を示します． . :dep plotters = { git = &quot;https://github.com/38/plotters&quot;, default_features = true, features = [&quot;evcxr&quot;] } . // From Plotters Tutorial with Jupyter // https://plotters-rs.github.io/plotters-doc-data/evcxr-jupyter-integration.html extern crate plotters; use plotters::prelude::*; evcxr_figure((640, 480), |root| { root.fill(&amp;WHITE); let mut chart = ChartBuilder::on(&amp;root) .caption(&quot;y=x^2&quot;, (&quot;Arial&quot;, 50).into_font()) .margin(5) .x_label_area_size(30) .y_label_area_size(30) .build_ranged(-1f32..1f32, -0.1f32..1f32)?; chart.configure_mesh().draw()?; chart.draw_series(plotters::series::LineSeries::new( (-50..=50).map(|x| x as f32 / 50.0).map(|x| (x, x * x)), &amp;RED, )).unwrap() .label(&quot;y = x^2&quot;) .legend(|(x,y)| PathElement::new(vec![(x,y), (x + 20,y)], &amp;RED)); chart.configure_series_labels() .background_style(&amp;WHITE.mix(0.8)) .border_style(&amp;BLACK) .draw()?; Ok(()) }) . Fontconfig error: Cannot load default config file Fontconfig error: Cannot load default config file Fontconfig warning: ignoring C.UTF-8: not a valid language tag . y=x^2 0.0 0.2 0.4 0.6 0.8 -0.8 -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 y = x^2 // From mandelbrot.rs // https://github.com/38/plotters/blob/master/examples/mandelbrot.rs use plotters::prelude::*; use std::ops::Range; fn mandelbrot_set( real: Range&lt;f64&gt;, complex: Range&lt;f64&gt;, samples: (usize, usize), max_iter: usize, ) -&gt; impl Iterator&lt;Item = (f64, f64, usize)&gt; { let step = ( (real.end - real.start) / samples.0 as f64, (complex.end - complex.start) / samples.1 as f64, ); return (0..(samples.0 * samples.1)).map(move |k| { let c = ( real.start + step.0 * (k % samples.0) as f64, complex.start + step.1 * (k / samples.0) as f64, ); let mut z = (0.0, 0.0); let mut cnt = 0; while cnt &lt; max_iter &amp;&amp; z.0 * z.0 + z.1 * z.1 &lt;= 1e10 { z = (z.0 * z.0 - z.1 * z.1 + c.0, 2.0 * z.0 * z.1 + c.1); cnt += 1; } return (c.0, c.1, cnt); }); } evcxr_figure((640, 480), |root| { root.fill(&amp;WHITE); let mut chart = ChartBuilder::on(&amp;root) .margin(20) .x_label_area_size(10) .y_label_area_size(10) .build_cartesian_2d(-2.1f64..0.6f64, -1.2f64..1.2f64)?; chart .configure_mesh() .disable_x_mesh() .disable_y_mesh() .draw()?; let plotting_area = chart.plotting_area(); let range = plotting_area.get_pixel_range(); let (pw, ph) = (range.0.end - range.0.start, range.1.end - range.1.start); let (xr, yr) = (chart.x_range(), chart.y_range()); for (x, y, c) in mandelbrot_set(xr, yr, (pw as usize, ph as usize), 100) { if c != 100 { plotting_area.draw_pixel((x, y), &amp;HSLColor(c as f64 / 100.0, 1.0, 0.5))?; } else { plotting_area.draw_pixel((x, y), &amp;BLACK)?; } } Ok(()) }) . Fontconfig error: Cannot load default config file Fontconfig error: Cannot load default config file Fontconfig warning: ignoring C.UTF-8: not a valid language tag . -1.0 -0.5 0.0 0.5 1.0 -2.0 -1.5 -1.0 -0.5 0.0 0.5 &#21442;&#32771; . evcxr | jupyter-langs | RustのドローイングライブラリPlottersの紹介 |",
            "url": "https://lab.ar90n.net/rust/jupyter/2020/11/15/rust-on-nodebook-with-evcxr-jupyter.html",
            "relUrl": "/rust/jupyter/2020/11/15/rust-on-nodebook-with-evcxr-jupyter.html",
            "date": " • Nov 15, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
            "content": "&#12399;&#12376;&#12417;&#12395; . 拡大と回転と並進とによって実現する幾何学変換に相似変換があります．これは，画像間の位置合わせ等に用いられます． 具体的には，互いに対応する点${x_{i}}$と$y_{i} left(i = 1, 2, dots n right)$が与えられた時，それらの間に存在する相似変換を推定するといったものです． . これを実現アルゴリズムにS.Umeyamaによって提案された手法があります．古典的な手法ではありますが，実用的なアルゴリズムであると思います．scikit-imageにおけるSimilalityTransformでも使用されています． . &#12420;&#12387;&#12383;&#12371;&#12392; . Least-Squares Estimation of Transformation Parameters Between Two Point Patternsによる提案手法を読む | Pythonによる簡易的な実装 | . &#34892;&#21015;&#12398;&#24615;&#36074;&#24489;&#32722; . 以下にこれから利用する行列の性質を示します．ここで，$ mathbf A = left(a_{i,j} right)$及び$ mathbf B = left(b_{i,j} right)$は行列を，$ left&lt; cdot, cdot right&gt;$は行列の内積を表します． . $$ begin{aligned} mathrm {tr} mathbf A &amp;= mathrm {tr} mathbf A^{ mathrm T} mathrm {tr} mathbf A mathbf B mathbf C &amp;= mathrm {tr} mathbf B mathbf C mathbf A mathrm {tr} mathbf A^{ mathrm T} mathbf B &amp;= left&lt; mathbf A, mathbf B right&gt; &amp;= left | mathbf A mathbf B right |^{2} frac{ partial}{ partial mathbf A} mathrm {tr} left( mathbf A mathbf B right) &amp;= mathbf B^{T} frac{ partial}{ partial mathbf A} mathrm {tr} left( mathbf A^{ mathrm T} mathbf B right) &amp;= mathbf B frac{ partial}{ partial mathbf A} mathrm {tr} left(f left( mathbf A right) g left( mathbf A right) right) &amp;= frac{ partial}{ partial mathbf A_{1}} mathrm {tr} left(f left( mathbf A_{1} right) g left( mathbf A right) right) + frac{ partial}{ partial mathbf A_{2}} mathrm {tr} left(f left( mathbf A right) g left( mathbf A_{2} right) right) left&lt; mathbf A, mathbf B right&gt; &amp;= mathrm {tr} mathbf A^{ mathrm T} B &amp;= sum_{i,j} a_{j,i}b_{i,j} end{aligned} $$ &#30456;&#20284;&#22793;&#25563;&#12395;&#12388;&#12356;&#12390; . 上述したとおり，相似変換とは拡大と回転と並進とによって実現する幾何学的変換です．従って，変換元を$ mathbf x$，変換先を$ mathbf x&#39;$，拡大率，回転行列，並進ベクトルをそれぞれ$ left(c, mathbf R, mathbf t right)$とすると . $$ begin{aligned} mathbf x&#39; &amp;= c mathbf R mathbf x + mathbf t end{aligned} $$と表されます． . ここで，特徴点$ mathbf x_{i}$と，その相似変換による変換$ mathbf y_{i} left(i = 1, 2, dots , n right)$を観測した場合を考えます．この時，以下の$e left(c, mathbf R, mathbf t right)$を最小化することで，$ mathbf x_{i}$と$ mathbf y_{i}$から相似変換のパラメータ$ left(c, mathbf R, mathbf t right)$を推定することができます． . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} sum_{i=1}^{n} left| mathbf y_{i} - left(c mathbf R mathbf x_{i} + mathbf t right) right|^{2} end{aligned} $$ &#22238;&#36578;&#34892;&#21015;&#12398;&#25512;&#23450; . 相似変換に推定の先立ち，まずは以下の式を最小化する$ mathbf R$を推定することを考えます．ここで，$ mathbf A$及び$ mathbf B$は$m times n$の行列を，$ mathbf R$は$m times m$の行列を表します． . $$ begin{alignedat}{4} text{minimize} &amp; &amp; left | mathbf A - mathbf R mathbf B right |^{2} &amp; text{subject to} &amp; &amp; left| mathbf R right| &amp;= 1&amp; &amp; &amp; mathbf R mathbf R^{ mathrm T} &amp;= mathbf I end{alignedat} $$$ mathbf R$を適切に推定するためには，与えられた束縛条件の元で目的関数を最小化する必要があります．従って，ラグランジュの未定乗数法を用います．ここでは，ラグランジュ関数$F$は以下の様に表されます．なお，$l_{i,j}$及び$g$はラグランジュ乗数となります． . $$ begin{aligned} F &amp;= left | mathbf A - mathbf R mathbf B right |^{2} + sum_{i=1}^{m} sum_{j=1}^{m} l_{i,j} left( mathbf R^{ mathrm T} mathbf R - mathbf I right)_{i,j} + g left( left| mathbf R right| - 1 right) end{aligned} $$上式において，$ mathbf R^{ mathrm T} mathbf R$と$ mathbf I$は対象行列です．従って，それらの差である$ left( mathbf R^{ mathrm T} mathbf R - mathbf I right)$も対象行列となります．$ left( mathbf R^{ mathrm T} mathbf R - mathbf I right)$が対象行列であるならば，対象な成分に対応するラグランジュ乗数も同様に等しくなります．すなわち， . $$ begin{aligned} l_{i,j} &amp;= l_{j,i} end{aligned} $$となります．従って，ラグランジュ関数の第2項は以下の様に表現することが可能です． . $$ begin{aligned} sum_{i=1}^{m} sum_{j=1}^{m} l_{i,j} left( mathbf R^{ mathrm T} mathbf R - mathbf I right)_{i,j}　&amp;= left&lt; left(l_{i,j} right), mathbf R^{ mathrm T} mathbf R - mathbf I right&gt; &amp;= mathrm{tr} left( left(l_{j,i} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) &amp;= mathrm{tr} left( left(l_{i,j} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) end{aligned} $$ここで， . $$ begin{aligned} mathbf L &amp;= left(l_{i,j} right) end{aligned} $$と置くと， . $$ begin{aligned} mathrm{tr} left( left(l_{i,j} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right)　&amp;= mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) end{aligned} $$と表すことができます．従って，ラグランジュ関数$F$は以下の様に表現されます． . $$ begin{aligned} F &amp;= left | mathbf A - mathbf R mathbf B right |^{2} + mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) + g left( left| mathbf R right| - 1 right) end{aligned} $$ $F$を最小化する$ mathbf R$を求めるためには，以下の式を$ mathbf R$について解く必要があります． . $$ begin{aligned} frac{ partial F}{ partial mathbf R} &amp;= frac{ partial}{ partial mathbf R} left | mathbf A - mathbf R mathbf B right |^{2} + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) + frac{ partial}{ partial mathbf R} g left( left| mathbf R right| - 1 right) &amp;= 0 end{aligned} $$まずは，右辺第１項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} left | mathbf A - mathbf R mathbf B right |^{2} &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( left( mathbf A - mathbf R mathbf B right)^{ mathrm T} left( mathbf A - mathbf R mathbf B right) right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf A - mathbf A^{ mathrm T} mathbf R mathbf B - mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A + mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf A right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf R mathbf B right) + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A right) + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B mathbf A^{ mathrm T} mathbf R right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A mathbf B^{ mathrm T} mathbf R^{ mathrm T} right) + frac{ partial}{ partial mathbf R_{1}} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R_{1}^{ mathrm T} mathbf R mathbf B right) + frac{ partial}{ partial mathbf R_{2}} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R_{2} mathbf B right) &amp;= - mathbf A mathbf B^{ mathrm T} - mathbf A mathbf B^{ mathrm T} + frac{ partial}{ partial mathbf R_{1}} mathrm{tr} left( mathbf R_{1}^{ mathrm T} mathbf R mathbf B mathbf B^{ mathrm T} right) + frac{ partial}{ partial mathbf R_{2}} mathrm{tr} left( mathbf B mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R_{2} right) &amp;= -2 mathbf A mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} + left( mathbf B mathbf B^{ mathrm T} mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= -2 mathbf A mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} &amp;= -2 mathbf A mathbf B^{ mathrm T} + 2 mathbf R mathbf B mathbf B^{ mathrm T} end{aligned} $$ 次に，右辺第２項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L mathbf R^{ mathrm T} mathbf R right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L right) &amp;= frac{ partial}{ partial mathbf R_{1}} mathrm {tr} left( mathbf L mathbf R_{1}^{ mathrm T} mathbf R right) + frac{ partial}{ partial mathbf R_{2}} mathrm {tr} left( mathbf L mathbf R^{ mathrm T} mathbf R_{2} right) &amp;= frac{ partial}{ partial mathbf R_{1}} mathrm {tr} left( mathbf R mathbf L mathbf R_{1}^{ mathrm T} right) + left( mathbf L mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= mathbf R mathbf L + mathbf R mathbf L^{ mathrm T} &amp;= mathbf R mathbf L + mathbf R mathbf L &amp;= 2 mathbf R mathbf L end{aligned} $$最後に，右辺第３項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} g left( left| mathbf R right| - 1 right) &amp;= g frac{ partial}{ partial mathbf R} left| mathbf R right| &amp;= g mathbf{R} end{aligned} $$ 以上の結果より， . $$ begin{aligned} frac{ partial F}{ partial mathbf R} &amp;= -2 mathbf A mathbf B^{ mathrm T} + 2 mathbf R mathbf B mathbf B^{ mathrm T} + 2 mathbf R mathbf L +g mathbf{R} &amp;= 0 end{aligned} $$と表現することができます．上式を整理すると， . $$ begin{aligned} 2 mathbf R mathbf B mathbf B^{ mathrm T} + 2 mathbf R mathbf L +g mathbf{R} &amp;=2 mathbf A mathbf B^{ mathrm T} mathbf R left( mathbf B mathbf B^{ mathrm T} + mathbf L + frac{1}{2}g mathbf I right) &amp;= mathbf A mathbf B^{ mathrm T} end{aligned} $$と表すことができます．ここで， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf B mathbf B^{ mathrm T} + mathbf L + frac{1}{2}g mathbf I end{aligned} $$と置きます．すると， . $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf L&#39;^{ mathrm T} mathbf R^{ mathrm T} &amp;= mathbf B mathbf A^{ mathrm T} end{aligned} $$となります．$ mathbf B mathbf B^{ mathrm T}$，$ mathbf L$及び$ mathbf I$は全て対象行列です．従って， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf L&#39;^{ mathrm T} end{aligned} $$という関係が成立します．従って， . $$ begin{aligned} mathbf L&#39; mathbf R^{ mathrm T} &amp;= mathbf B mathbf A^{ mathrm T} end{aligned} $$となります．ここで，両辺にそれぞれ自身の転置を掛けると， . $$ begin{aligned} mathbf L&#39; mathbf R^{ mathrm T} left( mathbf L&#39; mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= mathbf L&#39; mathbf R^{ mathrm T} mathbf R mathbf L&#39;^{ mathrm T} &amp;= mathbf L&#39; mathbf L&#39;^{ mathrm T} &amp;= mathbf L&#39;^{2} &amp;= mathbf B mathbf A^{ mathrm T} left( mathbf B mathbf A^{ mathrm T} right)^{ mathrm T} end{aligned} $$となります．また，$ mathbf A mathbf B^{ mathrm T}$の特異値分解を以下の様に置きます． . $$ begin{aligned} mathbf A mathbf B^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$すると， . $$ begin{aligned} mathbf L&#39;^{2} &amp;= left( mathbf U mathbf D mathbf V^{ mathrm T} right)^{ mathrm T} mathbf U mathbf D mathbf V^{ mathrm T} &amp;= mathbf V mathbf D mathbf U^{ mathrm T} mathbf U mathbf D mathbf V^{ mathrm T} &amp;= mathbf V mathbf D^{2} mathbf V^{ mathrm T} end{aligned} $$であり， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf V sqrt{ mathbf D^{2}} mathbf V^{ mathrm T} &amp;= mathbf V begin{pmatrix} ddots &amp; &amp; &amp; sqrt{d_{i}^{2}}&amp; &amp; &amp; ddots end{pmatrix} mathbf V^{ mathrm T} &amp;= mathbf V begin{pmatrix} ddots &amp; &amp; &amp; d_{i}s_{i}&amp; &amp; &amp; ddots end{pmatrix} mathbf V^{ mathrm T} &amp;= mathbf V mathbf D mathbf S mathbf V^{ mathrm T} end{aligned} $$と表すことができます．なお，$ mathbf S = mathop{ rm diag}s_{i} left(s_{i} = pm1 right)$となります． . 次に，上式の両辺に対して行列式を考えます．すると， . $$ begin{aligned} left| mathbf L&#39; right| &amp;= left| mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right| &amp;= left| mathbf V right| cdot left| mathbf D right| cdot left| mathbf S right| cdot left| mathbf V^{ mathrm T} right| end{aligned} $$であり，$ left| mathbf V right| = left| mathbf V^{ mathrm T} right| = 1$より， . $$ begin{aligned} &amp;= left| mathbf D right| cdot left| mathbf S right| end{aligned} $$また， . $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf L&#39; &amp;= mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} mathbf L&#39; &amp;= mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} end{aligned} $$であることから， . $$ begin{aligned} left| mathbf L&#39; right| &amp;= left| mathbf R^{ mathrm T} right| cdot left| mathbf A mathbf B^{ mathrm T} right| &amp;= left| mathbf A mathbf B^{ mathrm T} right| end{aligned} $$となります．従って， $$ begin{aligned} left| mathbf D right| cdot left| mathbf S right| &amp;= left| mathbf A mathbf B^{ mathrm T} right| end{aligned} $$ . と表すことができます．また，特異値の性質より，$d_{i} geq 0$であるため， . $$ begin{aligned} left| mathbf D right| &amp; geq 0 end{aligned} $$となります．従って， . $$ begin{aligned} left| mathbf S right|&amp;= begin{cases} 1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| geq 0 -1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| leq 0 end{cases} end{aligned} $$となります．ここで，$ left| mathbf A - mathbf R mathbf B right|^{2}$の最小化について考えます．以上の結果より$ left| mathbf A - mathbf R mathbf B right|^{2}$は， . $$ begin{aligned} left | mathbf A - mathbf R mathbf B right |^{2} &amp;= mathrm{tr} left( left( mathbf A - mathbf R mathbf B right)^{ mathrm T} left( mathbf A - mathbf R mathbf B right) right) &amp;= mathrm{tr} left( mathbf A^{ mathrm T} mathbf A right) - mathrm{tr} left( mathbf A^{ mathrm T} mathbf R mathbf B right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf R mathbf B right) &amp;= left | mathbf A right |^{2} - mathrm{tr} left( left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right)^{ mathrm T} right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= left | mathbf A right |^{2} - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( mathbf B^{ mathrm T} mathbf B right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf L&#39; right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf D mathbf S mathbf V^{ mathrm T} mathbf V right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf D mathbf S right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 left(d_{1}s_{1} + d_{2}s_{2} + cdots + d_{m}s_{m} right) end{aligned} $$と表すことができます．ここで，$ mathbf A$，$ mathbf B$，$d_{i}$が問題より与えられており，$ left | mathbf A right |^{2} ge 0$，$ left | mathbf B right |^{2} ge 0$となります．従って，$ text{minimize} left | mathbf A - mathbf R mathbf B right |^{2}$は以下の様に書き換えることができます． . $$ begin{alignedat}{4} text{maximize} &amp; &amp; d_{1}s_{1} + d_{2}s_{2} + cdots + d_{m}s_{m} &amp; text{subject to} &amp; &amp; s_{1}s_{2} cdots s_{m} &amp;= begin{cases} 1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| geq 0 -1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| leq 0 end{cases}&amp; &amp; &amp; left| s_{i} right| &amp;= 1 end{alignedat} $$まず，$ left| mathbf A mathbf B^{ mathrm T} right| geq 0$の場合について考えます．この時，$s_{i}=1$で目的関数が最大化することは明らかです．次に，$ left| mathbf A mathbf B^{ mathrm T} right| leq 0$の場合について考えます．$d_{1} geq d_{2} geq cdots geq d_{m}$であるため，$s_{1} = s_{2} = cdots = s_{m-1} = 1$，$s_{m} = -1$で目的関数が最大化します． . 最後に，以上の結果を元に実際に$ mathbf R$を求めていきます．まず，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m$である場合を考えます．この時，$ mathbf L&#39;$は正則行列となります．よって， . $$ begin{aligned} mathbf L&#39;^{-1} &amp;= left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right)^{-1} &amp;= left( mathbf V^{ mathrm T} right)^{-1} mathbf S^{-1} mathbf D^{-1} mathbf V^{-1} &amp;= mathbf V mathbf S mathbf D^{-1} mathbf V^{ mathrm T} &amp;= mathbf V mathbf D^{-1} mathbf S mathbf V^{ mathrm T} end{aligned} $$となります．従って， . $$ begin{aligned} mathbf R &amp;= mathbf A mathbf B^{ mathrm T} mathbf L&#39;^{-1} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf V mathbf D^{-1} mathbf S mathbf V^{ mathrm T} &amp;= mathbf U mathbf S mathbf V^{ mathrm T} end{aligned} $$となります．次に，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m-1$である場合を考えます． . $$ begin{aligned} mathbf A mathbf B^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf L&#39; &amp;= mathbf V mathbf D mathbf S mathbf V^{ mathrm T} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} end{aligned} $$であるため， $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf R left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right) &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf R mathbf V mathbf D mathbf S mathbf V^{ mathrm T} mathbf V &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf V mathbf R mathbf V mathbf D mathbf S &amp;= mathbf U mathbf D end{aligned} $$ . ここで，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m-1$であるため，$d_{m} = 0$となります．また，$s_{1} = s_{2} = cdots = s_{m} = 1$であるため， . $$ begin{aligned} mathbf D mathbf S &amp;= mathbf D end{aligned} $$となります．よって， . $$ begin{aligned} mathbf R mathbf V mathbf D &amp;= mathbf U mathbf D end{aligned} $$ここで， $$ begin{aligned} mathbf Q &amp;= mathbf U^{ mathrm T} mathbf R mathbf V left| mathbf Q right| &amp;= left| mathbf U^{ mathrm T} mathbf R mathbf V right| &amp;= left| mathbf U^{ mathrm T} right| left| mathbf R right| left| mathbf V right| &amp;= left| mathbf U right| left| mathbf V right| end{aligned} $$ . と置くと， . $$ begin{aligned} mathbf U^{ mathrm T} mathbf R mathbf V mathbf D &amp;= mathbf U^{ mathrm T} mathbf U mathbf D mathbf Q mathbf D &amp;= mathbf D end{aligned} $$と表すことができます．さらに . $$ begin{aligned} mathbf Q &amp;= left( mathbf q_{1} mathbf q_{2} cdots mathbf q_{m} right) mathbf e_{i} &amp;= left(e_{i,1}, e_{i,2}, cdots, e_{i,m} right)^{ mathrm T} e_{i,j} &amp;= begin{cases} 0 &amp; text{otherwise} 1 &amp; text{if} i=j end{cases} end{aligned} $$と置くと， . $$ begin{aligned} d_{i} mathbf q_{i} &amp;= d_{i} mathbf e_{i} mathbf q_{i} &amp;= mathbf e_{i} left( 1 leq i leq m - 1 right) end{aligned} $$となります．また，$ mathbf U$, $ mathbf R$, $ mathbf V$は全て直交行列です．従って$ mathbf Q$も同様に直交行列となります．そのため，$ mathbf q_{m}$は$ mathbf q_{1} cdots mathbf q_{m-1}$と直交します．従って， . $$ begin{aligned} mathbf q_{m} = begin{cases} mathbf e_{m} &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 - mathbf e_{m} &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} end{aligned} $$となります．以上の結果より， . $$ begin{aligned} mathrm{svd} left( mathbf A mathbf B^{ mathrm T} right) &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} mathbf R &amp;= mathbf U mathbf Q mathbf V^{ mathrm T} &amp;= mathbf U mathbf S mathbf V^{ mathrm T} end{aligned} $$ &#30456;&#20284;&#22793;&#25563;&#12398;&#25512;&#23450; . 前述した通り，相似変換は以下の$e^{2} left(c, mathbf R, mathbf t right)$を最小化する$c, mathbf R, mathbf t$を求めることによって与えられます． . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} sum_{i=1}^{n} left| mathbf y_{i} - left(c mathbf R mathbf x_{i} + mathbf t right) right|^{2} end{aligned} $$ここで，$ mathbf X= left( mathbf x_{1}, mathbf x_{2}, cdots, mathbf x_{n} right)$，$ mathbf Y= left( mathbf y_{1}, mathbf y_{2}, cdots, mathbf y_{n} right)$，$ mathbf h = left(1, 1, cdots, 1 right)^{ mathrm T}$と置くと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y - c mathbf R mathbf X - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} end{aligned} $$と表現することができます．また， . $$ begin{aligned} mathbf K &amp;= mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} mathbf K &amp;= mathbf K^{ mathrm T} mathbf K mathbf K^{ mathrm T} &amp;= mathbf K end{aligned} $$とすると， . $$ begin{aligned} mathbf X mathbf K &amp;= mathbf X left( mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} right) &amp;= mathbf X - frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} mathbf X &amp;= mathbf X mathbf K + frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} end{aligned} $$であり，同様に， . $$ begin{aligned} mathbf Y &amp;= mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} end{aligned} $$これらを用いて，$e^{2} left(c, mathbf R, mathbf t right)$を表すと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} - c mathbf R left( mathbf X mathbf K + frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} right) - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} - c mathbf R mathbf X mathbf K - frac{c}{n} mathbf R mathbf X mathbf h mathbf h^{ mathrm T} - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K + left( frac{1}{n} mathbf Y mathbf h - frac{c}{n} mathbf R mathbf X mathbf h - mathbf t right) mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right) right) &amp;= frac{1}{n} mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) - left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) - left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) + left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) &amp;= frac{1}{n} left { mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right) - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right)+ mathrm{tr} left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right)^{ mathrm T} right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( left( mathbf K^{ mathrm T} mathbf Y^{ mathrm T} - c mathbf K^{ mathrm T} mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( mathbf K^{ mathrm T} left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } end{aligned} $$なお， . $$ begin{aligned} mathbf t&#39; &amp;= - frac{1}{n} mathbf Y mathbf h + frac{c}{n} mathbf R mathbf X mathbf h + mathbf t end{aligned} $$と置いています．ここで，右辺第３項について考えます． $$ begin{aligned} mathrm{tr} left( mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; mathbf h^{ mathrm T} right) &amp;= mathrm{tr} left( mathbf h^{ mathrm T} mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( mathbf h^{ mathrm T} left( mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( left( mathbf h^{ mathrm T} - frac{1}{n} mathbf h^{ mathrm T} mathbf h mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( left( mathbf h^{ mathrm T} - mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= 0 end{aligned} $$ . 次に右辺第２項について考えます． $$ begin{aligned} left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2}&amp;= n left | mathbf t&#39; right |^{2} end{aligned} $$ . 以上の結果より， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; right |^{2} end{aligned} $$と表されます．$e^{2} left(c, mathbf R, mathbf t right)$を最小化するために，$ mathbf t&#39;=0$と置くと， . $$ begin{aligned} mathbf t&#39; &amp;= - frac{1}{n} mathbf Y mathbf h + frac{c}{n} mathbf R mathbf X mathbf h + mathbf t &amp;= 0 end{aligned} $$従って， . $$ begin{aligned} mathbf t &amp;= frac{1}{n} mathbf Y mathbf h - frac{c}{n} mathbf R mathbf X mathbf h end{aligned} $$ここで， $$ begin{aligned} mathbf{ mu_{y}} &amp;= frac{1}{n} mathbf Y mathbf h mathbf{ mu_{x}} &amp;= frac{1}{n} mathbf X mathbf h end{aligned} $$ . と置くと， $$ begin{aligned} mathbf t &amp;= mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} end{aligned} $$ . 並進成分が求まったので，再度評価関数$e^{2}$を書き下すと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t = mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} right) &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} end{aligned} $$ここで，$ frac{1}{n} mathbf Y mathbf K mathbf X^{ mathrm T}$の特異値分解を以下の様に置きます． $$ begin{aligned} frac{1}{n} mathbf Y mathbf K mathbf X^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$ . すると， . $$ begin{aligned} left( mathbf Y mathbf K right) left(c mathbf X mathbf K right)^{ mathrm T} &amp;= c mathbf Y mathbf K mathbf K^{ mathrm T} mathbf X^{ mathrm T} &amp;= c mathbf Y mathbf K mathbf X^{ mathrm T} &amp;= cn mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$また，回転行列の推定の結果より， $$ begin{aligned} frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} &amp;= frac{1}{n} left { left | mathbf Y mathbf K right |^{2} + c^{2} left | mathbf X mathbf K right |^{2} - 2 mathrm{tr} left(cn mathbf U mathbf D mathbf V^{ mathrm T} right) right } end{aligned} $$ . 上式を$c$について最小化すると， . $$ begin{aligned} frac{ partial}{ partial c} frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2}&amp;= frac{1}{n} left {2 c left | mathbf X mathbf K right |^{2} - 2n mathrm{tr} left( mathbf U mathbf D mathbf V^{ mathrm T} right) right } &amp;= 0 c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ frac{1}{n} left | mathbf X mathbf K right |^{2}} end{aligned} $$ここで， . $$ begin{aligned} sigma_{x}^{2}&amp;= frac{1}{n} left | mathbf X mathbf K right |^{2} end{aligned} $$とおくと， . $$ begin{aligned} c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ sigma_{x}^{2}} end{aligned} $$また，回転行列$ mathbf R$についても同様に . $$ begin{aligned} mathbf R &amp;= mathbf U mathbf S mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} end{aligned} $$以上の結果をまとめると， $$ begin{aligned} c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ sigma_{x}^{2}} mathbf R &amp;= mathbf U mathbf S mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} mathbf t &amp;= mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} end{aligned} $$ . Python&#12395;&#12424;&#12427;&#23455;&#35013; . 上述の方法をPythonで実装しました．青色の点が$ mathbf X$を，橙色の点が$ mathbf Y$を，緑色の点が$c mathbf R mathbf X$をそれぞれ表しています．橙色の点ど緑色の点が重なっていることから，パラメータの推定が適切に行われていることを確認できます． . import numpy as np from random import random import math import matplotlib.pyplot as plt n = 64 c = random() + 0.5 theta = math.pi * random() cs, ss = math.cos(theta), math.sin(theta) R = np.array([[cs, -ss], [ss, cs]]) t = np.random.rand(2, 1) noise = 0.0 * np.random.rand(2, n) X = np.random.rand(2, n) Y = c * R @ X + t + noise h = np.ones((n, 1)) K = np.eye(n) - 1 / n * h @ h.T U, D, V = np.linalg.svd(Y @ K @ X.T / n) S = np.diag([1,np.linalg.det(U) * np.linalg.det(V) ]) R_pred = U @ S @ V.T c_pred = n * np.trace(np.diag(D) @ S) / np.trace(X @ K @ X.T) t_pred = ((Y @ h) - c_pred * R_pred @ X @ h) / n Y_pred = c_pred * R_pred @ X + t_pred ax = plt.gca() ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) plt.scatter(x = X[0,:], y =X[1,:], label=&quot;X&quot;, color=&quot;tab:blue&quot;, alpha=0.3) plt.scatter(x = Y[0,:], y =Y[1,:], label=&quot;Y&quot;, color=&quot;tab:orange&quot;, alpha=0.3) plt.scatter(x = Y_pred[0,:], y =Y_pred[1,:], label=&quot;Y_pred&quot;, color=&quot;tab:green&quot;, alpha=0.3) ax.legend() plt.show() . &#21442;&#32771; . Least-Squares Estimation of Transformation Parameters Between Two Point Patterns, S. Umeyama, 1991 | Matrix Cookbook, Kaare Brandt Petersen, Michael Syskind Pedersen, 2005 |",
            "url": "https://lab.ar90n.net/imageprocessing/geometry/2020/11/08/read-umeyama-1991-paper.html",
            "relUrl": "/imageprocessing/geometry/2020/11/08/read-umeyama-1991-paper.html",
            "date": " • Nov 8, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "smart_openによる統一的なファイルアクセス",
            "content": "&#12399;&#12376;&#12417;&#12395; . ファイルの格納先(ファイルシステム，S3，GCS等)毎にIO処理を記述すると，プログラムが複雑になりがちです．ここでは，それらを統一的に取り扱うことができるsmart_openについて述べます． . &#12420;&#12387;&#12383;&#12371;&#12392; . smart_openの導入 | smart_openによるファイルシステム，クラウドストレージ，Webからのファイル読み込み | . smart_open&#12395;&#12388;&#12356;&#12390; . smart_openはビルトインのopenを置き換えることで，様々なプロトコルを用いてファイルをオープンすることを可能にします．現状のプロトコルに対応している様です． . S3 | GCS | Blob Storage | HDFS | ファイルシステム | SSH | SCP | SFTP | HTTP | . また，以下形式で圧縮されたファイルを透過的に扱うことができます． . gzip | bzip2 | . ここでは，ファイルシステム，S3，GCS，HTTPによるファイルアクセスを評価します． . 従って，以下のようにクラウドストレージをサポートするsmart_openを導入します． . $ pip install smart_open[all] . 他の導入方法については，リポジトリのREADMEを参考にしてください． . &#12463;&#12521;&#12454;&#12489;&#12473;&#12488;&#12524;&#12540;&#12472;&#65292;Web&#12363;&#12425;&#12501;&#12449;&#12452;&#12523;&#12434;&#35501;&#12415;&#36796;&#12416; . 通常，クラウドストレージ上のファイルにアクセスするには専用のSDKを使用することが多いと思います． また，HTTPプロトコルでアクセスするには，urllibやrequests等を使用することが多いと思います． そのため，リソースに応じてこれらのライブラリを適切に取り扱う必要があります． . smart_openはこれらのライブラリを適切にラップします．従って，これらのファイルをファイルシステム上にあるかの様に取り扱うことが可能となります． . ここでは，TIFFファイルをGCS, S3, HTTP, ファイルシステム経由で読み込み表示するサンプルを示します．なお，事前に適切な認証情報を設定しておく必要があります． . from smart_open import open import matplotlib.pyplot as plt from PIL import Image sources = { &quot;S3&quot;: &quot;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;HTTP&quot;: &quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;FILESYSTEM&quot;: &quot;/tmp/LC80030172015001LGN00_BQA.TIF&quot; } for protocol, url in sources.items(): with open(url, &quot;rb&quot;) as fp: img = Image.open(fp) plt.figure() plt.title(f&quot;from {protocol}&quot;) plt.imshow(img, cmap=&#39;gray&#39;) . pathlib.Path&#32076;&#30001;&#12391;smart_open&#12434;&#20351;&#12358;&#12371;&#12392;&#12399;&#12391;&#12365;&#12427;&#12424;&#12358;&#12391;&#12377;&#12364; . いかなるリソースもopenで同様に取り扱うことができる事はとても便利です．しかしながら，strでリソースを指定するのは少し大変です．なので，pathlib.Pathでリソースを指定できると便利です． . smart_openはpathlib.Path.openをフックすることできるようです．しかしながら，pathlib.Pathがファイルパスしか扱えない(//が/に置換されてしまう)ので，すこし微妙かもしれません．． . from pathlib import Path Path(&quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;) . PosixPath(&#39;https:/s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&#39;) . &#21442;&#32771; . smart_open | .",
            "url": "https://lab.ar90n.net/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "relUrl": "/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "date": " • Oct 21, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
            "content": "はじめに . このUSB-NICをUbuntu 20.04から使用するために行った作業記録です． . やったこと . ネットワークデバイスを有効 | netplanで静的IPアドレスを設定 | . 現状の確認 . USBポートに差し込んだのみでは，ネットワークデバイスとして使用可能な状態にはなりませんでした． まずは，USBデバイスとして適切に認識されていることを確認します． . $ lsusb Bus 002 Device 002: ID 0b95:1790 ASIX Electronics Corp. AX88179 Gigabit Ethernet Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 8087:0a2a Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub . ASIX Electronics Corp. AX88179 Gigabit Ethernet このデバイスが対象のUSB-NICであるようです． . ネットワークデバイスとして認識する . 参考サイトの方法に従ってネットワークデバイスとして認識させます． . $ sudo lshw -c Network ... *-network:0 DISABLED description: Ethernet interface physical id: 1 bus info: usb@2:4 logical name: enx000ec6853d1a serial: 00:0e:c6:85:3d:1a size: 10Mbit/s capacity: 1Gbit/s capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation configuration: autonegotiation=off broadcast=yes driver=ax88179_178a duplex=half link=no multicast=yes port=MII speed=10Mbit/s ... $ sudo ifconfig enx000ec6853d1a up $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 39 bytes 3635 (3.6 KB) RX errors 0 dropped 32 overruns 0 frame 0 TX packets 7 bytes 882 (882.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . /etc/cloud/cloud.cfg.d/50-curtin-networking.cfgにenx000ec6853d1aの設定を追加 . $ cat /etc/cloud/cloud.cfg.d/50-curtin-networking.cfg network: ethernets: enp2s0: addresses: [] dhcp4: true enx000ec6853d1a: addresses: - 10.0.100.1/24 gateway4: 10.0.0.1 dhcp4: false version: 2 $ sudo cloud-init clean -r . ここでシステムが再起動します．その後，以下の様に設定確認します． . $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.100.1 netmask 255.255.255.0 broadcast 10.0.100.255 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 2163 bytes 212391 (212.3 KB) RX errors 0 dropped 1734 overruns 0 frame 0 TX packets 18 bytes 1900 (1.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . 参考 . Ubuntu 16.04.5で有線LANが繋がらない | .",
            "url": "https://lab.ar90n.net/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "relUrl": "/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "date": " • Oct 17, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "DICOMにおける文字コードの取り扱い",
            "content": "はじめに . DICOMを取り扱うライブラリの多くは海外製であるため，日本語の取り扱いが得意で無いことが多いです. そこで，DICOMにおいて日本語を正しく扱うために色々と調べたのでまとめます． . やったこと . DICOMで日本語を表現する方法を調査 | . 文字コードについて復習 . DICOMにおける文字コードの取り扱いについて述べる前に，いわゆる”文字コード”と呼ばれているものは何であるかを簡単に復習します．より正しく”文字コード”について理解するためには，（符号化）文字集合と（文字）符号化方式を区別することが重要です．文字集合とは表現する文字の集合（アルファベット全てやひらがな全てなど）です．符号化方式とは文字集合の要素をコンピュータ上で取り扱うことが可能な形式に変換する方法です．従って，同一の文字集合に対して複数の符号化方式が存在します． . ISO/IEC 2022 とはなんだろう . ISO/IEC 2022とは文字集合を７ビット文字または８ビット文字にて表現する符号化方式です．特徴としてはエスケープシーケンスを利用することで，複数の文字集合を同時に取り扱うことが可能である点が挙げられます．日本語においては，このISO/IEC 2022の機構を利用したISO-2022-JPが広く利用されています．ISO-2022-JPは一般的にJISコードと呼ばれます．これには漢字，ひらがな，カタカナ，ラテン文字，ギリシア文字，キリル文字など多くの文字集合が含まれます．（半角カタカナは含まれません） . 上述した通り，ISO/IEC 2022には7ビット文字を利用したものと8ビット文字を利用したものとが存在します．ここでは８ビット文字を利用した場合のみを考慮します．ISO/IEC 2022の符号表は図形文字の領域（GL，GR）と制御文字の領域（CL，CR)からなります．また，４つの仮想的なバッファ(G0, G1, G2,G3)が存在します．ISO/IEC 2022を利用するには，エスケープシーケンスを用いて任意のバッファへ文字集合をロードし，それを図形文字の領域（GL，GR)に呼び出します．呼び出しには永続的に呼び出すロッキングシフトと１文字のみのシングルシフトが存在します． . DICOMにおけるISO/IEC 2022 . DICOMでは符号方式としてISO/IEC 2022のサブセットを用いています．具体的には . 8ビット文字をサポート | デフォルトの文字集合としてISO646を使用 | ISO646は必ずGL空間に呼び出される | ISO646以外の文字集合を用いる場合はSpecific Character Set(0008,0005)に指定する | エスケープを利用した符号拡張を使う(ISO/IEC 2022)場合はSpecific Character Setに二つ以上の文字集合を指定する | バッファG0はGLに，バッファG1はGRにロードされる | G2，G3は利用不可 | G0，G1は常に呼び出し状態にあるのでロッキングシフトは不要 | . という制約があります． . 実際にDICOMで日本語を扱ってみる . DICOMで日本語を扱うためには，Specific Character Set(0008,0005)に使用する符号方式を設定する必要があります．ここでは，以下の患者名を符号化することを考えます． . ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう . この患者名には，半角かな，漢字，全角ひらがなが含まれています．英数字と半角かなはISO 2022 IR 13で，漢字と全角ひらがなはISO 2022 IR 87で表現が可能です． 従って，Specific Character Set(0008,0005)には以下の値を設定します． . ISO 2022 IR 13 ISO 2022 IR 87 . 前述の通り，ISO/IEC 2022ではエスケープシーケンスを用いて複数の符号方式を切り替えます． 従って，上述の患者名においても適切なタイミングでエスケープする必要があります． エスケープシーケンスを追加した例を以下にしまします． . ﾔﾏﾀﾞ^ﾀﾛｳ= ESC 02/04 04/02 山田 ESC 02/08 04/10 ^ ESC 02/04 04/02 太郎 ESC 02/08 04/10 = ESC 02/04 04/02 やまだ ESC 02/08 04/10 ^ ESC 02/04 04/02 たろう ESC 02/08 04/10 . また，各エスケープシーケンスの詳細を以下に示します． . エスケープシーケンス 処理 . ESC 02/08 04/10 | 英数字(ISO-IR 14)をGLにロード | . ESC 02/04 04/02 | 漢字とひらがな(ISO-IR 87)をGLにロード | . これらを踏まえて，実際にエンコーディングすると以下の値が得られます． . 13/04 12/15 12/00 13/14 05/14 12/00 13/11 11/03 03/13 01/11 02/04 04/02 03/11 03/03 04/05 04/04 01/11 02/08 04/10 05/14 01/11 02/04 04/02 04/02 04/00 04/15 03/10 01/11 02/08 04/10 03/13 01/11 02/04 04/02 02/04 06/04 02/04 05/14 02/04 04/00 01/11 02/08 04/10 05/14 01/11 02/04 04/02 02/04 03/15 02/04 06/13 02/04 02/06 01/11 02/08 04/10 . 参考 . JIS漢字コード | ISO/IEC 2022 | JIS X 0201 | ２０１１ ST講座 入門講座 DICOM規格 初級 –DICOMをうまく使いこなす– | DICOMの日本語エンコーディング処理実装 | DICOM に慣れる － 現場で DICOM 接続に慌てないための知識 （２） 文字系の通信 － | H.3 Example of Person Name Value Representation in the Japanese Language | .",
            "url": "https://lab.ar90n.net/dicom/2020/10/12/character-encodings-in-dicom.html",
            "relUrl": "/dicom/2020/10/12/character-encodings-in-dicom.html",
            "date": " • Oct 12, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "移動平均フィルタの零点と周波数特性",
            "content": "&#12399;&#12376;&#12417;&#12395; . 最も単純なローパスフィルタとして，移動平均フィルタが広く知られています． しかしながら，その詳細な性質を確認する機会はあまり無いのではと思います． そこで，移動平均フィルタの伝達関数，複素平面における零点の分布，周波数特性を示します． そして，ローパスフィルタとしての特性を再確認します． . &#12420;&#12387;&#12383;&#12371;&#12392; . 移動平均フィルタについて複素平面上で零点の分布をプロット | 移動平均フィルタについて周波数特性をプロット | 移動平均フィルタがローパスフィルタであり，直線位相であること確認 | . &#31227;&#21205;&#24179;&#22343;&#12501;&#12451;&#12523;&#12479;&#12395;&#12388;&#12356;&#12390; . 移動平均フィルタとは， $n$ サンプル目の入力を$x_{n}$，出力を$y_{n}$，フィルタ長を$N$とすると以下のように表すことができます． $$y_{n} = frac{1}{N} sum_{m = 0}^{N} x_{n + m}$$ これは，連続する$N$サンプルの平均を出力とすることを意味しています． 今回は，零点と周波数特性の関係を調べたいので，上式にZ変換を行い周波数領域に持っていきます． . $$ begin{aligned} mathcal{Z}(x_{n+m}) &amp; = z^{-m}X(z) mathcal{Z}(y_{n}) &amp; = Y(z) &amp; = H(z)X(z) &amp; = frac{1}{N} left( sum_{m = 0}^{N} z^{-m} right) X(z) end{aligned} $$ &#35079;&#32032;&#24179;&#38754;&#19978;&#12391;&#38646;&#28857;&#12434;&#27714;&#12417;&#12427; . 前述の伝達関数$H(z)$の根を求めることで，零点が複素平面上でどのように分布しているかを知ることができます．ここでは，$H(z)$の求根にはコンパニオン行列の固有値を計算する方法を用います． 求根方法の詳細についていかに述べます． . まず初めに問題を定義します．$H(z)$の根を求めることとは，以下の式を満たす$z$を求めることになります． . $$ begin{aligned} H(z) &amp; = frac{1}{N} sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ここで，両辺を$N$倍して以下の式を得ます $$ begin{aligned} H&#39;(z) &amp; = sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ . この時，$H&#39;(z)$に対するコンパニオン行列$C(H&#39;(Z))$は以下のように求まります． . $$ begin{aligned} C left(H&#39;(z) right) &amp; = begin{pmatrix} 0 &amp; 0 &amp; cdots &amp; 0 &amp; -1 1 &amp; 0 &amp; cdots &amp; 0 &amp; -1 0 &amp; 1 &amp; cdots &amp; 0 &amp; -1 vdots &amp; vdots &amp; ddots &amp; vdots &amp; vdots 0 &amp; 0 &amp; cdots &amp; 1 &amp; -1 end{pmatrix} end{aligned} $$コンパニオン行列$C left(H&#39;(z) right)$には，以下の様な面白い性質があります． . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) end{aligned} $$ここで，左辺は$H&#39;(z)$の固有多項式を表します．従って， . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) &amp;= 0 end{aligned} $$と置くと，$z$は$C left(H&#39;(z) right)$の固有値に等しいことが解ります． . 以下に零点のプロットを示します．この結果より，以下を確認できます． . 零点は単位円上にのみ存在する | $z=-1$以外の零点は全て複素共役になっている | . import numpy as np import altair as alt def companion(n: int): return np.hstack([np.vstack([np.zeros(n-1), np.eye(n-1,n-1)] ), -np.ones(n).reshape(-1,1)]) def zeros(n): return np.linalg.eig(companion(n))[0] def plot_zeros(n): source = alt.Data(values=sum([[{ &#39;Real Part&#39; : pt.real, &#39;Imaginary Part&#39;: pt.imag, &quot;n&quot;: i } for pt in zeros(i)] for i in range(1, n + 1)], [])) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.Chart(source).mark_circle().encode(x=alt.X(&quot;Real Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2])), y=alt.Y(&quot;Imaginary Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2]))).add_selection(select_order).transform_filter(select_order).interactive() plot_zeros(32) . &#21608;&#27874;&#25968;&#29305;&#24615;&#12434;&#27714;&#12417;&#12427; . 同様に周波数特性を求めます．周波数特性は$H(z)$に対して$z rightarrow exp^{-i omega}$と置換して$ left|H(z) right|$，$ angle H(z)$を計算することで得られます． . import math def response(n): freq = np.linspace(0, 1.0, 257, endpoint=True) resp = np.sum(np.vander(np.exp(freq * 2 * np.pi * 1j), n), axis=1) / n return resp, freq def plot_freq_feature(n): source = alt.Data(values = sum([[{ &#39;Normalized frequency&#39;: f, &#39;gain&#39;: 20 * math.log10(abs(r)), &#39;phase&#39;: math.atan2(r.imag, r.real), &#39;n&#39;: i } for r, f in zip(*response(i))] for i in range(1, n+1)], [])) base = alt.Chart(source).encode( alt.X(&#39;Normalized frequency:Q&#39;, axis=alt.Axis(title=None)) ) amp = base.mark_line(stroke=&#39;#57A44C&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;gain:Q&#39;, scale=alt.Scale(domain=[-50, 0], clamp=True), axis=alt.Axis(title=&#39;Gain(dB)&#39;, titleColor=&#39;#57A44C&#39;)), ) phase = base.mark_line(stroke=&#39;#5276A7&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;phase:Q&#39;, scale=alt.Scale(domain=[-math.pi, math.pi]), axis=alt.Axis(title=&#39;Phase(rad)&#39;, titleColor=&#39;#5276A7&#39;)), ) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.layer(amp, phase).resolve_scale( y = &#39;independent&#39; ).add_selection(select_order).transform_filter(select_order).interactive() plot_freq_feature(32) . 上図より以下のことが確認できます． . 低周波を通し，高周波をカットするローパスフィスタになっている | 複素平面上で零点の存在する周波数は利得が小さい（カットされている） | 直線位相となっている | . &#21442;&#32771; . Eigenvalue-Polynomials | .",
            "url": "https://lab.ar90n.net/signalprocessing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "relUrl": "/signalprocessing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "date": " • Oct 10, 2020"
        }
        
    
  
    
        ,"post19": {
            "title": "GitHub ActionsでWebサイトを自動更新する",
            "content": "はじめに . GitHubPages + GitHub Actions でコンテンツを自動的に更新するWebサイトをつくってみました．GitHub Trending に登場したリポジトリに付与されていた topics を一覧表示するサイトです．言語ごとの用途がざっくりとした感じでみることができます． . Topics in GitHub Trending - GitHub . 今回，勉強も兼ねてフロントエンドとデータのクローリング処理共に Elm で記述しました． . GitHub Actions によるバッチ処理の定刻実行 . GitHub Actionsによって定刻実行されるバッチ処理はは以下の3つのジョブからなります． . build | crawl | push | . それぞれ，クローリングスクリプトのビルド，データのクローリング，データのリポジトリへのプッシュを行います．設定の詳細はこちらを参考にしてください． . CLIプログラムを Elm で書く . crawlジョブではElmで記述されたCLIプログラムを実行してデータの取得を行います．ElmはWebフロントエンドを記述することに特化している言語です．そのため，CLIプログラムの開発に必要な，コマンドライン引数の処理といった機能がサポートされいません．そこで，今回は以下のパッケージを持ちました． . pdillonkearns/elm-cli-options-parser . こちらのパッケージを用いると，Flagを用いてコマンドライン引数へのアクセスが可能となります．今回のプログラムでは，以下の様にgithubToken と language と dataRange とを引数から受け取っています． . init : Flags -&gt; TrendingApiOptions -&gt; ( Model, Cmd Msg ) init { githubToken } { language, dateRange } = ( { githubToken = githubToken } , attemptApi TrendingApiResponse (fetchTrending githubToken language dateRange) ) . また，GitHub Tredingsの取得は以下のAPIを利用させていただきました． . github-trending-api . クローリング結果の保存 . 今回，GitHub PagesのみでWebサイトをホスティングするため，データベースを使用することはできません．そのため，クローリング結果はJSONに整形されたのちに，直接GitHub Pagesのリポジトリにプッシュされます． . topics . この，JSONをフロントエンドから取得することで動的なコンテンツ更新を実現します． . Elmによるフロントエンド開発 . 特筆すべきことはありません．Elmは本当に書きやすい言語でした． . 所感 . Elmの勉強としてはちょうど良い分量でした．GitHub PagesとGitHub Actionsで結構なことができる印象なので，また何かチャレンジしたいですね． .",
            "url": "https://lab.ar90n.net/elm/web/2020/08/09/automated-update-github-pages.html",
            "relUrl": "/elm/web/2020/08/09/automated-update-github-pages.html",
            "date": " • Aug 9, 2020"
        }
        
    
  
    
        ,"post20": {
            "title": "純粋なバイナリヒープ",
            "content": "純粋なヒープを実装する場合，Braun Treeなど色々と適したデータ構造があるらしいですね． でも、あまり詳しくないので今回は馴染みの深いバイナリヒープを実装する方法について調べてみました． . バイナリヒープとは？ . 二分木を用いて実装したヒープです．ヒープとは以下の性質をもつデータ構造です． . 木構造をもつ | 常に子要素の値は親要素の値以上 | . ヒープ自身の詳細についてはこの記事を参考にしてください． . バイナリヒープを純粋に実装する . 一般的にバイナリヒープの実装には配列とそのインデックスを用いることが多いと思います．（上記のウィキペディアにもこの方法が記載されています） しかしがなら，この方法は配列の内容を書き換える必要があるため，純粋ではありません．そこで，今回は以下で提案されている手法を用いました． . A Functional Approach to Standard Binary Heaps . この論文では，純粋なバイナリヒープの挿入，構築，削除の各操作ついてScalaを用いて説明しています． 以降，これらについて簡単に紹介を行います． . ヒープクラス . この論文ではバイナリヒープを表現するためのクラスHeapを以下のように定義しています， . abstract sealed class Heap { def min: Int // ヒープの最小値 def left: Heap //左側の子要素 def right: Heap //右側の子要素 def size: Int //ヒープに含まれる要素数 def height: Int //ヒープの高さ } case class Branch(min: Int, left: Heap, right: Heap, size: Int, height: Int) extends Heap case object Leaf extends Heap { def min: Int = fail(&quot;Leaf.min&quot;) def left: Heap = fail(&quot;Leaf.min&quot;) def right: Heap = fail(&quot;Leaf.right&quot;) def size: Int = 0 def height: Int = 0 } . 上述の通り，Heapクラスのleftとrightを持つ再帰的な構造になっています． また，Heapクラスは抽象クラスであるため，一つ以上の子要素を持つBranchと子要素を持たないLeafとを派生させています． 単純な二分木にはsizeとheightは必須ではありません．しかしながら，今回のようにバイナリヒープを実現するためには非常に重要となってきます． . 挿入 O(log n) . 新たな要素をを挿入する際に気をつけなければいけないことは，要素を挿入したバイナリヒープもまた上述の条件を満たさなければならないということです． そこで，今回の実装では挿入処理を以下の二つの処理に分けて考えます． . 要素をLeafとして最下レベルに追加する． | 1.にて追加した要素を適切な位置まで上へ登らせる（bubbleUp）． | それでは，まずは1.の新たな要素をLeafとして追加する方法について解説します． ノード追加すること自体は言語側でやってくれることなので，基本的には問題になりません． そのため，次にLeafを挿入する場所はどこかを知ることが問題となります． . 二分木に対する操作のパフォーマンスは木の高さに依存するため，可能な限り二分木の高さを抑える必要があります． 従って，新たな要素はleft側から順番に挿入します． バイナリヒープは二分木であるため，ルートから適切にleftまたはrightを選択することで任意の位置に到達することが可能です． そのため，この問題はleftとrightを以下のように4つの場合に分けて考えることで解決することができます． . leftが完全二分木でない場合 -&gt; leftを選択 | leftが完全二分木であるが，rightは完全二分木でない場合 -&gt; rightを選択 | leftもrightも完全二分木であるが，leftの方がrightよりも高い場合 -&gt; rightを選択 | leftもrightも完全二分木であり，高さが等しい場合 -&gt; leftを選択 | これら4つの場合を図に表すと以下のようになります． . . また，Heapが完全二分木であるか否かは以下の条件式で求めることが可能です． . Size==2Height−1Size == 2^{Height} - 1Size==2Height−1 . 次に，2.のbubbleUpの方法について解説します． bubbleUpの処理は単純で，自身の値(min)と子要素の値(min)とを比較し，子要素の値(min)の値の方が小さい場合は要素を入れ替えます． 以上の結果を元に，insertとbubbleUpは以下のように実装することができます． . def bubbleUp(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, Heap(x, lt, rt), r) case (_, Branch(z, lt, rt, _, _)) if (x &gt; z) =&gt; Heap(z, l, Heap(x, lt, rt)) case (_, _) =&gt; Heap(x, l, r) } def insert(x: Int): Heap = if (isEmpty) Heap(x) else if (left.size &lt; math.pow(2, left.height) - 1) bubbleUp(min, left.insert(x), right) else if (right.size &lt; math.pow(2, right.height) - 1) bubbleUp(min, left, right.insert(x)) else if (right.height &lt; left.height) bubbleUp(min, left, right.insert(x)) else bubbleUp(min, left.insert(x), right) . 構築 O(n) . ソートされていない配列からバイナリヒープの構築を試みます． ここでは，構築済みのバイナリヒープをleftとrightに，配列のi番目の要素をminに設定した要素を考えます． しかしながら，配列のi番目の要素が各子要素の値(min)より小さいとは限らないため，全体としてヒープの条件を満たすとは限りません． そこで，ヒープの条件を満たさない場合は，配列のi番目の要素を適切な位置まで降ろす操作(bubbleDown)が必要となります． . bubbleDownはHeapのminの値と各子要素のminの値とを比較し，小さな場合は何もせず， 大きな場合は要素を入れ替えた後に，再帰的にbubbleDownを呼びだします． こうすることで，当該要素を適切な位置まで降ろすことができます． 以上の結果を踏まえ，配列からバイナリヒープを構築する関数heapify及びbubbleUpは以下のように定義できます． . def bubbleDown(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, _, _, _, _), Branch(z, lt, rt, _, _)) if (z &lt; y &amp;&amp; x &gt; z) =&gt; Heap(z, l, bubbleDown(x, lt, rt)) case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, bubbleDown(x, lt, rt), r) case (_, _) =&gt; Heap(x, l, r) } def heapify(a: Array[Int]): Heap = { def loop(i: Int): Heap = if (i &lt; a.length) bubbleDown(a(i), loop(2 * i + 1), loop(2 * i + 2)) else Leaf loop(0) } . heapifyは一見するとを$O(n log n)$に見えますが，漸近的には$O(n)$らしいです． 正直，なぜ$O(n)$に成るのかは理解できていませんが，アルゴリズムイントロダクションに詳細が記載されているとあったので，そのうち調べてみようと思います． . 削除 O(log n) . 要素をの削除も挿入と同様， 以下のように二つのの処理に分けて考えることができます． . 最後に挿入した要素をバイナリヒープのルートへ移動させる | 1.でルートへ移動した要素を適切な位置まで降ろす(bubbleDown) | 最後に挿入した要素は挿入処理と同様に二分木を走査し，当該要素を見つけることで実現します． 要素を適切な位置まで降ろす処理(bubbleDown)は構築の際に用いたものと同一です． 以上の結果より，要素を削除する関数removeは以下のように実装されます． なお，floatLeftは左側の，floatRightは右側の子要素の値と親要素の値を交換する関数です. . def remove: Heap = if (isEmpty) fail(&quot;Empty heap.&quot;) else bubbleRootDown(mergeChildren(left, right)) def bubbleRootDown(h: Heap): Heap = if (h.isEmpty) Leaf else Heap.bubbleDown(h.min, h.left, h.right) def mergeChildren(l: Heap, r: Heap): Heap = if (l.isEmpty &amp;&amp; r.isEmpty) Leaf else if (l.size &lt; math.pow(2, l.height) - 1) floatLeft(l.min, mergeChildren(l.left, l.right), r) else if (r.size &lt; math.pow(2, r.height) - 1) floatRight(r.min, l, mergeChildren(r.left, r.right)) else if (r.height &lt; l.height) floatLeft(l.min, mergeChildren(l.left, l.right), r) else floatRight(r.min, l, mergeChildren(r.left, r.right)) def floatLeft(x: Int, l: Heap, r: Heap): Heap = l match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, Heap(x, lt, rt), r) case _ =&gt; Heap(x, l, r) } def floatRight(x: Int, l: Heap, r: Heap): Heap = r match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, l, Heap(x, lt, rt)) case _ =&gt; Heap(x, l, r) } . F#によるプライオリティキュー . バイナリヒープを使ったプライオリティキューの実装です． . PriorityQueue . 参考文献ではScalaによる実装でしたが，自分が普段使いする言語はF#なので，F#で実装してみました． .",
            "url": "https://lab.ar90n.net/algorithm/2020/06/27/purely-binary-heap.html",
            "relUrl": "/algorithm/2020/06/27/purely-binary-heap.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post21": {
            "title": "三次元空間における行列演算の復習",
            "content": "ぱっと思いつかなかったのでメモ． . 任意の単位ベクトルへの射影行列 . 任意の単位ベクトルを$ vec{n}$とすると，$ vec{n}$への射影行列$P_{p}$は以下の様に表されます． . Pp=n⃗n⃗TP_{p} = vec{n} vec{n}^{T}Pp​=n . n . T . 法線ベクトルに直交する平面への射影行列 . 法線ベクトルへの射影を元のベクトルから引くことで，法線ベクトルと直交する平面への射影が可能となります． そのため，法線ベクトルと直交する平面への射影行列$P_{o}$は以下のように表されます． . Po=I−Pp=I−n⃗n⃗T begin{aligned} P_{o} &amp;= I - P_{p} &amp;= I - vec{n} vec{n}^{T} end{aligned}Po​​=I−Pp​=I−n . n . T​ . 任意の単位ベクトルを回転軸とした回転行列 . 任意の単位ベクトル$ vec{n}$を以下のように定義します． n⃗=(nx,ny,nz) vec{n} = left(n_x, n_y, n_z right)n=(nx​,ny​,nz​) . ここで，Z軸方向の単位ベクトル$ vec{e_{z}}$を$ vec{n}$に変換する行列$P$を考えます．$P$はY軸回転$R_{y}$とZ軸回転$R_{z}$の積で以下のように表現できます． cθ=nxnx2+ny2sθ=nynx2+ny2cϕ=nznx2+ny2+nz2sϕ=nx2+ny2nx2+ny2+nz2Rxz=(cϕ0sϕ010−sϕ0cϕ)Rxy=(cθ−sθ0sθcθ0001)P=Rxy∗Rxz begin{aligned} c_{ theta} &amp;= frac{n_{x}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} s_{ theta} &amp;= frac{n_{y}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} c_{ phi} &amp;= frac{n_{z}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} s_{ phi} &amp;= frac{ sqrt{n_{x}^{2} + n_{y}^{2}}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} R_{xz} &amp;= left( begin{array}{rrr} c_{ phi} &amp; 0 &amp; s_{ phi} 0 &amp; 1 &amp; 0 -s_{ phi}&amp; 0 &amp; c_{ phi} end{array} right) R_{xy} &amp;= left( begin{array}{rrr} c_{ theta} &amp; -s_{ theta} &amp; 0 s_{ theta} &amp; c_{ theta} &amp; 0 0 &amp; 0 &amp; 1 end{array} right) P &amp;= R_{xy} * R_{xz} end{aligned}cθ​sθ​cϕ​sϕ​Rxz​Rxy​P​=nx2​+ny2​​nx​​=nx2​+ny2​​ny​​=nx2​+ny2​+nz2​​nz​​=nx2​+ny2​+nz2​​nx2​+ny2​​​=⎝⎜⎜⎜⎜⎜⎛​cϕ​0−sϕ​​010​sϕ​0cϕ​​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cθ​sθ​0​−sθ​cθ​0​001​⎠⎟⎟⎟⎟⎟⎞​=Rxy​∗Rxz​​ . $P$によって変換されたZ軸を$ vec{e_{z}’}(= vec{n})$とすると，所望の任意の単位ベクトルを回転軸とする回転行列は以下の３つの変換の合成で表すことができます． . $ vec{e_{z}}$を$ vec{e_{z}}’$に変換する$P$ | $ vec{e_{z}}$を回転軸とする回転$R_{a}$ | $ vec{e_{z}}’$を$ vec{e_{z}}$に変換する$P^{T}$ | したがって，最終的な回転行列$R$は以下のように表されます． . Ra=(cos⁡(a)−sin⁡(a)0sin⁡(a)cos⁡(a)0001)R=P∗Ra∗PT=(nx2+(ny2+nz2)cos⁡(a)−nxnycos⁡(a)+nxny−(nz3+(nx2+ny2)nz)sin⁡(a)−nxnzcos⁡(a)+nxnz+nysin⁡(a)−nxnycos⁡(a)+nxny+(nz3+(nx2+ny2)nz)sin⁡(a)ny2+(nx2+nz2)cos⁡(a)−nynzcos⁡(a)+nynz−nxsin⁡(a)−nxnzcos⁡(a)+nxnz−(nx2ny+ny3+nynz2)sin⁡(a)−nynzcos⁡(a)+nynz+(nx3+nxny2+nxnz2)sin⁡(a)nz2+(nx2+ny2)cos⁡(a))=(cos⁡(a)+nx2(1−cos⁡(a))nxny(1−cos⁡(a))−nzsin⁡(a)nxnz(1−cos⁡(a))+nysin⁡(a)nxny(1−cos⁡(a))+nzsin⁡(a)cos⁡(a)+ny2(1−cos⁡(a))nynz(1−cos⁡(a))−nxsin⁡(a)nxnz(1−cos⁡(a))−nysin⁡(a)nynz(1−cos⁡(a))+nxsin⁡(a)cos⁡(a)+nz2(1−cos⁡(a))) begin{aligned} R_{a} &amp;= left( begin{array}{rrr} cos left(a right) &amp; - sin left(a right) &amp; 0 sin left(a right) &amp; cos left(a right) &amp; 0 0 &amp; 0 &amp; 1 end{array} right) R &amp;= P * R_{a} * P^{T} &amp;= left( begin{array}{rrr} mathit{n_{x}}^{2} + { left( mathit{n_{y}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} - { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} + mathit{n_{y}} sin left(a right) - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} + { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; mathit{n_{y}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} - mathit{n_{x}} sin left(a right) - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} - { left( mathit{n_{x}}^{2} mathit{n_{y}} + mathit{n_{y}}^{3} + mathit{n_{y}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} + { left( mathit{n_{x}}^{3} + mathit{n_{x}} mathit{n_{y}}^{2} + mathit{n_{x}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; mathit{n_{z}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} cos left(a right) end{array} right) &amp;= left( begin{array}{rrr} cos left(a right) + mathit{n_{x}}^{2} left(1- cos left(a right) right) &amp; mathit{n_{x}} mathit{n_{y}} left(1 - cos left(a right) right) - mathit{n_{z}} sin left(a right) &amp; mathit{n_{x}} mathit{n_{z}} left( 1 - cos left(a right) right) + mathit{n_{y}} sin left(a right) mathit{n_{x}} mathit{n_{y}} left( 1 - cos left(a right) right) + mathit{n_{z}} sin left(a right) &amp; cos left(a right) + mathit{n_{y}}^{2} left( 1- cos left(a right) right) &amp; mathit{n_{y}} mathit{n_{z}} left( 1- cos left(a right) right) - mathit{n_{x}} sin left(a right) mathit{n_{x}} mathit{n_{z}} left(1- cos left(a right) right) - mathit{n_{y}} sin left(a right) &amp; mathit{n_{y}} mathit{n_{z}} left(1- cos left(a right) right) + mathit{n_{x}} sin left(a right) &amp; cos left(a right) + mathit{n_{z}}^{2} left( 1- cos left(a right) right) end{array} right) end{aligned}Ra​R​=⎝⎜⎜⎜⎜⎜⎛​cos(a)sin(a)0​−sin(a)cos(a)0​001​⎠⎟⎟⎟⎟⎟⎞​=P∗Ra​∗PT=⎝⎜⎜⎜⎜⎜⎛​nx​2+(ny​2+nz​2)cos(a)−nx​ny​cos(a)+nx​ny​+(nz​3+(nx​2+ny​2)nz​)sin(a)−nx​nz​cos(a)+nx​nz​−(nx​2ny​+ny​3+ny​nz​2)sin(a)​−nx​ny​cos(a)+nx​ny​−(nz​3+(nx​2+ny​2)nz​)sin(a)ny​2+(nx​2+nz​2)cos(a)−ny​nz​cos(a)+ny​nz​+(nx​3+nx​ny​2+nx​nz​2)sin(a)​−nx​nz​cos(a)+nx​nz​+ny​sin(a)−ny​nz​cos(a)+ny​nz​−nx​sin(a)nz​2+(nx​2+ny​2)cos(a)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cos(a)+nx​2(1−cos(a))nx​ny​(1−cos(a))+nz​sin(a)nx​nz​(1−cos(a))−ny​sin(a)​nx​ny​(1−cos(a))−nz​sin(a)cos(a)+ny​2(1−cos(a))ny​nz​(1−cos(a))+nx​sin(a)​nx​nz​(1−cos(a))+ny​sin(a)ny​nz​(1−cos(a))−nx​sin(a)cos(a)+nz​2(1−cos(a))​⎠⎟⎟⎟⎟⎟⎞​​ .",
            "url": "https://lab.ar90n.net/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "relUrl": "/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post22": {
            "title": "5行で書くポアソンブレンディング",
            "content": "はじめに . 画像の滑らかな合成アルゴリズムにポアソンブレンディング(Poisson Image Editting)があります．これは，ポアソン方程式を解くことで元の勾配を保ちながら，境界部分が連続となる合成画像を推定するというものです． ネットを調べると，ポアソン方程式の計算にはSOR法やマルチグリッド法などを実装した高速な連立方程式ソルバを利用することが多いようです．しかしながら，外部のソルバを利用するとプロジェクトの規模が大きくなってしまいます．また，外部のソルバを利用せず，上述のアルゴリズムを自前で実装することは非常に困難な作業です．そこで，ヤコビ法をラプラシアンフィルタで記述し実装を簡略化しました． . やったこと . ラプラシアンフィルタを使用してヤコビ法を記述 | ポアソンブレンディングを５行で実装 | プロジェクトをGithubに作成 | . ポアソン方程式をラプラシアンフィルタで記述する . 参考記事によると，座標$p$における画素値$f_p$は以下の式で求められます． . fp=∑q∈Nfq+4gq−∑q∈Ngq4f_p = frac{ sum_{q in N} f_q + 4 g_{q} - sum_{q in N} g_q}{4}fp​=4∑q∈N​fq​+4gq​−∑q∈N​gq​​ . ここで，ヤコビ法によって$f_p$を求めます．$k$回目のイテレーションにおける座標$p$における画素値を$f_{p}^{k}$とします．すると，$f_{p}^{k}$は以下のように表記することができます． . fpk+1=∑q∈Nfqk+4gp−∑q∈Ngq4=4fpk−4fpk+∑q∈Nfqk+4gp−∑q∈Ngq4=fpk+−4(fpk−gp)+∑q∈Nfqk−gq4=fpk+14Δp(f−g) begin{aligned} f_{p}^{k+1} &amp;= frac{ sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_{q}}{4} &amp;= frac{4f_{p}^{k} -4 f_{p}^{k} + sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_q}{4} &amp;= f_{p}^{k} + frac{-4 (f_{p}^{k} - g_{p}) + sum_{q in N} f_{q}^{k} - g_q}{4} &amp;= f_{p}^{k} + frac{1}{4} Delta_{p} left(f - g right) end{aligned}fpk+1​​=4∑q∈N​fqk​+4gp​−∑q∈N​gq​​=44fpk​−4fpk​+∑q∈N​fqk​+4gp​−∑q∈N​gq​​=fpk​+4−4(fpk​−gp​)+∑q∈N​fqk​−gq​​=fpk​+41​Δp​(f−g)​ . 以上の結果より，注目領域に$ frac{1}{4} Delta_{p} left(f - g right)$を加算していくことで合成を行います． $ Delta_{p}$は座標$p$におけるラプラシアンを表します．以下にscipyを用いで実装したコードを示します．関数の引数はそれぞれ，target_imgが合成先画像，src_imgが合成元画像, mask_imgが合成領域マスク, iterが反復処理の回数をそれぞれ表します．コードサイズを5行に抑えるため，省いた処理（入力のバリデーション，反復処理の打ち切り）や冗長な処理（target_imgとsrc_imgとの差分を毎ループ計算している）がありますが，アルゴリズムのエッセンスは十分表現できていると思います． . 5行で実装 . from scipy.ndimage import laplace def poisson_blend(target_img, src_img, mask_img, iter: int = 1024): for _ in range(iter): target_img = target_img + 0.25 * mask_img * laplace(target_img - src_img) return target_img.clip(0, 1) . poisson_blendの入力と出力との関係を以下の図に示します．以下の図は，左側から合成元画像(src_img)，合成領域マスク(mask_img)，合成先画像(target_img)，合成画像を表します．境界領域が滑らかに合成されていることが確認できます． . . 上記の関数に加え，結果確認用のノートブックなどを追加したリポジトリを作成しました．よろしければ，こちらも参考にしてください. . 参考 . Poisson Image Editing | ar90n/poisson-blending-in-5lines | .",
            "url": "https://lab.ar90n.net/imageprocessing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "relUrl": "/imageprocessing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post23": {
            "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
            "content": "はじめに . Raspberry Pi 4+k3s+rayでクラスタを作成して，分散処理の実験を行います．Raspberry Pi 4 には事前にUbuntu 20.04を導入しておきます． . cgroupの有効化 . 残念ながら，このcgroupの設定が何故必要なのかを理解できていません．しかしながら，Webで調べた限りでは，必要そうなので設定することにします．（設定しない場合はどうなるかを試してはいません） . SDカードをホストマシンにマウントして以下のコマンド実行します．以下の例では，/Vlumes/system-bootにSDカードがマウントされています．マウントポイントについては，環境に応じて適切に書き換えてください． . $ sed -i -e &#39;s/$/ cgroup_memory=1 cgroup_enable=memory cgroup_enable=cpuset/&#39; /Volumes/system-boot/cmdline.txt . 修正したSDカードを用いてシステムを起動します．その後，以下のコマンドで設定の反映を確認できます． . $ cat /proc/cgroups #subsys_name hierarchy num_cgroups enabled cpuset 5 10 1 cpu 4 98 1 cpuacct 4 98 1 blkio 8 98 1 memory 2 147 1 devices 11 98 1 freezer 9 11 1 net_cls 6 10 1 perf_event 7 10 1 net_prio 6 10 1 pids 10 106 1 rdma 3 1 1 . k3sの導入 . リポジトリの手順に従います．注意が必要な点は，マスターノードとワーカーノードとで導入方法が異なる点です．ここでハマらなければ，さくっと導入できると思います．今回，以下の様にマスターノードx1，ワーカーノードx3でk3sクラスタを構成しました． . $ kubectl get nodes NAME STATUS ROLES AGE VERSION k3s-node3 Ready worker 3d12h v1.18.2+k3s1 k3s-node2 Ready worker 3d12h v1.18.2+k3s1 k3s-node1 Ready worker 3d12h v1.18.2+k3s1 k3s-master Ready master 3d18h v1.18.2+k3s1 . rayクラスタのデプロイ . こちらも公式の手順に従います．しかしながら，こちらで使用しているDockerイメージはamd64向けに作成された物であり，aarch64環境では動作しません．そこで，ほぼ等価なイメージをaarch64向けに作成しました．今回は，このイメージを用いてクラスタを作成します．具体的には，ray-cluster.yamlを以下の様に修正します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..0563c934f 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,7 +59,7 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: @@ -120,7 +120,7 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: . 以下のようにコンテナをデプロイします． . $ kubectl create -f ray/doc/kubernetes/ray-namespace.yaml namespace/ray created $ kubectl apply -f ray/doc/kubernetes/ray-cluster.yaml service/ray-head created deployment.apps/ray-head created deployment.apps/ray-worker created $ kubectl -n ray get pods NAME READY STATUS RESTARTS AGE ray-head-7957ff48b6-tj6z2 1/1 Running 0 118s ray-worker-7574c9d77-bs4dx 1/1 Running 0 118s ray-worker-7574c9d77-2868n 1/1 Running 1 118s ray-worker-7574c9d77-x48m7 1/1 Running 0 118s . クラスタの作成が完了したので，テストプログラムを実行します．こちらも公式の手順に従い，example.pyを実行します． . $ kubectl -n ray cp ray/doc/kubernetes/example.py ray-head-7957ff48b6-tj6z2:/example.py $ kubectl -n ray exec ray-head-7957ff48b6-tj6z2 -- python example.py 2020-05-24 14:13:54,824 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. Iteration 0 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 1 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 2 Counter({(&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 2}) Iteration 3 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 13, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3}) Iteration 4 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2}) Iteration 5 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 6 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 7 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3}) Iteration 8 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 9 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3}) Success! . ベンチマーク . 最後に，作成したクラスタのベンチマークとして，マンデルブロ集合の描画時間を計測します．マンデルブロ集合の描画には以下のコードを用います．画像全体をn_x_grids x n_y_grids個の領域に区切り，各領域毎に並行処理します． . #!/usr/bin/env python import numpy as np from numba import njit import itertools import os import ray import matplotlib.pyplot as plt from timeit import timeit if (os.environ.get(&quot;RAY_HEAD_SERVICE_HOST&quot;) is None): ray.init() else: redis_host = os.environ[&quot;RAY_HEAD_SERVICE_HOST&quot;] ray.init(address=redis_host + &quot;:6379&quot;) n_x_grids = int(os.environ.get(&quot;X_GRIDS&quot;, 32)) n_y_grids = int(os.environ.get(&quot;Y_GRIDS&quot;, 32)) grid_width = int(os.environ.get(&quot;GRID_WIDTH&quot;, 100)) grid_height = int(os.environ.get(&quot;GRID_HEIGHT&quot;, 100)) def grid_range(begin, end, n_grids): ih, it = itertools.tee(np.linspace(begin, end, n_grids + 1)) next(it) return ((h,t) for h,t in zip(ih, it)) @ray.remote def mandelbrot(c, n = 32, th = 200): z = 1j * np.zeros(c.shape) r = np.zeros(c.shape) for i in range(n): mask = np.abs(z) &lt;= th z += (z * z + c - z) * mask.astype(np.int) r[mask] = i # make smooth return r - np.log2(np.log2(np.abs(z) + 1)) def rendering(n_xg, n_yg, gw, gh): res = [] xs = grid_range(-2, 1, n_xg) ys = grid_range(-1, 1, n_yg) for ((xb, xe), (yb, ye)) in itertools.product(xs, ys): x, y = np.meshgrid(np.linspace(xb, xe, gw), np.linspace(yb, ye, gh)) c = x + 1j * y res.append(mandelbrot.remote(c)) res = ray.get(res) return np.concatenate(np.concatenate(np.array(res).reshape(n_yg, n_xg, gh, gw), axis=2),axis=0) benchmark = timeit(lambda: rendering(n_x_grids, n_y_grids, grid_width, grid_height), number=8) / 8 print(f&quot;time: {benchmark}&quot;) img = rendering(n_x_grids, n_y_grids, grid_width, grid_height) plt.figure(dpi=200) plt.imshow(img, cmap=&#39;rainbow&#39;, interpolation=&#39;bilinear&#39;, extent=[-2, 1, -1, 1]) plt.xticks(color=&#39;None&#39;) plt.yticks(color=&#39;None&#39;) plt.tick_params(length=0) plt.savefig(&#39;figure.png&#39;) . また，クラスタの設定も少しだけ修正します．各コンテナに割り当てるメモリの変更と，必要なパッケージをコンテナ起動時に追加します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..d2b2c9678 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,11 +59,11 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: - - &quot;ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 6379 # Redis port. - containerPort: 6380 # Redis port. @@ -120,11 +120,11 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: - - &quot;ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 12345 # Ray internal communication. - containerPort: 12346 # Ray internal communication. @@ -147,4 +147,4 @@ spec: resources: requests: cpu: 100m - memory: 512Mi + memory: 1024Mi . 実行結果を以下に示します．無事に動作している様です． . $ kubectl -n ray exec ray-head-6785995666-m49kv -- python main.py 2020-05-24 14:57:57,849 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. (pid=2799) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2799) return r - np.log2(np.log2(np.abs(z) + 1)) (pid=2780, ip=10.42.1.13) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2780, ip=10.42.4.25) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2783, ip=10.42.0.35) main.py:36: RuntimeWarning: divide by zero encountered in log2 time: 34.654623864378664 . . Rayのワーカーノードの数を変更すると以下の様に処理時間が変化しました． . ワーカーノード数 処理時間[s] . 0 | 45.09195340787119 | . 1 | 48.55051823974645 | . 2 | 38.57156975386897 | . 3 | 34.654623864378664 | . あまり安定のしない微妙な結果となりました．思った以上に並列化される部分意外にボトルネックがあったのかもしれません． . 参考 . Raspberry pi 4におけるK3Sクラスタ構築 | Ray | k3s | .",
            "url": "https://lab.ar90n.net/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "relUrl": "/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "date": " • May 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "都内でソフトウェアエンジニアをやっています． . 画像処理，Python，Web開発など広くポストしてます． . Name . 和田政弘 . GitHub . @ar90n . Twitter . @ar90n . Mail . argon.argon.argon@gmail.com . Skill . 画像処理 | 医療画像処理 | Python | C++ | Web | 組み込み | .",
          "url": "https://lab.ar90n.net/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lab.ar90n.net/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}