{
  
    
        "post0": {
            "title": "Rustでレイトレーシングをしてみる",
            "content": "はじめに . Rustの勉強を兼ねて，こちらを参考にレイトレーシングを写経してみました． . メモ . 十分な数のRayを計算しなければ綺麗な画像は得られない．レイトレーシング結果のサンプルで，画素が黒く欠損しているのは十分な数のRayを計算していないから | Rayによってランダムにサンプリングすることで，ブラーやボケやアンチエイリアシングを表現する | 思っていたよりも単純 | . 結果 . 1週目 . | 2週目 . | . 参考 . Ray Tracing in One Weekend | Ray Tracing: the Next Week |",
            "url": "https://lab.ar90n.net/rust/computergraphics/2021/03/30/ray-tracing-in-weekend.html",
            "relUrl": "/rust/computergraphics/2021/03/30/ray-tracing-in-weekend.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "glutinに入門してみる",
            "content": "はじめに . glutin に入門した記録です． Objファイルをロードして，スタンフォードバニーを表示するサンプルプログラムを作成します． . glutinとは . Rustで記述されたOpenGLのラッパーライブラリです． OpenGLのラッパーライブラリには抽象度が高いものから低いものまで様々あります． 本ライブラリは，それらの中でも抽象度が低い，低レベルな機能を提供することを目的としたライブラリです． したがって，OpenGL相当の非常にプリミティブな機能しか提供されていません． . glutinの実装の興味深い点に，ユーザが指定したAPIのバインディングをビルド時に動的に生成する点が挙げられます． この機能の利用方法については， サンプルプログラムの動作を通じて後述します． . サンプルプログラムの解析 . サンプルプログラムの実行 . リポジトリページにある手順に従ってサンプルプログラムを実行します． . $ git clone https://github.com/rust-windowing/glutin $ cd glutin $ cargo run --example window . すると，以下のようなウィンドウが表示されます． . . gl_bindings.rsの生成 . それでは，このサンプルプログラムの詳細をみていきます． . まず，Cargo.tomlを見てみます．すると，以下のようにbuild.rsがbuild scriptが設定されていることが確認できます． . [package] name = &quot;glutin_examples&quot; ... build = &quot;build.rs&quot; ... [build-dependencies] gl_generator = &quot;0.14&quot; . build.rsを確認すると，１２行目から１４行目において，GLES 2.0のバインディングを生成していることが確認できます． この処理は，gl_generatorを用いて実現されています． . use gl_generator::{Api, Fallbacks, Profile, Registry}; use std::env; use std::fs::File; use std::path::PathBuf; fn main() { let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } . 次に，実際にどのようあファイルが生成されているかを確認します． 環境変数OUT_DIRはcargoによって設定されてしまうため，任意の値を設定することができません． そこで，以下のように環境変数名を変更します． . $ git diff diff --git a/glutin_examples/build.rs b/glutin_examples/build.rs index 77f6fa5..4ff7c4e 100644 a/glutin_examples/build.rs +++ b/glutin_examples/build.rs @@ -4,7 +4,7 @@ use std::fs::File; use std::path::PathBuf; fn main() { - let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); + let dest = PathBuf::from(&amp;env::var(&quot;TMP_OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); . そして，ビルドするとgl_bindings.rsというファイルが作成されていることが確認できます． ファイルの内容を確認すると，GLES 2.0に利用されるデータ構造のバインディングか確認できます． . $ TMP_OUT_DIR=`pwd` cargo build --example window $ ls gl_bindings.rs gl_bindings.rs $ head -n 32 gl_bindings.rs mod __gl_imports { pub use std::mem; pub use std::marker::Send; pub use std::os::raw; } pub mod types { #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)] // Common types from OpenGL 1.1 pub type GLenum = super::__gl_imports::raw::c_uint; pub type GLboolean = super::__gl_imports::raw::c_uchar; pub type GLbitfield = super::__gl_imports::raw::c_uint; pub type GLvoid = super::__gl_imports::raw::c_void; pub type GLbyte = super::__gl_imports::raw::c_char; pub type GLshort = super::__gl_imports::raw::c_short; pub type GLint = super::__gl_imports::raw::c_int; pub type GLclampx = super::__gl_imports::raw::c_int; pub type GLubyte = super::__gl_imports::raw::c_uchar; pub type GLushort = super::__gl_imports::raw::c_ushort; pub type GLuint = super::__gl_imports::raw::c_uint; pub type GLsizei = super::__gl_imports::raw::c_int; pub type GLfloat = super::__gl_imports::raw::c_float; pub type GLclampf = super::__gl_imports::raw::c_float; pub type GLdouble = super::__gl_imports::raw::c_double; pub type GLclampd = super::__gl_imports::raw::c_double; pub type GLeglImageOES = *const super::__gl_imports::raw::c_void; pub type GLchar = super::__gl_imports::raw::c_char; pub type GLcharARB = super::__gl_imports::raw::c_char; . 次に，ターゲットのAPIをApi::Glに変更して&#39;gl_bindings.rsを生成してみます. すると，先ほど生成したgl_bindings.rsとは内容が異なることが確認できます． このように，ターゲットや機能に合わせて，バックエンドを静的に切り替えて使用することが可能です． . $ mv gl_bindings.rs gl_bindings_gles2.rs $ git diff diff --git a/glutin_examples/build.rs b/glutin_examples/build.rs index 77f6fa5..7e149bd 100644 a/glutin_examples/build.rs +++ b/glutin_examples/build.rs @@ -4,12 +4,12 @@ use std::fs::File; use std::path::PathBuf; fn main() { - let dest = PathBuf::from(&amp;env::var(&quot;OUT_DIR&quot;).unwrap()); + let dest = PathBuf::from(&amp;env::var(&quot;TMP_OUT_DIR&quot;).unwrap()); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); - Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, []) + Registry::new(Api::Gl, (3, 3), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } $ TMP_OUT_DIR=`pwd` cargo build --example window $ diff gl_bindings.rs gl_bindings_gles2.rs | head -n 32 121a122 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_ATOMIC_COUNTER_BUFFERS: types::GLenum = 0x92D9; 123a125,126 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_PROGRAM: types::GLenum = 0x8259; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_RESOURCES: types::GLenum = 0x92F5; 128a132 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_VARIABLES: types::GLenum = 0x9305; 129a134,136 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALIASED_POINT_SIZE_RANGE: types::GLenum = 0x846D; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALL_BARRIER_BITS: types::GLenum = 0xFFFFFFFF; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALL_SHADER_BITS: types::GLenum = 0xFFFFFFFF; 130a138 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS: types::GLenum = 0x0D55; 133,135d140 &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND: types::GLenum = 0x1501; &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND_INVERTED: types::GLenum = 0x1504; &lt; #[allow(dead_code, non_upper_case_globals)] pub const AND_REVERSE: types::GLenum = 0x1502; 136a142 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ANY_SAMPLES_PASSED_CONSERVATIVE: types::GLenum = 0x8D6A; 138a145,152 &gt; #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_SIZE: types::GLenum = 0x92FB; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_STRIDE: types::GLenum = 0x92FE; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BARRIER_BIT: types::GLenum = 0x00001000; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER: types::GLenum = 0x92C0; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_BINDING: types::GLenum = 0x92C1; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_INDEX: types::GLenum = 0x9301; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_SIZE: types::GLenum = 0x92C3; &gt; #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_START: types::GLenum = 0x92C2; 141,146d154 &lt; #[allow(dead_code, non_upper_case_globals)] pub const BACK_LEFT: types::GLenum = 0x0402; &lt; #[allow(dead_code, non_upper_case_globals)] pub const BACK_RIGHT: types::GLenum = 0x0403; &lt; #[allow(dead_code, non_upper_case_globals)] pub const BGR: types::GLenum = 0x80E0; . ウィンドウの表示とポリゴンの描画 . 先ほど実行したサンプルプログラムに対応するコードはこちらになります． それでは，こちらの内容を先頭から紹介していきます． . まずは，supportモジュールと利用するglutinのモジュールのインポートです． supportモジュールは，ポリゴンの生成と描画，頂点シェーダ，フラグメントシェーダなど，サンプルプログラムに表示された三角形を描画するための処理が含まれています． . mod support; use glutin::event::{Event, WindowEvent}; use glutin::event_loop::{ControlFlow, EventLoop}; use glutin::window::WindowBuilder; use glutin::ContextBuilder; . 次にmain関数です．main関数では，まず初めにイベントループ，ウィンドウ，このウインドウと紐づいたGLコンテキストを作成します． コード中のwindowed_contextとは，ウインドウとこのウィンドウに紐づいたGLコンテキストとを表現する構造体になります． . fn main() { let el = EventLoop::new(); let wb = WindowBuilder::new().with_title(&quot;A fantastic window!&quot;); let windowed_context = ContextBuilder::new().build_windowed(wb, &amp;el).unwrap(); let windowed_context = unsafe { windowed_context.make_current().unwrap() }; println!(&quot;Pixel format of the window&#39;s GL context: {:?}&quot;, windowed_context.get_pixel_format()); ... } . 次にコンテキストの取得を行います．この処理は，support::loadによって実現します． support::loadでは，以下のような処理が実行されます． . 頂点シェーダとフラグメントシェーダのコンパイル | シェーダプログラムの作成 | 三角形のポリゴンを表す頂点バッファオブジェクトと頂点配列オブジェクトの作成 | 上記各種リソースのGLコンテキストへの割り当て | . このコンテキストは上述のGLコンテキストを内部に持ち，各種描画処理を移譲します． . let gl = support::load(&amp;windowed_context.context()); . 最後にイベントハンドラです．このイベントハンドラは先ほど作成したイベントループ渡され，何かイベントが発生するたびに呼び出されます． 従って，イベントハンドラでは，発生したイベントの識別とそのイベントに対応する振る舞いを記述する必要があります． 各イベントに対する振る舞いについては，コード中にコメントとして追記しました． . el.run(move |event, _, control_flow| { println!(&quot;{:?}&quot;, event); *control_flow = ControlFlow::Wait; match event { Event::LoopDestroyed =&gt; return, // イベントループか破棄されたのでインベントハンドラから抜ける Event::WindowEvent { event, .. } =&gt; match event { WindowEvent::Resized(physical_size) =&gt; windowed_context.resize(physical_size), // ウインドウをリサイズ WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit, // ウインドウを閉じる _ =&gt; (), }, Event::RedrawRequested(_) =&gt; { gl.draw_frame([1.0, 0.5, 0.7, 1.0]); // ポリゴンの描画． windowed_context.swap_buffers().unwrap(); // オフスクリーンに描画した結果を表示する } _ =&gt; (), } }); . スタンフォードバニーを表示する . Objファイルを読み取り，スタンフォードバニーを描画するサンプルプログラムを作成しました． このサンプルを実行すると，以下のような画面が表示されます． . . 全体の構成は，glutinのサンプルプログラムを大きく変更はありません， 従って，比較的容易に読み取ることが可能かと思います． しかしながら，幾つか新しい試みを行っているため，それらについて紹介します． . gl_bindings.rsのソースツリーへの取り込み . 前述した通り，gl_bindings.rsはビルド時に動的に生成されます．従って，これらが提供する型を編集時に取得することはできません． そのため，このままではコード補完や静的解析を行うことができません． Rustによる開発では，これらのツールは非常に重要であるため，このままでは非常に辛い開発が強いられます． . そこで，gl_buildings.rsをソースツリーに取り込んでしまうことにしました． 具体的には，以下のようにgl_bindings.rsの保存先を変更します． . fn main() { let mut dest = PathBuf::from(env!(&quot;CARGO_MANIFEST_DIR&quot;)); dest.push(&quot;src&quot;); println!(&quot;cargo:rerun-if-changed=build.rs&quot;); let mut file = File::create(&amp;dest.join(&quot;gl_bindings.rs&quot;)).unwrap(); Registry::new(Api::Gl, (3, 1), Profile::Core, Fallbacks::All, []) .write_bindings(gl_generator::StructGenerator, &amp;mut file) .unwrap(); } . この変更により，初回のビルド以降は以下のようにgl_bindings.rsがソースツリー内に存在します． 従って，コード補完や静的解析が適切に動作します． . $ ls ./src context.rs gl_bindings.rs main.rs obj.rs shader.rs . 注意点としては，gl_bindings.rsは動的に生成されるものなのでリポジトリに含んではいけないことです． 従って，以下のように.gitignoreに追加します． . $ cat .gitignore src/gl_bindings.rs target . Objファイルについて . Objファイルと呼ばれるファイルフォーマットには様々なものがあります． ここで使用するのは，3Dモデルを表現するために用いられるObjファイルです． また，Objファイルは頂点，面，法線など様々なデータを格納することができます． ここでは，以下のように頂点とそれらによって構成される面のみを対象とします． . v &lt;頂点番号1&gt; &lt;X座標1&gt; &lt;Y座標1&gt; &lt;Z座標1&gt; v &lt;頂点番号2&gt; &lt;X座標2&gt; &lt;Y座標2&gt; &lt;Z座標2&gt; ... f &lt;面番号1&gt; &lt;頂点番号i&gt; &lt;頂点番号j&gt; &lt;頂点番号k&gt; ... . 参考 . glutin |",
            "url": "https://lab.ar90n.net/rust/glutin/opengl/computergraphics/2021/02/01/getting-started-with-glutin.html",
            "relUrl": "/rust/glutin/opengl/computergraphics/2021/02/01/getting-started-with-glutin.html",
            "date": " • Feb 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "starshipの導入",
            "content": "Cicaを導入する . startshipを使用するためには，事前にNerdFontを導入する必要があります． そこで，今回はCicaを使用しました． 導入はリリースページから配布されているアーカイブをダウンロードしttfファイルをダブルクリックで完了です． . startshipを導入する . brewを使ってstartshipを導入します． . $ brew install starship . 以下のように良い感じです． . .",
            "url": "https://lab.ar90n.net/tool/2021/01/06/install-starship.html",
            "relUrl": "/tool/2021/01/06/install-starship.html",
            "date": " • Jan 6, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "型レベル整数ライブラリtypenumの紹介",
            "content": "&#12399;&#12376;&#12417;&#12395; . 型レベル整数とは，型によって整数を表現する方法です．この型とは整数を表すi32や文字列を表すStringと同様のものです．すなわち，１を表す型や，2を表す型を定義し，それらによって整数を型レベルで表現します． . 型レベル整数の嬉しい点として，型レベル整数による式はコンパイル時に評価されることが挙げられます．これによって，各種定数を容易に設定することが可能となります． . Rustにて型レベル整数の実装として，typenumというクレートがあります．ここでは，このtypenumの簡単な使用方法を紹介します． . &#12420;&#12387;&#12383;&#12371;&#12392; . typenumによる型レベル整数の定義 | typenumによってサポートされる演算の評価 | . &#23455;&#38555;&#12395;&#22411;&#12524;&#12505;&#12523;&#25972;&#25968;&#12434;&#20351;&#12387;&#12390;&#12415;&#12427; . それでは，実際にtypenumを使用して整数の演算を行っていきます．まず，1+2を計算する例を以下に示します． ここで，P1とP2はそれぞれ1と2を，Sumは加算を表します．また，to_i32()は型レベル整数が示す値をi32へ変換する処理です． . :dep typenum //above line is magic for adding crate use typenum::*; type A = Sum&lt;P1, P2&gt;; // A is P3 assert_eq!(A::to_i32(), 3); // A::to_i32() == 3 . 以上の結果より，適切に型レベルで1+2が計算出来たことがわかります．　次はもう少し複雑な例について考えます．以下に示すコードは，型レベル整数を用いて，((1 + 2 ) * 3 - 4) / 5を計算します．ここで，Quotは除算を，Diffは減算を，Prodは乗算を表します． . use typenum::*; type A = Quot&lt;Diff&lt;Prod&lt;Sum&lt;P1, P2&gt;, P3&gt;, P4&gt;, P5&gt;; // A is P1 assert_eq!(A::to_i32(), 1); // A::to_i32() == 1 . ここでは，最低限の演算しか紹介しませんでしたが，typenumにはこれら以外にも多くの機能が実装されています．興味のある方は，是非確認してみてください． . &#21442;&#32771; . typenum |",
            "url": "https://lab.ar90n.net/rust/2020/12/13/introduction-to-typenum.html",
            "relUrl": "/rust/2020/12/13/introduction-to-typenum.html",
            "date": " • Dec 13, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "evcxr_jupyterによるRust on Notebook",
            "content": "&#12399;&#12376;&#12417;&#12395; . Jupyter Notebookはカーネルを切り替えることにより，様々な言語で開発することができます．ここでは，Rustのカーネル実装であるevcxr_jupyterを用いて，NotebookによるRust開発に挑戦してみます． . &#12420;&#12387;&#12383;&#12371;&#12392; . evcxr_jupyterの導入 | 外部Crateの導入 | データ表示のカスタマイズ | plottersによるグラフの描画 | . evcxr_jupyter&#12398;&#23566;&#20837; . jupyter-langsのRustに関する部分をお借りしました．当該箇所を自分のDockerfileにコピペで特に問題なく動作しました．使用するだけならば，jupyter-langsを直接使うのが一番手っ取り早いと思います．それにしても，jupyter-langsはすごいですね．これだけカーネルを導入するのは色々と大変だったと思います．ありがたいです． . &#22806;&#37096;Crate&#12398;&#23566;&#20837; . 外部Crateの導入はCode Cellに以下の様な記述を追加することで実現します． . :dep Crate名 = バージョン . 初回評価時はコンパイルを行うため少し時間がかかります．以下に，base64を導入する例を示します． . :dep base64 = &quot;0.10.1&quot; //From Tour of the EvCxR Jupyter Kernel //https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb base64::encode(&amp;vec![1, 2, 3, 4]) . &#34;AQIDBA==&#34; . &#12487;&#12540;&#12479;&#34920;&#31034;&#12398;&#12459;&#12473;&#12479;&#12510;&#12452;&#12474; . evcxr_jupyterは以下のフォーマットでMIME Type と Content を標準出力に出力することで，HTMLに埋め込んで表示することが可能です． . EVCXR_BEGIN_CONTENT &lt;&lt;MIME Type&gt;&gt; &lt;&lt; Content &gt;&gt; EVCXR_END_CONTENT . 具体的には，以下の様に表を出力したり， . println!(r#&quot;EVCXR_BEGIN_CONTENT text/html &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; EVCXR_END_CONTENT&quot;#); . 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 画像を出力したりすることが可能です . println!(r#&quot;EVCXR_BEGIN_CONTENT image/png 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 EVCXR_END_CONTENT&quot;#); . また，fn evcxr_display(&amp;self)となる関数（トレイト？）を任意の型に対して実装することで，その型をNotebookに出力することが可能となります． 以下に，image::RgbImageに対して，fn evcxr_display(&amp;self)を実装した例を示します． . :dep image = &quot;0.23&quot; //From Tour of the EvCxR Jupyter Kernel //https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb extern crate image; extern crate base64; pub trait EvcxrResult {fn evcxr_display(&amp;self);} impl EvcxrResult for image::RgbImage { fn evcxr_display(&amp;self) { let mut buffer = Vec::new(); image::png::PNGEncoder::new(&amp;mut buffer).encode(&amp;**self, self.width(), self.height(), image::ColorType::Rgb8).unwrap(); let img = base64::encode(&amp;buffer); println!(&quot;EVCXR_BEGIN_CONTENT image/png n{} nEVCXR_END_CONTENT&quot;, img); } } image::ImageBuffer::from_fn(256, 256, |x, y| { if (x as i32 - y as i32).abs() &lt; 3 { image::Rgb([0, 0, 255]) } else { image::Rgb([0, 0, 0]) } }) . The type of the variable figure was redefined, so was lost. . plotters&#12395;&#12424;&#12427;&#12464;&#12521;&#12501;&#12398;&#25551;&#30011; . plottersとはRustで記述されたグラフを描画するためのCrateです．詳細については，まだ作成途中とのことですが，こちらの資料に詳しくまとまっていました．また，日本語の資料としては，こちらの記事が大変わかりやすくまとまっていました． . 以下に，プロット機能を用いて二次関数とマンデルブロ集合を描画する礼を示します． . :dep plotters = { git = &quot;https://github.com/38/plotters&quot;, default_features = true, features = [&quot;evcxr&quot;] } . // From Plotters Tutorial with Jupyter // https://plotters-rs.github.io/plotters-doc-data/evcxr-jupyter-integration.html extern crate plotters; use plotters::prelude::*; evcxr_figure((640, 480), |root| { root.fill(&amp;WHITE); let mut chart = ChartBuilder::on(&amp;root) .caption(&quot;y=x^2&quot;, (&quot;Arial&quot;, 50).into_font()) .margin(5) .x_label_area_size(30) .y_label_area_size(30) .build_ranged(-1f32..1f32, -0.1f32..1f32)?; chart.configure_mesh().draw()?; chart.draw_series(plotters::series::LineSeries::new( (-50..=50).map(|x| x as f32 / 50.0).map(|x| (x, x * x)), &amp;RED, )).unwrap() .label(&quot;y = x^2&quot;) .legend(|(x,y)| PathElement::new(vec![(x,y), (x + 20,y)], &amp;RED)); chart.configure_series_labels() .background_style(&amp;WHITE.mix(0.8)) .border_style(&amp;BLACK) .draw()?; Ok(()) }) . Fontconfig error: Cannot load default config file Fontconfig error: Cannot load default config file Fontconfig warning: ignoring C.UTF-8: not a valid language tag . y=x^2 0.0 0.2 0.4 0.6 0.8 -0.8 -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 y = x^2 // From mandelbrot.rs // https://github.com/38/plotters/blob/master/examples/mandelbrot.rs use plotters::prelude::*; use std::ops::Range; fn mandelbrot_set( real: Range&lt;f64&gt;, complex: Range&lt;f64&gt;, samples: (usize, usize), max_iter: usize, ) -&gt; impl Iterator&lt;Item = (f64, f64, usize)&gt; { let step = ( (real.end - real.start) / samples.0 as f64, (complex.end - complex.start) / samples.1 as f64, ); return (0..(samples.0 * samples.1)).map(move |k| { let c = ( real.start + step.0 * (k % samples.0) as f64, complex.start + step.1 * (k / samples.0) as f64, ); let mut z = (0.0, 0.0); let mut cnt = 0; while cnt &lt; max_iter &amp;&amp; z.0 * z.0 + z.1 * z.1 &lt;= 1e10 { z = (z.0 * z.0 - z.1 * z.1 + c.0, 2.0 * z.0 * z.1 + c.1); cnt += 1; } return (c.0, c.1, cnt); }); } evcxr_figure((640, 480), |root| { root.fill(&amp;WHITE); let mut chart = ChartBuilder::on(&amp;root) .margin(20) .x_label_area_size(10) .y_label_area_size(10) .build_cartesian_2d(-2.1f64..0.6f64, -1.2f64..1.2f64)?; chart .configure_mesh() .disable_x_mesh() .disable_y_mesh() .draw()?; let plotting_area = chart.plotting_area(); let range = plotting_area.get_pixel_range(); let (pw, ph) = (range.0.end - range.0.start, range.1.end - range.1.start); let (xr, yr) = (chart.x_range(), chart.y_range()); for (x, y, c) in mandelbrot_set(xr, yr, (pw as usize, ph as usize), 100) { if c != 100 { plotting_area.draw_pixel((x, y), &amp;HSLColor(c as f64 / 100.0, 1.0, 0.5))?; } else { plotting_area.draw_pixel((x, y), &amp;BLACK)?; } } Ok(()) }) . Fontconfig error: Cannot load default config file Fontconfig error: Cannot load default config file Fontconfig warning: ignoring C.UTF-8: not a valid language tag . -1.0 -0.5 0.0 0.5 1.0 -2.0 -1.5 -1.0 -0.5 0.0 0.5 &#21442;&#32771; . evcxr | jupyter-langs | RustのドローイングライブラリPlottersの紹介 |",
            "url": "https://lab.ar90n.net/rust/jupyter/2020/11/15/rust-on-nodebook-with-evcxr-jupyter.html",
            "relUrl": "/rust/jupyter/2020/11/15/rust-on-nodebook-with-evcxr-jupyter.html",
            "date": " • Nov 15, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
            "content": "&#12399;&#12376;&#12417;&#12395; . 拡大と回転と並進とによって実現する幾何学変換に相似変換があります．これは，画像間の位置合わせ等に用いられます． 具体的には，互いに対応する点${x_{i}}$と$y_{i}$$ left(i = 1, 2, dots n right)$が与えられた時，それらの間に存在する相似変換を推定するといったものです． . これを実現アルゴリズムにS.Umeyamaによって提案された手法があります．古典的な手法ではありますが，実用的なアルゴリズムであると思います．scikit-imageにおけるSimilalityTransformでも使用されています． . &#12420;&#12387;&#12383;&#12371;&#12392; . Least-Squares Estimation of Transformation Parameters Between Two Point Patternsによる提案手法を読む | Pythonによる簡易的な実装 | . &#34892;&#21015;&#12398;&#24615;&#36074;&#24489;&#32722; . 以下にこれから利用する行列の性質を示します．ここで，$ mathbf A = left(a_{i,j} right)$及び$ mathbf B = left(b_{i,j} right)$は行列を，$ left&lt; cdot, cdot right&gt;$は行列の内積を表します． . $$ begin{aligned} mathrm {tr} mathbf A &amp;= mathrm {tr} mathbf A^{ mathrm T} mathrm {tr} mathbf A mathbf B mathbf C &amp;= mathrm {tr} mathbf B mathbf C mathbf A mathrm {tr} mathbf A^{ mathrm T} mathbf B &amp;= left&lt; mathbf A, mathbf B right&gt; &amp;= left | mathbf A mathbf B right |^{2} frac{ partial}{ partial mathbf A} mathrm {tr} left( mathbf A mathbf B right) &amp;= mathbf B^{T} frac{ partial}{ partial mathbf A} mathrm {tr} left( mathbf A^{ mathrm T} mathbf B right) &amp;= mathbf B frac{ partial}{ partial mathbf A} mathrm {tr} left(f left( mathbf A right) g left( mathbf A right) right) &amp;= frac{ partial}{ partial mathbf A_{1}} mathrm {tr} left(f left( mathbf A_{1} right) g left( mathbf A right) right) + frac{ partial}{ partial mathbf A_{2}} mathrm {tr} left(f left( mathbf A right) g left( mathbf A_{2} right) right) left&lt; mathbf A, mathbf B right&gt; &amp;= mathrm {tr} mathbf A^{ mathrm T} B &amp;= sum_{i,j} a_{j,i}b_{i,j} end{aligned} $$ &#30456;&#20284;&#22793;&#25563;&#12395;&#12388;&#12356;&#12390; . 上述したとおり，相似変換とは拡大と回転と並進とによって実現する幾何学的変換です．従って，変換元を$ mathbf x$，変換先を$ mathbf x&#39;$，拡大率，回転行列，並進ベクトルをそれぞれ$ left(c, mathbf R, mathbf t right)$とすると . $$ begin{aligned} mathbf x&#39; &amp;= c mathbf R mathbf x + mathbf t end{aligned} $$と表されます． . ここで，特徴点$ mathbf x_{i}$と，その相似変換による変換$ mathbf y_{i} left(i = 1, 2, dots , n right)$を観測した場合を考えます．この時，以下の$e left(c, mathbf R, mathbf t right)$を最小化することで，$ mathbf x_{i}$と$ mathbf y_{i}$から相似変換のパラメータ$ left(c, mathbf R, mathbf t right)$を推定することができます． . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} sum_{i=1}^{n} left| mathbf y_{i} - left(c mathbf R mathbf x_{i} + mathbf t right) right|^{2} end{aligned} $$ &#22238;&#36578;&#34892;&#21015;&#12398;&#25512;&#23450; . 相似変換に推定の先立ち，まずは以下の式を最小化する$ mathbf R$を推定することを考えます．ここで，$ mathbf A$及び$ mathbf B$は$m times n$の行列を，$ mathbf R$は$m times m$の行列を表します． . $$ begin{alignedat}{4} text{minimize} &amp; &amp; left | mathbf A - mathbf R mathbf B right |^{2} &amp; text{subject to} &amp; &amp; left| mathbf R right| &amp;= 1&amp; &amp; &amp; mathbf R mathbf R^{ mathrm T} &amp;= mathbf I end{alignedat} $$$ mathbf R$を適切に推定するためには，与えられた束縛条件の元で目的関数を最小化する必要があります．従って，ラグランジュの未定乗数法を用います．ここでは，ラグランジュ関数$F$は以下の様に表されます．なお，$l_{i,j}$及び$g$はラグランジュ乗数となります． . $$ begin{aligned} F &amp;= left | mathbf A - mathbf R mathbf B right |^{2} + sum_{i=1}^{m} sum_{j=1}^{m} l_{i,j} left( mathbf R^{ mathrm T} mathbf R - mathbf I right)_{i,j} + g left( left| mathbf R right| - 1 right) end{aligned} $$上式において，$ mathbf R^{ mathrm T} mathbf R$と$ mathbf I$は対象行列です．従って，それらの差である$ left( mathbf R^{ mathrm T} mathbf R - mathbf I right)$も対象行列となります．$ left( mathbf R^{ mathrm T} mathbf R - mathbf I right)$が対象行列であるならば，対象な成分に対応するラグランジュ乗数も同様に等しくなります．すなわち， . $$ begin{aligned} l_{i,j} &amp;= l_{j,i} end{aligned} $$となります．従って，ラグランジュ関数の第2項は以下の様に表現することが可能です． . $$ begin{aligned} sum_{i=1}^{m} sum_{j=1}^{m} l_{i,j} left( mathbf R^{ mathrm T} mathbf R - mathbf I right)_{i,j}　&amp;= left&lt; left(l_{i,j} right), mathbf R^{ mathrm T} mathbf R - mathbf I right&gt; &amp;= mathrm{tr} left( left(l_{j,i} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) &amp;= mathrm{tr} left( left(l_{i,j} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) end{aligned} $$ここで， . $$ begin{aligned} mathbf L &amp;= left(l_{i,j} right) end{aligned} $$と置くと， . $$ begin{aligned} mathrm{tr} left( left(l_{i,j} right) left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right)　&amp;= mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) end{aligned} $$と表すことができます．従って，ラグランジュ関数$F$は以下の様に表現されます． . $$ begin{aligned} F &amp;= left | mathbf A - mathbf R mathbf B right |^{2} + mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) + g left( left| mathbf R right| - 1 right) end{aligned} $$ $F$を最小化する$ mathbf R$を求めるためには，以下の式を$ mathbf R$について解く必要があります． . $$ begin{aligned} frac{ partial F}{ partial mathbf R} &amp;= frac{ partial}{ partial mathbf R} left | mathbf A - mathbf R mathbf B right |^{2} + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) + frac{ partial}{ partial mathbf R} g left( left| mathbf R right| - 1 right) &amp;= 0 end{aligned} $$まずは，右辺第１項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} left | mathbf A - mathbf R mathbf B right |^{2} &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( left( mathbf A - mathbf R mathbf B right)^{ mathrm T} left( mathbf A - mathbf R mathbf B right) right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf A - mathbf A^{ mathrm T} mathbf R mathbf B - mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A + mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf A right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A^{ mathrm T} mathbf R mathbf B right) + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A right) + frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf B mathbf A^{ mathrm T} mathbf R right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf A mathbf B^{ mathrm T} mathbf R^{ mathrm T} right) + frac{ partial}{ partial mathbf R_{1}} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R_{1}^{ mathrm T} mathbf R mathbf B right) + frac{ partial}{ partial mathbf R_{2}} mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R_{2} mathbf B right) &amp;= - mathbf A mathbf B^{ mathrm T} - mathbf A mathbf B^{ mathrm T} + frac{ partial}{ partial mathbf R_{1}} mathrm{tr} left( mathbf R_{1}^{ mathrm T} mathbf R mathbf B mathbf B^{ mathrm T} right) + frac{ partial}{ partial mathbf R_{2}} mathrm{tr} left( mathbf B mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R_{2} right) &amp;= -2 mathbf A mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} + left( mathbf B mathbf B^{ mathrm T} mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= -2 mathbf A mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} + mathbf R mathbf B mathbf B^{ mathrm T} &amp;= -2 mathbf A mathbf B^{ mathrm T} + 2 mathbf R mathbf B mathbf B^{ mathrm T} end{aligned} $$ 次に，右辺第２項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L left( mathbf R^{ mathrm T} mathbf R - mathbf I right) right) &amp;= frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L mathbf R^{ mathrm T} mathbf R right) - frac{ partial}{ partial mathbf R} mathrm{tr} left( mathbf L right) &amp;= frac{ partial}{ partial mathbf R_{1}} mathrm {tr} left( mathbf L mathbf R_{1}^{ mathrm T} mathbf R right) + frac{ partial}{ partial mathbf R_{2}} mathrm {tr} left( mathbf L mathbf R^{ mathrm T} mathbf R_{2} right) &amp;= frac{ partial}{ partial mathbf R_{1}} mathrm {tr} left( mathbf R mathbf L mathbf R_{1}^{ mathrm T} right) + left( mathbf L mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= mathbf R mathbf L + mathbf R mathbf L^{ mathrm T} &amp;= mathbf R mathbf L + mathbf R mathbf L &amp;= 2 mathbf R mathbf L end{aligned} $$最後に，右辺第３項について考えます． . $$ begin{aligned} frac{ partial}{ partial mathbf R} g left( left| mathbf R right| - 1 right) &amp;= g frac{ partial}{ partial mathbf R} left| mathbf R right| &amp;= g mathbf{R} end{aligned} $$ 以上の結果より， . $$ begin{aligned} frac{ partial F}{ partial mathbf R} &amp;= -2 mathbf A mathbf B^{ mathrm T} + 2 mathbf R mathbf B mathbf B^{ mathrm T} + 2 mathbf R mathbf L +g mathbf{R} &amp;= 0 end{aligned} $$と表現することができます．上式を整理すると， . $$ begin{aligned} 2 mathbf R mathbf B mathbf B^{ mathrm T} + 2 mathbf R mathbf L +g mathbf{R} &amp;=2 mathbf A mathbf B^{ mathrm T} mathbf R left( mathbf B mathbf B^{ mathrm T} + mathbf L + frac{1}{2}g mathbf I right) &amp;= mathbf A mathbf B^{ mathrm T} end{aligned} $$と表すことができます．ここで， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf B mathbf B^{ mathrm T} + mathbf L + frac{1}{2}g mathbf I end{aligned} $$と置きます．すると， . $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf L&#39;^{ mathrm T} mathbf R^{ mathrm T} &amp;= mathbf B mathbf A^{ mathrm T} end{aligned} $$となります．$ mathbf B mathbf B^{ mathrm T}$，$ mathbf L$及び$ mathbf I$は全て対象行列です．従って， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf L&#39;^{ mathrm T} end{aligned} $$という関係が成立します．従って， . $$ begin{aligned} mathbf L&#39; mathbf R^{ mathrm T} &amp;= mathbf B mathbf A^{ mathrm T} end{aligned} $$となります．ここで，両辺にそれぞれ自身の転置を掛けると， . $$ begin{aligned} mathbf L&#39; mathbf R^{ mathrm T} left( mathbf L&#39; mathbf R^{ mathrm T} right)^{ mathrm T} &amp;= mathbf L&#39; mathbf R^{ mathrm T} mathbf R mathbf L&#39;^{ mathrm T} &amp;= mathbf L&#39; mathbf L&#39;^{ mathrm T} &amp;= mathbf L&#39;^{2} &amp;= mathbf B mathbf A^{ mathrm T} left( mathbf B mathbf A^{ mathrm T} right)^{ mathrm T} end{aligned} $$となります．また，$ mathbf A mathbf B^{ mathrm T}$の特異値分解を以下の様に置きます． . $$ begin{aligned} mathbf A mathbf B^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$すると， . $$ begin{aligned} mathbf L&#39;^{2} &amp;= left( mathbf U mathbf D mathbf V^{ mathrm T} right)^{ mathrm T} mathbf U mathbf D mathbf V^{ mathrm T} &amp;= mathbf V mathbf D mathbf U^{ mathrm T} mathbf U mathbf D mathbf V^{ mathrm T} &amp;= mathbf V mathbf D^{2} mathbf V^{ mathrm T} end{aligned} $$であり， . $$ begin{aligned} mathbf L&#39; &amp;= mathbf V sqrt{ mathbf D^{2}} mathbf V^{ mathrm T} &amp;= mathbf V begin{pmatrix} ddots &amp; &amp; &amp; sqrt{d_{i}^{2}}&amp; &amp; &amp; ddots end{pmatrix} mathbf V^{ mathrm T} &amp;= mathbf V begin{pmatrix} ddots &amp; &amp; &amp; d_{i}s_{i}&amp; &amp; &amp; ddots end{pmatrix} mathbf V^{ mathrm T} &amp;= mathbf V mathbf D mathbf S mathbf V^{ mathrm T} end{aligned} $$と表すことができます．なお，$ mathbf S = mathop{ rm diag}s_{i} left(s_{i} = pm1 right)$となります． . 次に，上式の両辺に対して行列式を考えます．すると， . $$ begin{aligned} left| mathbf L&#39; right| &amp;= left| mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right| &amp;= left| mathbf V right| cdot left| mathbf D right| cdot left| mathbf S right| cdot left| mathbf V^{ mathrm T} right| end{aligned} $$であり，$ left| mathbf V right| = left| mathbf V^{ mathrm T} right| = 1$より， . $$ begin{aligned} &amp;= left| mathbf D right| cdot left| mathbf S right| end{aligned} $$また， . $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf L&#39; &amp;= mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} mathbf L&#39; &amp;= mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} end{aligned} $$であることから， . $$ begin{aligned} left| mathbf L&#39; right| &amp;= left| mathbf R^{ mathrm T} right| cdot left| mathbf A mathbf B^{ mathrm T} right| &amp;= left| mathbf A mathbf B^{ mathrm T} right| end{aligned} $$となります．従って， $$ begin{aligned} left| mathbf D right| cdot left| mathbf S right| &amp;= left| mathbf A mathbf B^{ mathrm T} right| end{aligned} $$ . と表すことができます．また，特異値の性質より，$d_{i} geq 0$であるため， . $$ begin{aligned} left| mathbf D right| &amp; geq 0 end{aligned} $$となります．従って， . $$ begin{aligned} left| mathbf S right|&amp;= begin{cases} 1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| geq 0 -1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| leq 0 end{cases} end{aligned} $$となります．ここで，$ left| mathbf A - mathbf R mathbf B right|^{2}$の最小化について考えます．以上の結果より$ left| mathbf A - mathbf R mathbf B right|^{2}$は， . $$ begin{aligned} left | mathbf A - mathbf R mathbf B right |^{2} &amp;= mathrm{tr} left( left( mathbf A - mathbf R mathbf B right)^{ mathrm T} left( mathbf A - mathbf R mathbf B right) right) &amp;= mathrm{tr} left( mathbf A^{ mathrm T} mathbf A right) - mathrm{tr} left( mathbf A^{ mathrm T} mathbf R mathbf B right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf R mathbf B right) &amp;= left | mathbf A right |^{2} - mathrm{tr} left( left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right)^{ mathrm T} right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf R mathbf B right) &amp;= left | mathbf A right |^{2} - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) - mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) + mathrm{tr} left( mathbf B^{ mathrm T} mathbf B right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( left( mathbf R mathbf B right)^{ mathrm T} mathbf A right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf B^{ mathrm T} mathbf R^{ mathrm T} mathbf A right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf R^{ mathrm T} mathbf A mathbf B^{ mathrm T} right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} - 2 mathrm{tr} left( mathbf L&#39; right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf D mathbf S mathbf V^{ mathrm T} mathbf V right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 mathrm{tr} left( mathbf D mathbf S right) &amp;= left | mathbf A right |^{2} + left | mathbf B right |^{2} -2 left(d_{1}s_{1} + d_{2}s_{2} + cdots + d_{m}s_{m} right) end{aligned} $$と表すことができます．ここで，$ mathbf A$，$ mathbf B$，$d_{i}$が問題より与えられており，$ left | mathbf A right |^{2} ge 0$，$ left | mathbf B right |^{2} ge 0$となります．従って，$ text{minimize} left | mathbf A - mathbf R mathbf B right |^{2}$は以下の様に書き換えることができます． . $$ begin{alignedat}{4} text{maximize} &amp; &amp; d_{1}s_{1} + d_{2}s_{2} + cdots + d_{m}s_{m} &amp; text{subject to} &amp; &amp; s_{1}s_{2} cdots s_{m} &amp;= begin{cases} 1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| geq 0 -1 &amp; text{if} left| mathbf A mathbf B^{ mathrm T} right| leq 0 end{cases}&amp; &amp; &amp; left| s_{i} right| &amp;= 1 end{alignedat} $$まず，$ left| mathbf A mathbf B^{ mathrm T} right| geq 0$の場合について考えます．この時，$s_{i}=1$で目的関数が最大化することは明らかです．次に，$ left| mathbf A mathbf B^{ mathrm T} right| leq 0$の場合について考えます．$d_{1} geq d_{2} geq cdots geq d_{m}$であるため，$s_{1} = s_{2} = cdots = s_{m-1} = 1$，$s_{m} = -1$で目的関数が最大化します． . 最後に，以上の結果を元に実際に$ mathbf R$を求めていきます．まず，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m$である場合を考えます．この時，$ mathbf L&#39;$は正則行列となります．よって， . $$ begin{aligned} mathbf L&#39;^{-1} &amp;= left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right)^{-1} &amp;= left( mathbf V^{ mathrm T} right)^{-1} mathbf S^{-1} mathbf D^{-1} mathbf V^{-1} &amp;= mathbf V mathbf S mathbf D^{-1} mathbf V^{ mathrm T} &amp;= mathbf V mathbf D^{-1} mathbf S mathbf V^{ mathrm T} end{aligned} $$となります．従って， . $$ begin{aligned} mathbf R &amp;= mathbf A mathbf B^{ mathrm T} mathbf L&#39;^{-1} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf V mathbf D^{-1} mathbf S mathbf V^{ mathrm T} &amp;= mathbf U mathbf S mathbf V^{ mathrm T} end{aligned} $$となります．次に，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m-1$である場合を考えます． . $$ begin{aligned} mathbf A mathbf B^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf L&#39; &amp;= mathbf V mathbf D mathbf S mathbf V^{ mathrm T} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} end{aligned} $$であるため， $$ begin{aligned} mathbf R mathbf L&#39; &amp;= mathbf A mathbf B^{ mathrm T} mathbf R left( mathbf V mathbf D mathbf S mathbf V^{ mathrm T} right) &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf R mathbf V mathbf D mathbf S mathbf V^{ mathrm T} mathbf V &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf V mathbf R mathbf V mathbf D mathbf S &amp;= mathbf U mathbf D end{aligned} $$ . ここで，$ mathrm{rank} left( mathbf A mathbf B^{ mathrm T} right) = m-1$であるため，$d_{m} = 0$となります．また，$s_{1} = s_{2} = cdots = s_{m} = 1$であるため， . $$ begin{aligned} mathbf D mathbf S &amp;= mathbf D end{aligned} $$となります．よって， . $$ begin{aligned} mathbf R mathbf V mathbf D &amp;= mathbf U mathbf D end{aligned} $$ここで， $$ begin{aligned} mathbf Q &amp;= mathbf U^{ mathrm T} mathbf R mathbf V left| mathbf Q right| &amp;= left| mathbf U^{ mathrm T} mathbf R mathbf V right| &amp;= left| mathbf U^{ mathrm T} right| left| mathbf R right| left| mathbf V right| &amp;= left| mathbf U right| left| mathbf V right| end{aligned} $$ . と置くと， . $$ begin{aligned} mathbf U^{ mathrm T} mathbf R mathbf V mathbf D &amp;= mathbf U^{ mathrm T} mathbf U mathbf D mathbf Q mathbf D &amp;= mathbf D end{aligned} $$と表すことができます．さらに . $$ begin{aligned} mathbf Q &amp;= left( mathbf q_{1} mathbf q_{2} cdots mathbf q_{m} right) mathbf e_{i} &amp;= left(e_{i,1}, e_{i,2}, cdots, e_{i,m} right)^{ mathrm T} e_{i,j} &amp;= begin{cases} 0 &amp; text{otherwise} 1 &amp; text{if} i=j end{cases} end{aligned} $$と置くと， . $$ begin{aligned} d_{i} mathbf q_{i} &amp;= d_{i} mathbf e_{i} mathbf q_{i} &amp;= mathbf e_{i} left( 1 leq i leq m - 1 right) end{aligned} $$となります．また，$ mathbf U$, $ mathbf R$, $ mathbf V$は全て直交行列です．従って$ mathbf Q$も同様に直交行列となります．そのため，$ mathbf q_{m}$は$ mathbf q_{1} cdots mathbf q_{m-1}$と直交します．従って， . $$ begin{aligned} mathbf q_{m} = begin{cases} mathbf e_{m} &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 - mathbf e_{m} &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} end{aligned} $$となります．以上の結果より， . $$ begin{aligned} mathrm{svd} left( mathbf A mathbf B^{ mathrm T} right) &amp;= mathbf U mathbf D mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} mathbf R &amp;= mathbf U mathbf Q mathbf V^{ mathrm T} &amp;= mathbf U mathbf S mathbf V^{ mathrm T} end{aligned} $$ &#30456;&#20284;&#22793;&#25563;&#12398;&#25512;&#23450; . 前述した通り，相似変換は以下の$e^{2} left(c, mathbf R, mathbf t right)$を最小化する$c, mathbf R, mathbf t$を求めることによって与えられます． . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} sum_{i=1}^{n} left| mathbf y_{i} - left(c mathbf R mathbf x_{i} + mathbf t right) right|^{2} end{aligned} $$ここで，$ mathbf X= left( mathbf x_{1}, mathbf x_{2}, cdots, mathbf x_{n} right)$，$ mathbf Y= left( mathbf y_{1}, mathbf y_{2}, cdots, mathbf y_{n} right)$，$ mathbf h = left(1, 1, cdots, 1 right)^{ mathrm T}$と置くと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y - c mathbf R mathbf X - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} end{aligned} $$と表現することができます．また， . $$ begin{aligned} mathbf K &amp;= mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} mathbf K &amp;= mathbf K^{ mathrm T} mathbf K mathbf K^{ mathrm T} &amp;= mathbf K end{aligned} $$とすると， . $$ begin{aligned} mathbf X mathbf K &amp;= mathbf X left( mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} right) &amp;= mathbf X - frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} mathbf X &amp;= mathbf X mathbf K + frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} end{aligned} $$であり，同様に， . $$ begin{aligned} mathbf Y &amp;= mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} end{aligned} $$これらを用いて，$e^{2} left(c, mathbf R, mathbf t right)$を表すと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} - c mathbf R left( mathbf X mathbf K + frac{1}{n} mathbf X mathbf h mathbf h^{ mathrm T} right) - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K + frac{1}{n} mathbf Y mathbf h mathbf h^{ mathrm T} - c mathbf R mathbf X mathbf K - frac{c}{n} mathbf R mathbf X mathbf h mathbf h^{ mathrm T} - mathbf t mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K + left( frac{1}{n} mathbf Y mathbf h - frac{c}{n} mathbf R mathbf X mathbf h - mathbf t right) mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right |^{ mathrm 2} &amp;= frac{1}{n} mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K - mathbf t&#39; mathbf h^{ mathrm T} right) right) &amp;= frac{1}{n} mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) - left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) - left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) + left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) &amp;= frac{1}{n} left { mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right) - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right)+ mathrm{tr} left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( left( mathbf t&#39; mathbf h^{ mathrm T} right)^{ mathrm T} left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right) right)^{ mathrm T} right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) - mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( left( mathbf Y mathbf K - c mathbf R mathbf X mathbf K right)^{ mathrm T} left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( left( mathbf K^{ mathrm T} mathbf Y^{ mathrm T} - c mathbf K^{ mathrm T} mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( mathbf K^{ mathrm T} left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } &amp;= frac{1}{n} left { left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2} -2 mathrm{tr} left( mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) left( mathbf t&#39; mathbf h^{ mathrm T} right) right) right } end{aligned} $$なお， . $$ begin{aligned} mathbf t&#39; &amp;= - frac{1}{n} mathbf Y mathbf h + frac{c}{n} mathbf R mathbf X mathbf h + mathbf t end{aligned} $$と置いています．ここで，右辺第３項について考えます． $$ begin{aligned} mathrm{tr} left( mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; mathbf h^{ mathrm T} right) &amp;= mathrm{tr} left( mathbf h^{ mathrm T} mathbf K left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( mathbf h^{ mathrm T} left( mathbf I - frac{1}{n} mathbf h mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( left( mathbf h^{ mathrm T} - frac{1}{n} mathbf h^{ mathrm T} mathbf h mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= mathrm{tr} left( left( mathbf h^{ mathrm T} - mathbf h^{ mathrm T} right) left( mathbf Y^{ mathrm T} - c mathbf X^{ mathrm T} mathbf R^{ mathrm T} right) mathbf t&#39; right) &amp;= 0 end{aligned} $$ . 次に右辺第２項について考えます． $$ begin{aligned} left | mathbf t&#39; mathbf h^{ mathrm T} right |^{2}&amp;= n left | mathbf t&#39; right |^{2} end{aligned} $$ . 以上の結果より， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t right) &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} + left | mathbf t&#39; right |^{2} end{aligned} $$と表されます．$e^{2} left(c, mathbf R, mathbf t right)$を最小化するために，$ mathbf t&#39;=0$と置くと， . $$ begin{aligned} mathbf t&#39; &amp;= - frac{1}{n} mathbf Y mathbf h + frac{c}{n} mathbf R mathbf X mathbf h + mathbf t &amp;= 0 end{aligned} $$従って， . $$ begin{aligned} mathbf t &amp;= frac{1}{n} mathbf Y mathbf h - frac{c}{n} mathbf R mathbf X mathbf h end{aligned} $$ここで， $$ begin{aligned} mathbf{ mu_{y}} &amp;= frac{1}{n} mathbf Y mathbf h mathbf{ mu_{x}} &amp;= frac{1}{n} mathbf X mathbf h end{aligned} $$ . と置くと， $$ begin{aligned} mathbf t &amp;= mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} end{aligned} $$ . 並進成分が求まったので，再度評価関数$e^{2}$を書き下すと， . $$ begin{aligned} e^{2} left(c, mathbf R, mathbf t = mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} right) &amp;= frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} end{aligned} $$ここで，$ frac{1}{n} mathbf Y mathbf K mathbf X^{ mathrm T}$の特異値分解を以下の様に置きます． $$ begin{aligned} frac{1}{n} mathbf Y mathbf K mathbf X^{ mathrm T} &amp;= mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$ . すると， . $$ begin{aligned} left( mathbf Y mathbf K right) left(c mathbf X mathbf K right)^{ mathrm T} &amp;= c mathbf Y mathbf K mathbf K^{ mathrm T} mathbf X^{ mathrm T} &amp;= c mathbf Y mathbf K mathbf X^{ mathrm T} &amp;= cn mathbf U mathbf D mathbf V^{ mathrm T} end{aligned} $$また，回転行列の推定の結果より， $$ begin{aligned} frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2} &amp;= frac{1}{n} left { left | mathbf Y mathbf K right |^{2} + c^{2} left | mathbf X mathbf K right |^{2} - 2 mathrm{tr} left(cn mathbf U mathbf D mathbf V^{ mathrm T} right) right } end{aligned} $$ . 上式を$c$について最小化すると， . $$ begin{aligned} frac{ partial}{ partial c} frac{1}{n} left | mathbf Y mathbf K - c mathbf R mathbf X mathbf K right |^{2}&amp;= frac{1}{n} left {2 c left | mathbf X mathbf K right |^{2} - 2n mathrm{tr} left( mathbf U mathbf D mathbf V^{ mathrm T} right) right } &amp;= 0 c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ frac{1}{n} left | mathbf X mathbf K right |^{2}} end{aligned} $$ここで， . $$ begin{aligned} sigma_{x}^{2}&amp;= frac{1}{n} left | mathbf X mathbf K right |^{2} end{aligned} $$とおくと， . $$ begin{aligned} c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ sigma_{x}^{2}} end{aligned} $$また，回転行列$ mathbf R$についても同様に . $$ begin{aligned} mathbf R &amp;= mathbf U mathbf S mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} end{aligned} $$以上の結果をまとめると， $$ begin{aligned} c &amp;= frac{ mathrm{tr} left( mathbf D mathbf S right)}{ sigma_{x}^{2}} mathbf R &amp;= mathbf U mathbf S mathbf V^{ mathrm T} mathbf S &amp;= begin{cases} mathbf I &amp; text{if} left| mathbf U right| left| mathbf V right| = 1 mathrm{diag} left(1, 1, cdots, 1, -1 right) &amp; text{if} left| mathbf U right| left| mathbf V right| = -1 end{cases} mathbf t &amp;= mathbf{ mu_{y}} - c mathbf R mathbf{ mu_{x}} end{aligned} $$ . Python&#12395;&#12424;&#12427;&#23455;&#35013; . 上述の方法をPythonで実装しました．青色の点が$ mathbf X$を，橙色の点が$ mathbf Y$を，緑色の点が$c mathbf R mathbf X$をそれぞれ表しています．橙色の点ど緑色の点が重なっていることから，パラメータの推定が適切に行われていることを確認できます． . import numpy as np from random import random import math import matplotlib.pyplot as plt n = 64 c = random() + 0.5 theta = math.pi * random() cs, ss = math.cos(theta), math.sin(theta) R = np.array([[cs, -ss], [ss, cs]]) t = np.random.rand(2, 1) noise = 0.0 * np.random.rand(2, n) X = np.random.rand(2, n) Y = c * R @ X + t + noise h = np.ones((n, 1)) K = np.eye(n) - 1 / n * h @ h.T U, D, V = np.linalg.svd(Y @ K @ X.T / n) S = np.diag([1,np.linalg.det(U) * np.linalg.det(V) ]) R_pred = U @ S @ V.T c_pred = n * np.trace(np.diag(D) @ S) / np.trace(X @ K @ X.T) t_pred = ((Y @ h) - c_pred * R_pred @ X @ h) / n Y_pred = c_pred * R_pred @ X + t_pred ax = plt.gca() ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) plt.scatter(x = X[0,:], y =X[1,:], label=&quot;X&quot;, color=&quot;tab:blue&quot;, alpha=0.3) plt.scatter(x = Y[0,:], y =Y[1,:], label=&quot;Y&quot;, color=&quot;tab:orange&quot;, alpha=0.3) plt.scatter(x = Y_pred[0,:], y =Y_pred[1,:], label=&quot;Y_pred&quot;, color=&quot;tab:green&quot;, alpha=0.3) ax.legend() plt.show() . &#21442;&#32771; . Least-Squares Estimation of Transformation Parameters Between Two Point Patterns, S. Umeyama, 1991 | Matrix Cookbook, Kaare Brandt Petersen, Michael Syskind Pedersen, 2005 |",
            "url": "https://lab.ar90n.net/imageprocessing/geometry/2020/11/08/read-umeyama-1991-paper.html",
            "relUrl": "/imageprocessing/geometry/2020/11/08/read-umeyama-1991-paper.html",
            "date": " • Nov 8, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "smart_openによる統一的なファイルアクセス",
            "content": "&#12399;&#12376;&#12417;&#12395; . ファイルの格納先(ファイルシステム，S3，GCS等)毎にIO処理を記述すると，プログラムが複雑になりがちです．ここでは，それらを統一的に取り扱うことができるsmart_openについて述べます． . &#12420;&#12387;&#12383;&#12371;&#12392; . smart_openの導入 | smart_openによるファイルシステム，クラウドストレージ，Webからのファイル読み込み | . smart_open&#12395;&#12388;&#12356;&#12390; . smart_openはビルトインのopenを置き換えることで，様々なプロトコルを用いてファイルをオープンすることを可能にします．現状のプロトコルに対応している様です． . S3 | GCS | Blob Storage | HDFS | ファイルシステム | SSH | SCP | SFTP | HTTP | . また，以下形式で圧縮されたファイルを透過的に扱うことができます． . gzip | bzip2 | . ここでは，ファイルシステム，S3，GCS，HTTPによるファイルアクセスを評価します． . 従って，以下のようにクラウドストレージをサポートするsmart_openを導入します． . $ pip install smart_open[all] . 他の導入方法については，リポジトリのREADMEを参考にしてください． . &#12463;&#12521;&#12454;&#12489;&#12473;&#12488;&#12524;&#12540;&#12472;&#65292;Web&#12363;&#12425;&#12501;&#12449;&#12452;&#12523;&#12434;&#35501;&#12415;&#36796;&#12416; . 通常，クラウドストレージ上のファイルにアクセスするには専用のSDKを使用することが多いと思います． また，HTTPプロトコルでアクセスするには，urllibやrequests等を使用することが多いと思います． そのため，リソースに応じてこれらのライブラリを適切に取り扱う必要があります． . smart_openはこれらのライブラリを適切にラップします．従って，これらのファイルをファイルシステム上にあるかの様に取り扱うことが可能となります． . ここでは，TIFFファイルをGCS, S3, HTTP, ファイルシステム経由で読み込み表示するサンプルを示します．なお，事前に適切な認証情報を設定しておく必要があります． . from smart_open import open import matplotlib.pyplot as plt from PIL import Image sources = { &quot;S3&quot;: &quot;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;HTTP&quot;: &quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;FILESYSTEM&quot;: &quot;/tmp/LC80030172015001LGN00_BQA.TIF&quot; } for protocol, url in sources.items(): with open(url, &quot;rb&quot;) as fp: img = Image.open(fp) plt.figure() plt.title(f&quot;from {protocol}&quot;) plt.imshow(img, cmap=&#39;gray&#39;) . pathlib.Path&#32076;&#30001;&#12391;smart_open&#12434;&#20351;&#12358;&#12371;&#12392;&#12399;&#12391;&#12365;&#12427;&#12424;&#12358;&#12391;&#12377;&#12364; . いかなるリソースもopenで同様に取り扱うことができる事はとても便利です．しかしながら，strでリソースを指定するのは少し大変です．なので，pathlib.Pathでリソースを指定できると便利です． . smart_openはpathlib.Path.openをフックすることできるようです．しかしながら，pathlib.Pathがファイルパスしか扱えない(//が/に置換されてしまう)ので，すこし微妙かもしれません．． . from pathlib import Path Path(&quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;) . PosixPath(&#39;https:/s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&#39;) . &#21442;&#32771; . smart_open | .",
            "url": "https://lab.ar90n.net/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "relUrl": "/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "date": " • Oct 21, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
            "content": "はじめに . このUSB-NICをUbuntu 20.04から使用するために行った作業記録です． . やったこと . ネットワークデバイスを有効 | netplanで静的IPアドレスを設定 | . 現状の確認 . USBポートに差し込んだのみでは，ネットワークデバイスとして使用可能な状態にはなりませんでした． まずは，USBデバイスとして適切に認識されていることを確認します． . $ lsusb Bus 002 Device 002: ID 0b95:1790 ASIX Electronics Corp. AX88179 Gigabit Ethernet Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 8087:0a2a Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub . ASIX Electronics Corp. AX88179 Gigabit Ethernet このデバイスが対象のUSB-NICであるようです． . ネットワークデバイスとして認識する . 参考サイトの方法に従ってネットワークデバイスとして認識させます． . $ sudo lshw -c Network ... *-network:0 DISABLED description: Ethernet interface physical id: 1 bus info: usb@2:4 logical name: enx000ec6853d1a serial: 00:0e:c6:85:3d:1a size: 10Mbit/s capacity: 1Gbit/s capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation configuration: autonegotiation=off broadcast=yes driver=ax88179_178a duplex=half link=no multicast=yes port=MII speed=10Mbit/s ... $ sudo ifconfig enx000ec6853d1a up $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 39 bytes 3635 (3.6 KB) RX errors 0 dropped 32 overruns 0 frame 0 TX packets 7 bytes 882 (882.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . /etc/cloud/cloud.cfg.d/50-curtin-networking.cfgにenx000ec6853d1aの設定を追加 . $ cat /etc/cloud/cloud.cfg.d/50-curtin-networking.cfg network: ethernets: enp2s0: addresses: [] dhcp4: true enx000ec6853d1a: addresses: - 10.0.100.1/24 gateway4: 10.0.0.1 dhcp4: false version: 2 $ sudo cloud-init clean -r . ここでシステムが再起動します．その後，以下の様に設定確認します． . $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.100.1 netmask 255.255.255.0 broadcast 10.0.100.255 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 2163 bytes 212391 (212.3 KB) RX errors 0 dropped 1734 overruns 0 frame 0 TX packets 18 bytes 1900 (1.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . 参考 . Ubuntu 16.04.5で有線LANが繋がらない | .",
            "url": "https://lab.ar90n.net/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "relUrl": "/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "date": " • Oct 17, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "DICOMにおける文字コードの取り扱い",
            "content": "はじめに . DICOMを取り扱うライブラリの多くは海外製であるため，日本語の取り扱いが得意で無いことが多いです. そこで，DICOMにおいて日本語を正しく扱うために色々と調べたのでまとめます． . やったこと . DICOMで日本語を表現する方法を調査 | . 文字コードについて復習 . DICOMにおける文字コードの取り扱いについて述べる前に，いわゆる”文字コード”と呼ばれているものは何であるかを簡単に復習します．より正しく”文字コード”について理解するためには，（符号化）文字集合と（文字）符号化方式を区別することが重要です．文字集合とは表現する文字の集合（アルファベット全てやひらがな全てなど）です．符号化方式とは文字集合の要素をコンピュータ上で取り扱うことが可能な形式に変換する方法です．従って，同一の文字集合に対して複数の符号化方式が存在します． . ISO/IEC 2022 とはなんだろう . ISO/IEC 2022とは文字集合を７ビット文字または８ビット文字にて表現する符号化方式です．特徴としてはエスケープシーケンスを利用することで，複数の文字集合を同時に取り扱うことが可能である点が挙げられます．日本語においては，このISO/IEC 2022の機構を利用したISO-2022-JPが広く利用されています．ISO-2022-JPは一般的にJISコードと呼ばれます．これには漢字，ひらがな，カタカナ，ラテン文字，ギリシア文字，キリル文字など多くの文字集合が含まれます．（半角カタカナは含まれません） . 上述した通り，ISO/IEC 2022には7ビット文字を利用したものと8ビット文字を利用したものとが存在します．ここでは８ビット文字を利用した場合のみを考慮します．ISO/IEC 2022の符号表は図形文字の領域（GL，GR）と制御文字の領域（CL，CR)からなります．また，４つの仮想的なバッファ(G0, G1, G2,G3)が存在します．ISO/IEC 2022を利用するには，エスケープシーケンスを用いて任意のバッファへ文字集合をロードし，それを図形文字の領域（GL，GR)に呼び出します．呼び出しには永続的に呼び出すロッキングシフトと１文字のみのシングルシフトが存在します． . DICOMにおけるISO/IEC 2022 . DICOMでは符号方式としてISO/IEC 2022のサブセットを用いています．具体的には . 8ビット文字をサポート | デフォルトの文字集合としてISO646を使用 | ISO646は必ずGL空間に呼び出される | ISO646以外の文字集合を用いる場合はSpecific Character Set(0008,0005)に指定する | エスケープを利用した符号拡張を使う(ISO/IEC 2022)場合はSpecific Character Setに二つ以上の文字集合を指定する | バッファG0はGLに，バッファG1はGRにロードされる | G2，G3は利用不可 | G0，G1は常に呼び出し状態にあるのでロッキングシフトは不要 | . という制約があります． . 実際にDICOMで日本語を扱ってみる . DICOMで日本語を扱うためには，Specific Character Set(0008,0005)に使用する符号方式を設定する必要があります．ここでは，以下の患者名を符号化することを考えます． . ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう . この患者名には，半角かな，漢字，全角ひらがなが含まれています．英数字と半角かなはISO 2022 IR 13で，漢字と全角ひらがなはISO 2022 IR 87で表現が可能です． 従って，Specific Character Set(0008,0005)には以下の値を設定します． . ISO 2022 IR 13 ISO 2022 IR 87 . 前述の通り，ISO/IEC 2022ではエスケープシーケンスを用いて複数の符号方式を切り替えます． 従って，上述の患者名においても適切なタイミングでエスケープする必要があります． エスケープシーケンスを追加した例を以下にしまします． . ﾔﾏﾀﾞ^ﾀﾛｳ= ESC 02/04 04/02 山田 ESC 02/08 04/10 ^ ESC 02/04 04/02 太郎 ESC 02/08 04/10 = ESC 02/04 04/02 やまだ ESC 02/08 04/10 ^ ESC 02/04 04/02 たろう ESC 02/08 04/10 . また，各エスケープシーケンスの詳細を以下に示します． . エスケープシーケンス 処理 . ESC 02/08 04/10 | 英数字(ISO-IR 14)をGLにロード | . ESC 02/04 04/02 | 漢字とひらがな(ISO-IR 87)をGLにロード | . これらを踏まえて，実際にエンコーディングすると以下の値が得られます． . 13/04 12/15 12/00 13/14 05/14 12/00 13/11 11/03 03/13 01/11 02/04 04/02 03/11 03/03 04/05 04/04 01/11 02/08 04/10 05/14 01/11 02/04 04/02 04/02 04/00 04/15 03/10 01/11 02/08 04/10 03/13 01/11 02/04 04/02 02/04 06/04 02/04 05/14 02/04 04/00 01/11 02/08 04/10 05/14 01/11 02/04 04/02 02/04 03/15 02/04 06/13 02/04 02/06 01/11 02/08 04/10 . 参考 . JIS漢字コード | ISO/IEC 2022 | JIS X 0201 | ２０１１ ST講座 入門講座 DICOM規格 初級 –DICOMをうまく使いこなす– | DICOMの日本語エンコーディング処理実装 | DICOM に慣れる － 現場で DICOM 接続に慌てないための知識 （２） 文字系の通信 － | H.3 Example of Person Name Value Representation in the Japanese Language | .",
            "url": "https://lab.ar90n.net/dicom/2020/10/12/character-encodings-in-dicom.html",
            "relUrl": "/dicom/2020/10/12/character-encodings-in-dicom.html",
            "date": " • Oct 12, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "移動平均フィルタの零点と周波数特性",
            "content": "&#12399;&#12376;&#12417;&#12395; . 最も単純なローパスフィルタとして，移動平均フィルタが広く知られています． しかしながら，その詳細な性質を確認する機会はあまり無いのではと思います． そこで，移動平均フィルタの伝達関数，複素平面における零点の分布，周波数特性を示します． そして，ローパスフィルタとしての特性を再確認します． . &#12420;&#12387;&#12383;&#12371;&#12392; . 移動平均フィルタについて複素平面上で零点の分布をプロット | 移動平均フィルタについて周波数特性をプロット | 移動平均フィルタがローパスフィルタであり，直線位相であること確認 | . &#31227;&#21205;&#24179;&#22343;&#12501;&#12451;&#12523;&#12479;&#12395;&#12388;&#12356;&#12390; . 移動平均フィルタとは， $n$ サンプル目の入力を$x_{n}$，出力を$y_{n}$，フィルタ長を$N$とすると以下のように表すことができます． $$y_{n} = frac{1}{N} sum_{m = 0}^{N} x_{n + m}$$ これは，連続する$N$サンプルの平均を出力とすることを意味しています． 今回は，零点と周波数特性の関係を調べたいので，上式にZ変換を行い周波数領域に持っていきます． . $$ begin{aligned} mathcal{Z}(x_{n+m}) &amp; = z^{-m}X(z) mathcal{Z}(y_{n}) &amp; = Y(z) &amp; = H(z)X(z) &amp; = frac{1}{N} left( sum_{m = 0}^{N} z^{-m} right) X(z) end{aligned} $$ &#35079;&#32032;&#24179;&#38754;&#19978;&#12391;&#38646;&#28857;&#12434;&#27714;&#12417;&#12427; . 前述の伝達関数$H(z)$の根を求めることで，零点が複素平面上でどのように分布しているかを知ることができます．ここでは，$H(z)$の求根にはコンパニオン行列の固有値を計算する方法を用います． 求根方法の詳細についていかに述べます． . まず初めに問題を定義します．$H(z)$の根を求めることとは，以下の式を満たす$z$を求めることになります． . $$ begin{aligned} H(z) &amp; = frac{1}{N} sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ここで，両辺を$N$倍して以下の式を得ます $$ begin{aligned} H&#39;(z) &amp; = sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ . この時，$H&#39;(z)$に対するコンパニオン行列$C(H&#39;(Z))$は以下のように求まります． . $$ begin{aligned} C left(H&#39;(z) right) &amp; = begin{pmatrix} 0 &amp; 0 &amp; cdots &amp; 0 &amp; -1 1 &amp; 0 &amp; cdots &amp; 0 &amp; -1 0 &amp; 1 &amp; cdots &amp; 0 &amp; -1 vdots &amp; vdots &amp; ddots &amp; vdots &amp; vdots 0 &amp; 0 &amp; cdots &amp; 1 &amp; -1 end{pmatrix} end{aligned} $$コンパニオン行列$C left(H&#39;(z) right)$には，以下の様な面白い性質があります． . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) end{aligned} $$ここで，左辺は$H&#39;(z)$の固有多項式を表します．従って， . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) &amp;= 0 end{aligned} $$と置くと，$z$は$C left(H&#39;(z) right)$の固有値に等しいことが解ります． . 以下に零点のプロットを示します．この結果より，以下を確認できます． . 零点は単位円上にのみ存在する | $z=-1$以外の零点は全て複素共役になっている | . import numpy as np import altair as alt def companion(n: int): return np.hstack([np.vstack([np.zeros(n-1), np.eye(n-1,n-1)] ), -np.ones(n).reshape(-1,1)]) def zeros(n): return np.linalg.eig(companion(n))[0] def plot_zeros(n): source = alt.Data(values=sum([[{ &#39;Real Part&#39; : pt.real, &#39;Imaginary Part&#39;: pt.imag, &quot;n&quot;: i } for pt in zeros(i)] for i in range(1, n + 1)], [])) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.Chart(source).mark_circle().encode(x=alt.X(&quot;Real Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2])), y=alt.Y(&quot;Imaginary Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2]))).add_selection(select_order).transform_filter(select_order).interactive() plot_zeros(32) . &#21608;&#27874;&#25968;&#29305;&#24615;&#12434;&#27714;&#12417;&#12427; . 同様に周波数特性を求めます．周波数特性は$H(z)$に対して$z rightarrow exp^{-i omega}$と置換して$ left|H(z) right|$，$ angle H(z)$を計算することで得られます． . import math def response(n): freq = np.linspace(0, 1.0, 257, endpoint=True) resp = np.sum(np.vander(np.exp(freq * 2 * np.pi * 1j), n), axis=1) / n return resp, freq def plot_freq_feature(n): source = alt.Data(values = sum([[{ &#39;Normalized frequency&#39;: f, &#39;gain&#39;: 20 * math.log10(abs(r)), &#39;phase&#39;: math.atan2(r.imag, r.real), &#39;n&#39;: i } for r, f in zip(*response(i))] for i in range(1, n+1)], [])) base = alt.Chart(source).encode( alt.X(&#39;Normalized frequency:Q&#39;, axis=alt.Axis(title=None)) ) amp = base.mark_line(stroke=&#39;#57A44C&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;gain:Q&#39;, scale=alt.Scale(domain=[-50, 0], clamp=True), axis=alt.Axis(title=&#39;Gain(dB)&#39;, titleColor=&#39;#57A44C&#39;)), ) phase = base.mark_line(stroke=&#39;#5276A7&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;phase:Q&#39;, scale=alt.Scale(domain=[-math.pi, math.pi]), axis=alt.Axis(title=&#39;Phase(rad)&#39;, titleColor=&#39;#5276A7&#39;)), ) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.layer(amp, phase).resolve_scale( y = &#39;independent&#39; ).add_selection(select_order).transform_filter(select_order).interactive() plot_freq_feature(32) . 上図より以下のことが確認できます． . 低周波を通し，高周波をカットするローパスフィスタになっている | 複素平面上で零点の存在する周波数は利得が小さい（カットされている） | 直線位相となっている | . &#21442;&#32771; . Eigenvalue-Polynomials | .",
            "url": "https://lab.ar90n.net/signalprocessing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "relUrl": "/signalprocessing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "date": " • Oct 10, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "GitHub ActionsでWebサイトを自動更新する",
            "content": "はじめに . GitHubPages + GitHub Actions でコンテンツを自動的に更新するWebサイトをつくってみました．GitHub Trending に登場したリポジトリに付与されていた topics を一覧表示するサイトです．言語ごとの用途がざっくりとした感じでみることができます． . Topics in GitHub Trending - GitHub . 今回，勉強も兼ねてフロントエンドとデータのクローリング処理共に Elm で記述しました． . GitHub Actions によるバッチ処理の定刻実行 . GitHub Actionsによって定刻実行されるバッチ処理はは以下の3つのジョブからなります． . build | crawl | push | . それぞれ，クローリングスクリプトのビルド，データのクローリング，データのリポジトリへのプッシュを行います．設定の詳細はこちらを参考にしてください． . CLIプログラムを Elm で書く . crawlジョブではElmで記述されたCLIプログラムを実行してデータの取得を行います．ElmはWebフロントエンドを記述することに特化している言語です．そのため，CLIプログラムの開発に必要な，コマンドライン引数の処理といった機能がサポートされいません．そこで，今回は以下のパッケージを持ちました． . pdillonkearns/elm-cli-options-parser . こちらのパッケージを用いると，Flagを用いてコマンドライン引数へのアクセスが可能となります．今回のプログラムでは，以下の様にgithubToken と language と dataRange とを引数から受け取っています． . init : Flags -&gt; TrendingApiOptions -&gt; ( Model, Cmd Msg ) init { githubToken } { language, dateRange } = ( { githubToken = githubToken } , attemptApi TrendingApiResponse (fetchTrending githubToken language dateRange) ) . また，GitHub Tredingsの取得は以下のAPIを利用させていただきました． . github-trending-api . クローリング結果の保存 . 今回，GitHub PagesのみでWebサイトをホスティングするため，データベースを使用することはできません．そのため，クローリング結果はJSONに整形されたのちに，直接GitHub Pagesのリポジトリにプッシュされます． . topics . この，JSONをフロントエンドから取得することで動的なコンテンツ更新を実現します． . Elmによるフロントエンド開発 . 特筆すべきことはありません．Elmは本当に書きやすい言語でした． . 所感 . Elmの勉強としてはちょうど良い分量でした．GitHub PagesとGitHub Actionsで結構なことができる印象なので，また何かチャレンジしたいですね． .",
            "url": "https://lab.ar90n.net/elm/web/2020/08/09/automated-update-github-pages.html",
            "relUrl": "/elm/web/2020/08/09/automated-update-github-pages.html",
            "date": " • Aug 9, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "純粋なバイナリヒープ",
            "content": "純粋なヒープを実装する場合，Braun Treeなど色々と適したデータ構造があるらしいですね． でも、あまり詳しくないので今回は馴染みの深いバイナリヒープを実装する方法について調べてみました． . バイナリヒープとは？ . 二分木を用いて実装したヒープです．ヒープとは以下の性質をもつデータ構造です． . 木構造をもつ | 常に子要素の値は親要素の値以上 | . ヒープ自身の詳細についてはこの記事を参考にしてください． . バイナリヒープを純粋に実装する . 一般的にバイナリヒープの実装には配列とそのインデックスを用いることが多いと思います．（上記のウィキペディアにもこの方法が記載されています） しかしがなら，この方法は配列の内容を書き換える必要があるため，純粋ではありません．そこで，今回は以下で提案されている手法を用いました． . A Functional Approach to Standard Binary Heaps . この論文では，純粋なバイナリヒープの挿入，構築，削除の各操作ついてScalaを用いて説明しています． 以降，これらについて簡単に紹介を行います． . ヒープクラス . この論文ではバイナリヒープを表現するためのクラスHeapを以下のように定義しています， . abstract sealed class Heap { def min: Int // ヒープの最小値 def left: Heap //左側の子要素 def right: Heap //右側の子要素 def size: Int //ヒープに含まれる要素数 def height: Int //ヒープの高さ } case class Branch(min: Int, left: Heap, right: Heap, size: Int, height: Int) extends Heap case object Leaf extends Heap { def min: Int = fail(&quot;Leaf.min&quot;) def left: Heap = fail(&quot;Leaf.min&quot;) def right: Heap = fail(&quot;Leaf.right&quot;) def size: Int = 0 def height: Int = 0 } . 上述の通り，Heapクラスのleftとrightを持つ再帰的な構造になっています． また，Heapクラスは抽象クラスであるため，一つ以上の子要素を持つBranchと子要素を持たないLeafとを派生させています． 単純な二分木にはsizeとheightは必須ではありません．しかしながら，今回のようにバイナリヒープを実現するためには非常に重要となってきます． . 挿入 O(log n) . 新たな要素をを挿入する際に気をつけなければいけないことは，要素を挿入したバイナリヒープもまた上述の条件を満たさなければならないということです． そこで，今回の実装では挿入処理を以下の二つの処理に分けて考えます． . 要素をLeafとして最下レベルに追加する． | 1.にて追加した要素を適切な位置まで上へ登らせる（bubbleUp）． | それでは，まずは1.の新たな要素をLeafとして追加する方法について解説します． ノード追加すること自体は言語側でやってくれることなので，基本的には問題になりません． そのため，次にLeafを挿入する場所はどこかを知ることが問題となります． . 二分木に対する操作のパフォーマンスは木の高さに依存するため，可能な限り二分木の高さを抑える必要があります． 従って，新たな要素はleft側から順番に挿入します． バイナリヒープは二分木であるため，ルートから適切にleftまたはrightを選択することで任意の位置に到達することが可能です． そのため，この問題はleftとrightを以下のように4つの場合に分けて考えることで解決することができます． . leftが完全二分木でない場合 -&gt; leftを選択 | leftが完全二分木であるが，rightは完全二分木でない場合 -&gt; rightを選択 | leftもrightも完全二分木であるが，leftの方がrightよりも高い場合 -&gt; rightを選択 | leftもrightも完全二分木であり，高さが等しい場合 -&gt; leftを選択 | これら4つの場合を図に表すと以下のようになります． . . また，Heapが完全二分木であるか否かは以下の条件式で求めることが可能です． . Size==2Height−1Size == 2^{Height} - 1Size==2Height−1 . 次に，2.のbubbleUpの方法について解説します． bubbleUpの処理は単純で，自身の値(min)と子要素の値(min)とを比較し，子要素の値(min)の値の方が小さい場合は要素を入れ替えます． 以上の結果を元に，insertとbubbleUpは以下のように実装することができます． . def bubbleUp(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, Heap(x, lt, rt), r) case (_, Branch(z, lt, rt, _, _)) if (x &gt; z) =&gt; Heap(z, l, Heap(x, lt, rt)) case (_, _) =&gt; Heap(x, l, r) } def insert(x: Int): Heap = if (isEmpty) Heap(x) else if (left.size &lt; math.pow(2, left.height) - 1) bubbleUp(min, left.insert(x), right) else if (right.size &lt; math.pow(2, right.height) - 1) bubbleUp(min, left, right.insert(x)) else if (right.height &lt; left.height) bubbleUp(min, left, right.insert(x)) else bubbleUp(min, left.insert(x), right) . 構築 O(n) . ソートされていない配列からバイナリヒープの構築を試みます． ここでは，構築済みのバイナリヒープをleftとrightに，配列のi番目の要素をminに設定した要素を考えます． しかしながら，配列のi番目の要素が各子要素の値(min)より小さいとは限らないため，全体としてヒープの条件を満たすとは限りません． そこで，ヒープの条件を満たさない場合は，配列のi番目の要素を適切な位置まで降ろす操作(bubbleDown)が必要となります． . bubbleDownはHeapのminの値と各子要素のminの値とを比較し，小さな場合は何もせず， 大きな場合は要素を入れ替えた後に，再帰的にbubbleDownを呼びだします． こうすることで，当該要素を適切な位置まで降ろすことができます． 以上の結果を踏まえ，配列からバイナリヒープを構築する関数heapify及びbubbleUpは以下のように定義できます． . def bubbleDown(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, _, _, _, _), Branch(z, lt, rt, _, _)) if (z &lt; y &amp;&amp; x &gt; z) =&gt; Heap(z, l, bubbleDown(x, lt, rt)) case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, bubbleDown(x, lt, rt), r) case (_, _) =&gt; Heap(x, l, r) } def heapify(a: Array[Int]): Heap = { def loop(i: Int): Heap = if (i &lt; a.length) bubbleDown(a(i), loop(2 * i + 1), loop(2 * i + 2)) else Leaf loop(0) } . heapifyは一見するとを$O(n log n)$に見えますが，漸近的には$O(n)$らしいです． 正直，なぜ$O(n)$に成るのかは理解できていませんが，アルゴリズムイントロダクションに詳細が記載されているとあったので，そのうち調べてみようと思います． . 削除 O(log n) . 要素をの削除も挿入と同様， 以下のように二つのの処理に分けて考えることができます． . 最後に挿入した要素をバイナリヒープのルートへ移動させる | 1.でルートへ移動した要素を適切な位置まで降ろす(bubbleDown) | 最後に挿入した要素は挿入処理と同様に二分木を走査し，当該要素を見つけることで実現します． 要素を適切な位置まで降ろす処理(bubbleDown)は構築の際に用いたものと同一です． 以上の結果より，要素を削除する関数removeは以下のように実装されます． なお，floatLeftは左側の，floatRightは右側の子要素の値と親要素の値を交換する関数です. . def remove: Heap = if (isEmpty) fail(&quot;Empty heap.&quot;) else bubbleRootDown(mergeChildren(left, right)) def bubbleRootDown(h: Heap): Heap = if (h.isEmpty) Leaf else Heap.bubbleDown(h.min, h.left, h.right) def mergeChildren(l: Heap, r: Heap): Heap = if (l.isEmpty &amp;&amp; r.isEmpty) Leaf else if (l.size &lt; math.pow(2, l.height) - 1) floatLeft(l.min, mergeChildren(l.left, l.right), r) else if (r.size &lt; math.pow(2, r.height) - 1) floatRight(r.min, l, mergeChildren(r.left, r.right)) else if (r.height &lt; l.height) floatLeft(l.min, mergeChildren(l.left, l.right), r) else floatRight(r.min, l, mergeChildren(r.left, r.right)) def floatLeft(x: Int, l: Heap, r: Heap): Heap = l match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, Heap(x, lt, rt), r) case _ =&gt; Heap(x, l, r) } def floatRight(x: Int, l: Heap, r: Heap): Heap = r match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, l, Heap(x, lt, rt)) case _ =&gt; Heap(x, l, r) } . F#によるプライオリティキュー . バイナリヒープを使ったプライオリティキューの実装です． . PriorityQueue . 参考文献ではScalaによる実装でしたが，自分が普段使いする言語はF#なので，F#で実装してみました． .",
            "url": "https://lab.ar90n.net/algorithm/2020/06/27/purely-binary-heap.html",
            "relUrl": "/algorithm/2020/06/27/purely-binary-heap.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "三次元空間における行列演算の復習",
            "content": "ぱっと思いつかなかったのでメモ． . 任意の単位ベクトルへの射影行列 . 任意の単位ベクトルを$ vec{n}$とすると，$ vec{n}$への射影行列$P_{p}$は以下の様に表されます． . Pp=n⃗n⃗TP_{p} = vec{n} vec{n}^{T}Pp​=n . n . T . 法線ベクトルに直交する平面への射影行列 . 法線ベクトルへの射影を元のベクトルから引くことで，法線ベクトルと直交する平面への射影が可能となります． そのため，法線ベクトルと直交する平面への射影行列$P_{o}$は以下のように表されます． . Po=I−Pp=I−n⃗n⃗T begin{aligned} P_{o} &amp;= I - P_{p} &amp;= I - vec{n} vec{n}^{T} end{aligned}Po​​=I−Pp​=I−n . n . T​ . 任意の単位ベクトルを回転軸とした回転行列 . 任意の単位ベクトル$ vec{n}$を以下のように定義します． n⃗=(nx,ny,nz) vec{n} = left(n_x, n_y, n_z right)n=(nx​,ny​,nz​) . ここで，Z軸方向の単位ベクトル$ vec{e_{z}}$を$ vec{n}$に変換する行列$P$を考えます．$P$はY軸回転$R_{y}$とZ軸回転$R_{z}$の積で以下のように表現できます． cθ=nxnx2+ny2sθ=nynx2+ny2cϕ=nznx2+ny2+nz2sϕ=nx2+ny2nx2+ny2+nz2Rxz=(cϕ0sϕ010−sϕ0cϕ)Rxy=(cθ−sθ0sθcθ0001)P=Rxy∗Rxz begin{aligned} c_{ theta} &amp;= frac{n_{x}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} s_{ theta} &amp;= frac{n_{y}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} c_{ phi} &amp;= frac{n_{z}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} s_{ phi} &amp;= frac{ sqrt{n_{x}^{2} + n_{y}^{2}}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} R_{xz} &amp;= left( begin{array}{rrr} c_{ phi} &amp; 0 &amp; s_{ phi} 0 &amp; 1 &amp; 0 -s_{ phi}&amp; 0 &amp; c_{ phi} end{array} right) R_{xy} &amp;= left( begin{array}{rrr} c_{ theta} &amp; -s_{ theta} &amp; 0 s_{ theta} &amp; c_{ theta} &amp; 0 0 &amp; 0 &amp; 1 end{array} right) P &amp;= R_{xy} * R_{xz} end{aligned}cθ​sθ​cϕ​sϕ​Rxz​Rxy​P​=nx2​+ny2​​nx​​=nx2​+ny2​​ny​​=nx2​+ny2​+nz2​​nz​​=nx2​+ny2​+nz2​​nx2​+ny2​​​=⎝⎜⎜⎜⎜⎜⎛​cϕ​0−sϕ​​010​sϕ​0cϕ​​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cθ​sθ​0​−sθ​cθ​0​001​⎠⎟⎟⎟⎟⎟⎞​=Rxy​∗Rxz​​ . $P$によって変換されたZ軸を$ vec{e_{z}’}(= vec{n})$とすると，所望の任意の単位ベクトルを回転軸とする回転行列は以下の３つの変換の合成で表すことができます． . $ vec{e_{z}}$を$ vec{e_{z}}’$に変換する$P$ | $ vec{e_{z}}$を回転軸とする回転$R_{a}$ | $ vec{e_{z}}’$を$ vec{e_{z}}$に変換する$P^{T}$ | したがって，最終的な回転行列$R$は以下のように表されます． . Ra=(cos⁡(a)−sin⁡(a)0sin⁡(a)cos⁡(a)0001)R=P∗Ra∗PT=(nx2+(ny2+nz2)cos⁡(a)−nxnycos⁡(a)+nxny−(nz3+(nx2+ny2)nz)sin⁡(a)−nxnzcos⁡(a)+nxnz+nysin⁡(a)−nxnycos⁡(a)+nxny+(nz3+(nx2+ny2)nz)sin⁡(a)ny2+(nx2+nz2)cos⁡(a)−nynzcos⁡(a)+nynz−nxsin⁡(a)−nxnzcos⁡(a)+nxnz−(nx2ny+ny3+nynz2)sin⁡(a)−nynzcos⁡(a)+nynz+(nx3+nxny2+nxnz2)sin⁡(a)nz2+(nx2+ny2)cos⁡(a))=(cos⁡(a)+nx2(1−cos⁡(a))nxny(1−cos⁡(a))−nzsin⁡(a)nxnz(1−cos⁡(a))+nysin⁡(a)nxny(1−cos⁡(a))+nzsin⁡(a)cos⁡(a)+ny2(1−cos⁡(a))nynz(1−cos⁡(a))−nxsin⁡(a)nxnz(1−cos⁡(a))−nysin⁡(a)nynz(1−cos⁡(a))+nxsin⁡(a)cos⁡(a)+nz2(1−cos⁡(a))) begin{aligned} R_{a} &amp;= left( begin{array}{rrr} cos left(a right) &amp; - sin left(a right) &amp; 0 sin left(a right) &amp; cos left(a right) &amp; 0 0 &amp; 0 &amp; 1 end{array} right) R &amp;= P * R_{a} * P^{T} &amp;= left( begin{array}{rrr} mathit{n_{x}}^{2} + { left( mathit{n_{y}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} - { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} + mathit{n_{y}} sin left(a right) - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} + { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; mathit{n_{y}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} - mathit{n_{x}} sin left(a right) - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} - { left( mathit{n_{x}}^{2} mathit{n_{y}} + mathit{n_{y}}^{3} + mathit{n_{y}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} + { left( mathit{n_{x}}^{3} + mathit{n_{x}} mathit{n_{y}}^{2} + mathit{n_{x}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; mathit{n_{z}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} cos left(a right) end{array} right) &amp;= left( begin{array}{rrr} cos left(a right) + mathit{n_{x}}^{2} left(1- cos left(a right) right) &amp; mathit{n_{x}} mathit{n_{y}} left(1 - cos left(a right) right) - mathit{n_{z}} sin left(a right) &amp; mathit{n_{x}} mathit{n_{z}} left( 1 - cos left(a right) right) + mathit{n_{y}} sin left(a right) mathit{n_{x}} mathit{n_{y}} left( 1 - cos left(a right) right) + mathit{n_{z}} sin left(a right) &amp; cos left(a right) + mathit{n_{y}}^{2} left( 1- cos left(a right) right) &amp; mathit{n_{y}} mathit{n_{z}} left( 1- cos left(a right) right) - mathit{n_{x}} sin left(a right) mathit{n_{x}} mathit{n_{z}} left(1- cos left(a right) right) - mathit{n_{y}} sin left(a right) &amp; mathit{n_{y}} mathit{n_{z}} left(1- cos left(a right) right) + mathit{n_{x}} sin left(a right) &amp; cos left(a right) + mathit{n_{z}}^{2} left( 1- cos left(a right) right) end{array} right) end{aligned}Ra​R​=⎝⎜⎜⎜⎜⎜⎛​cos(a)sin(a)0​−sin(a)cos(a)0​001​⎠⎟⎟⎟⎟⎟⎞​=P∗Ra​∗PT=⎝⎜⎜⎜⎜⎜⎛​nx​2+(ny​2+nz​2)cos(a)−nx​ny​cos(a)+nx​ny​+(nz​3+(nx​2+ny​2)nz​)sin(a)−nx​nz​cos(a)+nx​nz​−(nx​2ny​+ny​3+ny​nz​2)sin(a)​−nx​ny​cos(a)+nx​ny​−(nz​3+(nx​2+ny​2)nz​)sin(a)ny​2+(nx​2+nz​2)cos(a)−ny​nz​cos(a)+ny​nz​+(nx​3+nx​ny​2+nx​nz​2)sin(a)​−nx​nz​cos(a)+nx​nz​+ny​sin(a)−ny​nz​cos(a)+ny​nz​−nx​sin(a)nz​2+(nx​2+ny​2)cos(a)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cos(a)+nx​2(1−cos(a))nx​ny​(1−cos(a))+nz​sin(a)nx​nz​(1−cos(a))−ny​sin(a)​nx​ny​(1−cos(a))−nz​sin(a)cos(a)+ny​2(1−cos(a))ny​nz​(1−cos(a))+nx​sin(a)​nx​nz​(1−cos(a))+ny​sin(a)ny​nz​(1−cos(a))−nx​sin(a)cos(a)+nz​2(1−cos(a))​⎠⎟⎟⎟⎟⎟⎞​​ .",
            "url": "https://lab.ar90n.net/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "relUrl": "/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "5行で書くポアソンブレンディング",
            "content": "はじめに . 画像の滑らかな合成アルゴリズムにポアソンブレンディング(Poisson Image Editting)があります．これは，ポアソン方程式を解くことで元の勾配を保ちながら，境界部分が連続となる合成画像を推定するというものです． ネットを調べると，ポアソン方程式の計算にはSOR法やマルチグリッド法などを実装した高速な連立方程式ソルバを利用することが多いようです．しかしながら，外部のソルバを利用するとプロジェクトの規模が大きくなってしまいます．また，外部のソルバを利用せず，上述のアルゴリズムを自前で実装することは非常に困難な作業です．そこで，ヤコビ法をラプラシアンフィルタで記述し実装を簡略化しました． . やったこと . ラプラシアンフィルタを使用してヤコビ法を記述 | ポアソンブレンディングを５行で実装 | プロジェクトをGithubに作成 | . ポアソン方程式をラプラシアンフィルタで記述する . 参考記事によると，座標$p$における画素値$f_p$は以下の式で求められます． . fp=∑q∈Nfq+4gq−∑q∈Ngq4f_p = frac{ sum_{q in N} f_q + 4 g_{q} - sum_{q in N} g_q}{4}fp​=4∑q∈N​fq​+4gq​−∑q∈N​gq​​ . ここで，ヤコビ法によって$f_p$を求めます．$k$回目のイテレーションにおける座標$p$における画素値を$f_{p}^{k}$とします．すると，$f_{p}^{k}$は以下のように表記することができます． . fpk+1=∑q∈Nfqk+4gp−∑q∈Ngq4=4fpk−4fpk+∑q∈Nfqk+4gp−∑q∈Ngq4=fpk+−4(fpk−gp)+∑q∈Nfqk−gq4=fpk+14Δp(f−g) begin{aligned} f_{p}^{k+1} &amp;= frac{ sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_{q}}{4} &amp;= frac{4f_{p}^{k} -4 f_{p}^{k} + sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_q}{4} &amp;= f_{p}^{k} + frac{-4 (f_{p}^{k} - g_{p}) + sum_{q in N} f_{q}^{k} - g_q}{4} &amp;= f_{p}^{k} + frac{1}{4} Delta_{p} left(f - g right) end{aligned}fpk+1​​=4∑q∈N​fqk​+4gp​−∑q∈N​gq​​=44fpk​−4fpk​+∑q∈N​fqk​+4gp​−∑q∈N​gq​​=fpk​+4−4(fpk​−gp​)+∑q∈N​fqk​−gq​​=fpk​+41​Δp​(f−g)​ . 以上の結果より，注目領域に$ frac{1}{4} Delta_{p} left(f - g right)$を加算していくことで合成を行います． $ Delta_{p}$は座標$p$におけるラプラシアンを表します．以下にscipyを用いで実装したコードを示します．関数の引数はそれぞれ，target_imgが合成先画像，src_imgが合成元画像, mask_imgが合成領域マスク, iterが反復処理の回数をそれぞれ表します．コードサイズを5行に抑えるため，省いた処理（入力のバリデーション，反復処理の打ち切り）や冗長な処理（target_imgとsrc_imgとの差分を毎ループ計算している）がありますが，アルゴリズムのエッセンスは十分表現できていると思います． . 5行で実装 . from scipy.ndimage import laplace def poisson_blend(target_img, src_img, mask_img, iter: int = 1024): for _ in range(iter): target_img = target_img + 0.25 * mask_img * laplace(target_img - src_img) return target_img.clip(0, 1) . poisson_blendの入力と出力との関係を以下の図に示します．以下の図は，左側から合成元画像(src_img)，合成領域マスク(mask_img)，合成先画像(target_img)，合成画像を表します．境界領域が滑らかに合成されていることが確認できます． . . 上記の関数に加え，結果確認用のノートブックなどを追加したリポジトリを作成しました．よろしければ，こちらも参考にしてください. . 参考 . Poisson Image Editing | ar90n/poisson-blending-in-5lines | .",
            "url": "https://lab.ar90n.net/imageprocessing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "relUrl": "/imageprocessing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
            "content": "はじめに . Raspberry Pi 4+k3s+rayでクラスタを作成して，分散処理の実験を行います．Raspberry Pi 4 には事前にUbuntu 20.04を導入しておきます． . cgroupの有効化 . 残念ながら，このcgroupの設定が何故必要なのかを理解できていません．しかしながら，Webで調べた限りでは，必要そうなので設定することにします．（設定しない場合はどうなるかを試してはいません） . SDカードをホストマシンにマウントして以下のコマンド実行します．以下の例では，/Vlumes/system-bootにSDカードがマウントされています．マウントポイントについては，環境に応じて適切に書き換えてください． . $ sed -i -e &#39;s/$/ cgroup_memory=1 cgroup_enable=memory cgroup_enable=cpuset/&#39; /Volumes/system-boot/cmdline.txt . 修正したSDカードを用いてシステムを起動します．その後，以下のコマンドで設定の反映を確認できます． . $ cat /proc/cgroups #subsys_name hierarchy num_cgroups enabled cpuset 5 10 1 cpu 4 98 1 cpuacct 4 98 1 blkio 8 98 1 memory 2 147 1 devices 11 98 1 freezer 9 11 1 net_cls 6 10 1 perf_event 7 10 1 net_prio 6 10 1 pids 10 106 1 rdma 3 1 1 . k3sの導入 . リポジトリの手順に従います．注意が必要な点は，マスターノードとワーカーノードとで導入方法が異なる点です．ここでハマらなければ，さくっと導入できると思います．今回，以下の様にマスターノードx1，ワーカーノードx3でk3sクラスタを構成しました． . $ kubectl get nodes NAME STATUS ROLES AGE VERSION k3s-node3 Ready worker 3d12h v1.18.2+k3s1 k3s-node2 Ready worker 3d12h v1.18.2+k3s1 k3s-node1 Ready worker 3d12h v1.18.2+k3s1 k3s-master Ready master 3d18h v1.18.2+k3s1 . rayクラスタのデプロイ . こちらも公式の手順に従います．しかしながら，こちらで使用しているDockerイメージはamd64向けに作成された物であり，aarch64環境では動作しません．そこで，ほぼ等価なイメージをaarch64向けに作成しました．今回は，このイメージを用いてクラスタを作成します．具体的には，ray-cluster.yamlを以下の様に修正します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..0563c934f 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,7 +59,7 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: @@ -120,7 +120,7 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: . 以下のようにコンテナをデプロイします． . $ kubectl create -f ray/doc/kubernetes/ray-namespace.yaml namespace/ray created $ kubectl apply -f ray/doc/kubernetes/ray-cluster.yaml service/ray-head created deployment.apps/ray-head created deployment.apps/ray-worker created $ kubectl -n ray get pods NAME READY STATUS RESTARTS AGE ray-head-7957ff48b6-tj6z2 1/1 Running 0 118s ray-worker-7574c9d77-bs4dx 1/1 Running 0 118s ray-worker-7574c9d77-2868n 1/1 Running 1 118s ray-worker-7574c9d77-x48m7 1/1 Running 0 118s . クラスタの作成が完了したので，テストプログラムを実行します．こちらも公式の手順に従い，example.pyを実行します． . $ kubectl -n ray cp ray/doc/kubernetes/example.py ray-head-7957ff48b6-tj6z2:/example.py $ kubectl -n ray exec ray-head-7957ff48b6-tj6z2 -- python example.py 2020-05-24 14:13:54,824 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. Iteration 0 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 1 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 2 Counter({(&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 2}) Iteration 3 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 13, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3}) Iteration 4 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2}) Iteration 5 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 6 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 7 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3}) Iteration 8 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 9 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3}) Success! . ベンチマーク . 最後に，作成したクラスタのベンチマークとして，マンデルブロ集合の描画時間を計測します．マンデルブロ集合の描画には以下のコードを用います．画像全体をn_x_grids x n_y_grids個の領域に区切り，各領域毎に並行処理します． . #!/usr/bin/env python import numpy as np from numba import njit import itertools import os import ray import matplotlib.pyplot as plt from timeit import timeit if (os.environ.get(&quot;RAY_HEAD_SERVICE_HOST&quot;) is None): ray.init() else: redis_host = os.environ[&quot;RAY_HEAD_SERVICE_HOST&quot;] ray.init(address=redis_host + &quot;:6379&quot;) n_x_grids = int(os.environ.get(&quot;X_GRIDS&quot;, 32)) n_y_grids = int(os.environ.get(&quot;Y_GRIDS&quot;, 32)) grid_width = int(os.environ.get(&quot;GRID_WIDTH&quot;, 100)) grid_height = int(os.environ.get(&quot;GRID_HEIGHT&quot;, 100)) def grid_range(begin, end, n_grids): ih, it = itertools.tee(np.linspace(begin, end, n_grids + 1)) next(it) return ((h,t) for h,t in zip(ih, it)) @ray.remote def mandelbrot(c, n = 32, th = 200): z = 1j * np.zeros(c.shape) r = np.zeros(c.shape) for i in range(n): mask = np.abs(z) &lt;= th z += (z * z + c - z) * mask.astype(np.int) r[mask] = i # make smooth return r - np.log2(np.log2(np.abs(z) + 1)) def rendering(n_xg, n_yg, gw, gh): res = [] xs = grid_range(-2, 1, n_xg) ys = grid_range(-1, 1, n_yg) for ((xb, xe), (yb, ye)) in itertools.product(xs, ys): x, y = np.meshgrid(np.linspace(xb, xe, gw), np.linspace(yb, ye, gh)) c = x + 1j * y res.append(mandelbrot.remote(c)) res = ray.get(res) return np.concatenate(np.concatenate(np.array(res).reshape(n_yg, n_xg, gh, gw), axis=2),axis=0) benchmark = timeit(lambda: rendering(n_x_grids, n_y_grids, grid_width, grid_height), number=8) / 8 print(f&quot;time: {benchmark}&quot;) img = rendering(n_x_grids, n_y_grids, grid_width, grid_height) plt.figure(dpi=200) plt.imshow(img, cmap=&#39;rainbow&#39;, interpolation=&#39;bilinear&#39;, extent=[-2, 1, -1, 1]) plt.xticks(color=&#39;None&#39;) plt.yticks(color=&#39;None&#39;) plt.tick_params(length=0) plt.savefig(&#39;figure.png&#39;) . また，クラスタの設定も少しだけ修正します．各コンテナに割り当てるメモリの変更と，必要なパッケージをコンテナ起動時に追加します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..d2b2c9678 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,11 +59,11 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: - - &quot;ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 6379 # Redis port. - containerPort: 6380 # Redis port. @@ -120,11 +120,11 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: - - &quot;ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 12345 # Ray internal communication. - containerPort: 12346 # Ray internal communication. @@ -147,4 +147,4 @@ spec: resources: requests: cpu: 100m - memory: 512Mi + memory: 1024Mi . 実行結果を以下に示します．無事に動作している様です． . $ kubectl -n ray exec ray-head-6785995666-m49kv -- python main.py 2020-05-24 14:57:57,849 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. (pid=2799) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2799) return r - np.log2(np.log2(np.abs(z) + 1)) (pid=2780, ip=10.42.1.13) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2780, ip=10.42.4.25) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2783, ip=10.42.0.35) main.py:36: RuntimeWarning: divide by zero encountered in log2 time: 34.654623864378664 . . Rayのワーカーノードの数を変更すると以下の様に処理時間が変化しました． . ワーカーノード数 処理時間[s] . 0 | 45.09195340787119 | . 1 | 48.55051823974645 | . 2 | 38.57156975386897 | . 3 | 34.654623864378664 | . あまり安定のしない微妙な結果となりました．思った以上に並列化される部分意外にボトルネックがあったのかもしれません． . 参考 . Raspberry pi 4におけるK3Sクラスタ構築 | Ray | k3s | .",
            "url": "https://lab.ar90n.net/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "relUrl": "/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "date": " • May 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "都内でソフトウェアエンジニアをやっています． . 画像処理，Python，Web開発など広くポストしてます． . Name . 和田政弘 . GitHub . @ar90n . Twitter . @ar90n . Mail . argon.argon.argon@gmail.com . Skill . 画像処理 | 医療画像処理 | Python | C++ | Web | 組み込み | .",
          "url": "https://lab.ar90n.net/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lab.ar90n.net/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}