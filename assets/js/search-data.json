{
  
    
        "post0": {
            "title": "移動平均フィルタの零点と周波数特性",
            "content": "&#12399;&#12376;&#12417;&#12395; . 最も単純なローパスフィルタとして，移動平均フィルタが広く知られています． しかしながら，その詳細な性質を確認する機会はあまり無いのではと思います． そこで，移動平均フィルタの伝達関数，複素平面における零点の分布，周波数特性を示します． そして，ローパスフィルタとしての特性を再確認します． . &#12420;&#12387;&#12383;&#12371;&#12392; . 移動平均フィルタについて複素平面上で零点の分布をプロット | 移動平均フィルタについて周波数特性をプロット | 移動平均フィルタがローパスフィルタであり，直線位相であること確認 | . &#31227;&#21205;&#24179;&#22343;&#12501;&#12451;&#12523;&#12479;&#12395;&#12388;&#12356;&#12390; . 移動平均フィルタとは， $n$ サンプル目の入力を$x_{n}$，出力を$y_{n}$，フィルタ長を$N$とすると以下のように表すことができます． $$y_{n} = frac{1}{N} sum_{m = 0}^{N} x_{n + m}$$ これは，連続する$N$サンプルの平均を出力とすることを意味しています． 今回は，零点と周波数特性の関係を調べたいので，上式にZ変換を行い周波数領域に持っていきます． . $$ begin{aligned} mathcal{Z}(x_{n+m}) &amp; = z^{-m}X(z) mathcal{Z}(y_{n}) &amp; = Y(z) &amp; = H(z)X(z) &amp; = frac{1}{N} left( sum_{m = 0}^{N} z^{-m} right) X(z) end{aligned} $$ &#35079;&#32032;&#24179;&#38754;&#19978;&#12391;&#38646;&#28857;&#12434;&#27714;&#12417;&#12427; . 前述の伝達関数$H(z)$の根を求めることで，零点が複素平面上でどのように分布しているかを知ることができます．ここでは，$H(z)$の求根にはコンパニオン行列の固有値を計算する方法を用います． 求根方法の詳細についていかに述べます． . まず初めに問題を定義します．$H(z)$の根を求めることとは，以下の式を満たす$z$を求めることになります． . $$ begin{aligned} H(z) &amp; = frac{1}{N} sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ここで，両辺を$N$倍して以下の式を得ます $$ begin{aligned} H&#39;(z) &amp; = sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ . この時，$H&#39;(z)$に対するコンパニオン行列$C(H&#39;(Z))$は以下のように求まります． . $$ begin{aligned} C left(H&#39;(z) right) &amp; = begin{pmatrix} 0 &amp; 0 &amp; cdots &amp; 0 &amp; -1 1 &amp; 0 &amp; cdots &amp; 0 &amp; -1 0 &amp; 1 &amp; cdots &amp; 0 &amp; -1 vdots &amp; vdots &amp; ddots &amp; vdots &amp; vdots 0 &amp; 0 &amp; cdots &amp; 1 &amp; -1 end{pmatrix} end{aligned} $$コンパニオン行列$C left(H&#39;(z) right)$には，以下の様な面白い性質があります． . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) end{aligned} $$ここで，左辺は$H&#39;(z)$の固有多項式を表します．従って， . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) &amp;= 0 end{aligned} $$と置くと，$z$は$C left(H&#39;(z) right)$の固有値に等しいことが解ります． . 以下に零点のプロットを示します．この結果より，以下を確認できます． . 零点は単位円上にのみ存在する | $z=-1$以外の零点は全て複素共役になっている | . import numpy as np import altair as alt def companion(n: int): return np.hstack([np.vstack([np.zeros(n-1), np.eye(n-1,n-1)] ), -np.ones(n).reshape(-1,1)]) def zeros(n): return np.linalg.eig(companion(n))[0] def plot_zeros(n): source = alt.Data(values=sum([[{ &#39;Real Part&#39; : pt.real, &#39;Imaginary Part&#39;: pt.imag, &quot;n&quot;: i } for pt in zeros(i)] for i in range(1, n + 1)], [])) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.Chart(source).mark_circle().encode(x=alt.X(&quot;Real Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2])), y=alt.Y(&quot;Imaginary Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2]))).add_selection(select_order).transform_filter(select_order).interactive() plot_zeros(32) . &#21608;&#27874;&#25968;&#29305;&#24615;&#12434;&#27714;&#12417;&#12427; . 同様に周波数特性を求めます．周波数特性は$H(z)$に対して$z rightarrow exp^{-i omega}$と置換して$ left|H(z) right|$，$ angle H(z)$を計算することで得られます． . import math def response(n): freq = np.linspace(0, 1.0, 257, endpoint=True) resp = np.sum(np.vander(np.exp(freq * 2 * np.pi * 1j), n), axis=1) / n return resp, freq def plot_freq_feature(n): source = alt.Data(values = sum([[{ &#39;Normalized frequency&#39;: f, &#39;gain&#39;: 20 * math.log10(abs(r)), &#39;phase&#39;: math.atan2(r.imag, r.real), &#39;n&#39;: i } for r, f in zip(*response(i))] for i in range(1, n+1)], [])) base = alt.Chart(source).encode( alt.X(&#39;Normalized frequency:Q&#39;, axis=alt.Axis(title=None)) ) amp = base.mark_line(stroke=&#39;#57A44C&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;gain:Q&#39;, scale=alt.Scale(domain=[-50, 0], clamp=True), axis=alt.Axis(title=&#39;Gain(dB)&#39;, titleColor=&#39;#57A44C&#39;)), ) phase = base.mark_line(stroke=&#39;#5276A7&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;phase:Q&#39;, scale=alt.Scale(domain=[-math.pi, math.pi]), axis=alt.Axis(title=&#39;Phase(rad)&#39;, titleColor=&#39;#5276A7&#39;)), ) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.layer(amp, phase).resolve_scale( y = &#39;independent&#39; ).add_selection(select_order).transform_filter(select_order).interactive() plot_freq_feature(32) . 上図より以下のことが確認できます． . 低周波を通し，高周波をカットするローパスフィスタになっている | 複素平面上で零点の存在する周波数は利得が小さい（カットされている） | 直線位相となっている | . &#21442;&#32771; . Eigenvalue-Polynomials | .",
            "url": "https://lab.ar90n.net/signal%20processing/jupyter/2020/10/21/analysis-of-moving-average-filter.html",
            "relUrl": "/signal%20processing/jupyter/2020/10/21/analysis-of-moving-average-filter.html",
            "date": " • Oct 21, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "smart_openによる統一的なファイルアクセス",
            "content": "&#12399;&#12376;&#12417;&#12395; . ファイルの格納先(ファイルシステム，S3，GCS等)毎にIO処理を記述すると，プログラムが複雑になりがちです．ここでは，それらを統一的に取り扱うことができるsmart_openについて述べます． . &#12420;&#12387;&#12383;&#12371;&#12392; . smart_openの導入 | smart_openによるファイルシステム，クラウドストレージ，Webからのファイル読み込み | . smart_open&#12395;&#12388;&#12356;&#12390; . smart_openはビルトインのopenを置き換えることで，様々なプロトコルを用いてファイルをオープンすることを可能にします．現状のプロトコルに対応している様です． . S3 | GCS | Blob Storage | HDFS | ファイルシステム | SSH | SCP | SFTP | HTTP | . また，以下形式で圧縮されたファイルを透過的に扱うことができます． . gzip | bzip2 | . ここでは，ファイルシステム，S3，GCS，HTTPによるファイルアクセスを評価します． . 従って，以下のようにクラウドストレージをサポートするsmart_openを導入します． . $ pip install smart_open[all] . 他の導入方法については，リポジトリのREADMEを参考にしてください． . &#12463;&#12521;&#12454;&#12489;&#12473;&#12488;&#12524;&#12540;&#12472;&#65292;Web&#12363;&#12425;&#12501;&#12449;&#12452;&#12523;&#12434;&#35501;&#12415;&#36796;&#12416; . 通常，クラウドストレージ上のファイルにアクセスするには専用のSDKを使用することが多いと思います． また，HTTPプロトコルでアクセスするには，urllibやrequests等を使用することが多いと思います． そのため，リソースに応じてこれらのライブラリを適切に取り扱う必要があります． . smart_openはこれらのライブラリを適切にラップします．従って，これらのファイルをファイルシステム上にあるかの様に取り扱うことが可能となります． . ここでは，TIFFファイルをGCS, S3, HTTP, ファイルシステム経由で読み込み表示するサンプルを示します．なお，事前に適切な認証情報を設定しておく必要があります． . from smart_open import open import matplotlib.pyplot as plt from PIL import Image sources = { &quot;S3&quot;: &quot;s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;HTTP&quot;: &quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;, &quot;FILESYSTEM&quot;: &quot;/tmp/LC80030172015001LGN00_BQA.TIF&quot; } for protocol, url in sources.items(): with open(url, &quot;rb&quot;) as fp: img = Image.open(fp) plt.figure() plt.title(f&quot;from {protocol}&quot;) plt.imshow(img, cmap=&#39;gray&#39;) . pathlib.Path&#32076;&#30001;&#12391;smart_open&#12434;&#20351;&#12358;&#12371;&#12392;&#12399;&#12391;&#12365;&#12427;&#12424;&#12358;&#12391;&#12377;&#12364; . いかなるリソースもopenで同様に取り扱うことができる事はとても便利です．しかしながら，strでリソースを指定するのは少し大変です．なので，pathlib.Pathでリソースを指定できると便利です． . smart_openはpathlib.Path.openをフックすることできるようです．しかしながら，pathlib.Pathがファイルパスしか扱えない(//が/に置換されてしまう)ので，すこし微妙かもしれません．． . from pathlib import Path Path(&quot;https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&quot;) . PosixPath(&#39;https:/s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF&#39;) . &#21442;&#32771; . smart_open | .",
            "url": "https://lab.ar90n.net/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "relUrl": "/cloud/python/aws/gcp/2020/10/21/accessing-file-with-unified-pythonic-api.html",
            "date": " • Oct 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
            "content": "はじめに . このUSB-NICをUbuntu 20.04から使用するために行った作業記録です． . やったこと . ネットワークデバイスを有効 | netplanで静的IPアドレスを設定 | . 現状の確認 . USBポートに差し込んだのみでは，ネットワークデバイスとして使用可能な状態にはなりませんでした． まずは，USBデバイスとして適切に認識されていることを確認します． . $ lsusb Bus 002 Device 002: ID 0b95:1790 ASIX Electronics Corp. AX88179 Gigabit Ethernet Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 8087:0a2a Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub . ASIX Electronics Corp. AX88179 Gigabit Ethernet このデバイスが対象のUSB-NICであるようです． . ネットワークデバイスとして認識する . 参考サイトの方法に従ってネットワークデバイスとして認識させます． . $ sudo lshw -c Network ... *-network:0 DISABLED description: Ethernet interface physical id: 1 bus info: usb@2:4 logical name: enx000ec6853d1a serial: 00:0e:c6:85:3d:1a size: 10Mbit/s capacity: 1Gbit/s capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation configuration: autonegotiation=off broadcast=yes driver=ax88179_178a duplex=half link=no multicast=yes port=MII speed=10Mbit/s ... $ sudo ifconfig enx000ec6853d1a up $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 39 bytes 3635 (3.6 KB) RX errors 0 dropped 32 overruns 0 frame 0 TX packets 7 bytes 882 (882.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . /etc/cloud/cloud.cfg.d/50-curtin-networking.cfgにenx000ec6853d1aの設定を追加 . $ cat /etc/cloud/cloud.cfg.d/50-curtin-networking.cfg network: ethernets: enp2s0: addresses: [] dhcp4: true enx000ec6853d1a: addresses: - 10.0.100.1/24 gateway4: 10.0.0.1 dhcp4: false version: 2 $ sudo cloud-init clean -r . ここでシステムが再起動します．その後，以下の様に設定確認します． . $ ifconfig ... enx000ec6853d1a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.100.1 netmask 255.255.255.0 broadcast 10.0.100.255 inet6 fe80::20e:c6ff:fe85:3d1a prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0e:c6:85:3d:1a txqueuelen 1000 (イーサネット) RX packets 2163 bytes 212391 (212.3 KB) RX errors 0 dropped 1734 overruns 0 frame 0 TX packets 18 bytes 1900 (1.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... . 参考 . Ubuntu 16.04.5で有線LANが繋がらない | .",
            "url": "https://lab.ar90n.net/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "relUrl": "/ubuntu/2020/10/17/usb-nic-in-ubuntu-server.html",
            "date": " • Oct 17, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "DICOMにおける文字コードの取り扱い",
            "content": "はじめに . DICOMを取り扱うライブラリの多くは海外製であるため，日本語の取り扱いが得意で無いことが多いです. そこで，DICOMにおいて日本語を正しく扱うために色々と調べたのでまとめます． . やったこと . DICOMで日本語を表現する方法を調査 | . 文字コードについて復習 . DICOMにおける文字コードの取り扱いについて述べる前に，いわゆる”文字コード”と呼ばれているものは何であるかを簡単に復習します．より正しく”文字コード”について理解するためには，（符号化）文字集合と（文字）符号化方式を区別することが重要です．文字集合とは表現する文字の集合（アルファベット全てやひらがな全てなど）です．符号化方式とは文字集合の要素をコンピュータ上で取り扱うことが可能な形式に変換する方法です．従って，同一の文字集合に対して複数の符号化方式が存在します． . ISO/IEC 2022 とはなんだろう . ISO/IEC 2022とは文字集合を７ビット文字または８ビット文字にて表現する符号化方式です．特徴としてはエスケープシーケンスを利用することで，複数の文字集合を同時に取り扱うことが可能である点が挙げられます．日本語においては，このISO/IEC 2022の機構を利用したISO-2022-JPが広く利用されています．ISO-2022-JPは一般的にJISコードと呼ばれます．これには漢字，ひらがな，カタカナ，ラテン文字，ギリシア文字，キリル文字など多くの文字集合が含まれます．（半角カタカナは含まれません） . 上述した通り，ISO/IEC 2022には7ビット文字を利用したものと8ビット文字を利用したものとが存在します．ここでは８ビット文字を利用した場合のみを考慮します．ISO/IEC 2022の符号表は図形文字の領域（GL，GR）と制御文字の領域（CL，CR)からなります．また，４つの仮想的なバッファ(G0, G1, G2,G3)が存在します．ISO/IEC 2022を利用するには，エスケープシーケンスを用いて任意のバッファへ文字集合をロードし，それを図形文字の領域（GL，GR)に呼び出します．呼び出しには永続的に呼び出すロッキングシフトと１文字のみのシングルシフトが存在します． . DICOMにおけるISO/IEC 2022 . DICOMでは符号方式としてISO/IEC 2022のサブセットを用いています．具体的には . 8ビット文字をサポート | デフォルトの文字集合としてISO646を使用 | ISO646は必ずGL空間に呼び出される | ISO646以外の文字集合を用いる場合はSpecific Character Set(0008,0005)に指定する | エスケープを利用した符号拡張を使う(ISO/IEC 2022)場合はSpecific Character Setに二つ以上の文字集合を指定する | バッファG0はGLに，バッファG1はGRにロードされる | G2，G3は利用不可 | G0，G1は常に呼び出し状態にあるのでロッキングシフトは不要 | . という制約があります． . 実際にDICOMで日本語を扱ってみる . DICOMで日本語を扱うためには，Specific Character Set(0008,0005)に使用する符号方式を設定する必要があります．ここでは，以下の患者名を符号化することを考えます． . ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう . この患者名には，半角かな，漢字，全角ひらがなが含まれています．英数字と半角かなはISO 2022 IR 13で，漢字と全角ひらがなはISO 2022 IR 87で表現が可能です． 従って，Specific Character Set(0008,0005)には以下の値を設定します． . ISO 2022 IR 13 ISO 2022 IR 87 . 前述の通り，ISO/IEC 2022ではエスケープシーケンスを用いて複数の符号方式を切り替えます． 従って，上述の患者名においても適切なタイミングでエスケープする必要があります． エスケープシーケンスを追加した例を以下にしまします． . ﾔﾏﾀﾞ^ﾀﾛｳ= ESC 02/04 04/02 山田 ESC 02/08 04/10 ^ ESC 02/04 04/02 太郎 ESC 02/08 04/10 = ESC 02/04 04/02 やまだ ESC 02/08 04/10 ^ ESC 02/04 04/02 たろう ESC 02/08 04/10 . また，各エスケープシーケンスの詳細を以下に示します． . エスケープシーケンス 処理 . ESC 02/08 04/10 | 英数字(ISO-IR 14)をGLにロード | . ESC 02/04 04/02 | 漢字とひらがな(ISO-IR 87)をGLにロード | . これらを踏まえて，実際にエンコーディングすると以下の値が得られます． . 13/04 12/15 12/00 13/14 05/14 12/00 13/11 11/03 03/13 01/11 02/04 04/02 03/11 03/03 04/05 04/04 01/11 02/08 04/10 05/14 01/11 02/04 04/02 04/02 04/00 04/15 03/10 01/11 02/08 04/10 03/13 01/11 02/04 04/02 02/04 06/04 02/04 05/14 02/04 04/00 01/11 02/08 04/10 05/14 01/11 02/04 04/02 02/04 03/15 02/04 06/13 02/04 02/06 01/11 02/08 04/10 . 参考 . JIS漢字コード | ISO/IEC 2022 | JIS X 0201 | ２０１１ ST講座 入門講座 DICOM規格 初級 –DICOMをうまく使いこなす– | DICOMの日本語エンコーディング処理実装 | DICOM に慣れる － 現場で DICOM 接続に慌てないための知識 （２） 文字系の通信 － | H.3 Example of Person Name Value Representation in the Japanese Language | .",
            "url": "https://lab.ar90n.net/dicom/2020/10/12/character-encodings-in-dicom.html",
            "relUrl": "/dicom/2020/10/12/character-encodings-in-dicom.html",
            "date": " • Oct 12, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "移動平均フィルタの零点と周波数特性",
            "content": "&#12399;&#12376;&#12417;&#12395; . 最も単純なローパスフィルタとして，移動平均フィルタが広く知られています． しかしながら，その詳細な性質を確認する機会はあまり無いのではと思います． そこで，移動平均フィルタの伝達関数，複素平面における零点の分布，周波数特性を示します． そして，ローパスフィルタとしての特性を再確認します． . &#12420;&#12387;&#12383;&#12371;&#12392; . 移動平均フィルタについて複素平面上で零点の分布をプロット | 移動平均フィルタについて周波数特性をプロット | 移動平均フィルタがローパスフィルタであり，直線位相であること確認 | . &#31227;&#21205;&#24179;&#22343;&#12501;&#12451;&#12523;&#12479;&#12395;&#12388;&#12356;&#12390; . 移動平均フィルタとは， $n$ サンプル目の入力を$x_{n}$，出力を$y_{n}$，フィルタ長を$N$とすると以下のように表すことができます． $$y_{n} = frac{1}{N} sum_{m = 0}^{N} x_{n + m}$$ これは，連続する$N$サンプルの平均を出力とすることを意味しています． 今回は，零点と周波数特性の関係を調べたいので，上式にZ変換を行い周波数領域に持っていきます． . $$ begin{aligned} mathcal{Z}(x_{n+m}) &amp; = z^{-m}X(z) mathcal{Z}(y_{n}) &amp; = Y(z) &amp; = H(z)X(z) &amp; = frac{1}{N} left( sum_{m = 0}^{N} z^{-m} right) X(z) end{aligned} $$ &#35079;&#32032;&#24179;&#38754;&#19978;&#12391;&#38646;&#28857;&#12434;&#27714;&#12417;&#12427; . 前述の伝達関数$H(z)$の根を求めることで，零点が複素平面上でどのように分布しているかを知ることができます．ここでは，$H(z)$の求根にはコンパニオン行列の固有値を計算する方法を用います． 求根方法の詳細についていかに述べます． . まず初めに問題を定義します．$H(z)$の根を求めることとは，以下の式を満たす$z$を求めることになります． . $$ begin{aligned} H(z) &amp; = frac{1}{N} sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ここで，両辺を$N$倍して以下の式を得ます $$ begin{aligned} H&#39;(z) &amp; = sum_{m = 0}^{N} z^{-m} &amp;= 0 end{aligned} $$ . この時，$H&#39;(z)$に対するコンパニオン行列$C(H&#39;(Z))$は以下のように求まります． . $$ begin{aligned} C left(H&#39;(z) right) &amp; = begin{pmatrix} 0 &amp; 0 &amp; cdots &amp; 0 &amp; -1 1 &amp; 0 &amp; cdots &amp; 0 &amp; -1 0 &amp; 1 &amp; cdots &amp; 0 &amp; -1 vdots &amp; vdots &amp; ddots &amp; vdots &amp; vdots 0 &amp; 0 &amp; cdots &amp; 1 &amp; -1 end{pmatrix} end{aligned} $$コンパニオン行列$C left(H&#39;(z) right)$には，以下の様な面白い性質があります． . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) end{aligned} $$ここで，左辺は$H&#39;(z)$の固有多項式を表します．従って， . $$ begin{aligned} left| zI = C left(H&#39;(z) right) right| &amp;= H&#39;(z) &amp;= 0 end{aligned} $$と置くと，$z$は$C left(H&#39;(z) right)$の固有値に等しいことが解ります． . 以下に零点のプロットを示します．この結果より，以下を確認できます． . 零点は単位円上にのみ存在する | $z=-1$以外の零点は全て複素共役になっている | . import numpy as np import altair as alt def companion(n: int): return np.hstack([np.vstack([np.zeros(n-1), np.eye(n-1,n-1)] ), -np.ones(n).reshape(-1,1)]) def zeros(n): return np.linalg.eig(companion(n))[0] def plot_zeros(n): source = alt.Data(values=sum([[{ &#39;Real Part&#39; : pt.real, &#39;Imaginary Part&#39;: pt.imag, &quot;n&quot;: i } for pt in zeros(i)] for i in range(1, n + 1)], [])) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.Chart(source).mark_circle().encode(x=alt.X(&quot;Real Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2])), y=alt.Y(&quot;Imaginary Part:Q&quot;, scale=alt.Scale(domain=[-1.2, 1.2]))).add_selection(select_order).transform_filter(select_order).interactive() plot_zeros(32) . &#21608;&#27874;&#25968;&#29305;&#24615;&#12434;&#27714;&#12417;&#12427; . 同様に周波数特性を求めます．周波数特性は$H(z)$に対して$z rightarrow exp^{-i omega}$と置換して$ left|H(z) right|$，$ angle H(z)$を計算することで得られます． . import math def response(n): freq = np.linspace(0, 1.0, 257, endpoint=True) resp = np.sum(np.vander(np.exp(freq * 2 * np.pi * 1j), n), axis=1) / n return resp, freq def plot_freq_feature(n): source = alt.Data(values = sum([[{ &#39;Normalized frequency&#39;: f, &#39;gain&#39;: 20 * math.log10(abs(r)), &#39;phase&#39;: math.atan2(r.imag, r.real), &#39;n&#39;: i } for r, f in zip(*response(i))] for i in range(1, n+1)], [])) base = alt.Chart(source).encode( alt.X(&#39;Normalized frequency:Q&#39;, axis=alt.Axis(title=None)) ) amp = base.mark_line(stroke=&#39;#57A44C&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;gain:Q&#39;, scale=alt.Scale(domain=[-50, 0], clamp=True), axis=alt.Axis(title=&#39;Gain(dB)&#39;, titleColor=&#39;#57A44C&#39;)), ) phase = base.mark_line(stroke=&#39;#5276A7&#39;, interpolate=&#39;monotone&#39;).encode( alt.Y(&#39;phase:Q&#39;, scale=alt.Scale(domain=[-math.pi, math.pi]), axis=alt.Axis(title=&#39;Phase(rad)&#39;, titleColor=&#39;#5276A7&#39;)), ) slider = alt.binding_range(min=1, max=n, step=1,name=&quot;n&quot;, ) select_order = alt.selection_single(fields=[&#39;n&#39;], bind=slider, init={&#39;n&#39;: 1}) return alt.layer(amp, phase).resolve_scale( y = &#39;independent&#39; ).add_selection(select_order).transform_filter(select_order).interactive() plot_freq_feature(32) . 上図より以下のことが確認できます． . 低周波を通し，高周波をカットするローパスフィスタになっている | 複素平面上で零点の存在する周波数は利得が小さい（カットされている） | 直線位相となっている | . &#21442;&#32771; . Eigenvalue-Polynomials | .",
            "url": "https://lab.ar90n.net/signal%20processing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "relUrl": "/signal%20processing/jupyter/2020/10/10/analysis-of-moving-average-filter.html",
            "date": " • Oct 10, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "GitHub ActionsでWebサイトを自動更新する",
            "content": "はじめに . GitHubPages + GitHub Actions でコンテンツを自動的に更新するWebサイトをつくってみました．GitHub Trending に登場したリポジトリに付与されていた topics を一覧表示するサイトです．言語ごとの用途がざっくりとした感じでみることができます． . Topics in GitHub Trending - GitHub . 今回，勉強も兼ねてフロントエンドとデータのクローリング処理共に Elm で記述しました． . GitHub Actions によるバッチ処理の定刻実行 . GitHub Actionsによって定刻実行されるバッチ処理はは以下の3つのジョブからなります． . build | crawl | push | . それぞれ，クローリングスクリプトのビルド，データのクローリング，データのリポジトリへのプッシュを行います．設定の詳細はこちらを参考にしてください． . CLIプログラムを Elm で書く . crawlジョブではElmで記述されたCLIプログラムを実行してデータの取得を行います．ElmはWebフロントエンドを記述することに特化している言語です．そのため，CLIプログラムの開発に必要な，コマンドライン引数の処理といった機能がサポートされいません．そこで，今回は以下のパッケージを持ちました． . pdillonkearns/elm-cli-options-parser . こちらのパッケージを用いると，Flagを用いてコマンドライン引数へのアクセスが可能となります．今回のプログラムでは，以下の様にgithubToken と language と dataRange とを引数から受け取っています． . init : Flags -&gt; TrendingApiOptions -&gt; ( Model, Cmd Msg ) init { githubToken } { language, dateRange } = ( { githubToken = githubToken } , attemptApi TrendingApiResponse (fetchTrending githubToken language dateRange) ) . また，GitHub Tredingsの取得は以下のAPIを利用させていただきました． . github-trending-api . クローリング結果の保存 . 今回，GitHub PagesのみでWebサイトをホスティングするため，データベースを使用することはできません．そのため，クローリング結果はJSONに整形されたのちに，直接GitHub Pagesのリポジトリにプッシュされます． . topics . この，JSONをフロントエンドから取得することで動的なコンテンツ更新を実現します． . Elmによるフロントエンド開発 . 特筆すべきことはありません．Elmは本当に書きやすい言語でした． . 所感 . Elmの勉強としてはちょうど良い分量でした．GitHub PagesとGitHub Actionsで結構なことができる印象なので，また何かチャレンジしたいですね． .",
            "url": "https://lab.ar90n.net/elm/web/2020/08/09/automated-update-github-pages.html",
            "relUrl": "/elm/web/2020/08/09/automated-update-github-pages.html",
            "date": " • Aug 9, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "純粋なバイナリヒープ",
            "content": "純粋なヒープを実装する場合，Braun Treeなど色々と適したデータ構造があるらしいですね． でも、あまり詳しくないので今回は馴染みの深いバイナリヒープを実装する方法について調べてみました． . バイナリヒープとは？ . 二分木を用いて実装したヒープです．ヒープとは以下の性質をもつデータ構造です． . 木構造をもつ | 常に子要素の値は親要素の値以上 | . ヒープ自身の詳細についてはこの記事を参考にしてください． . バイナリヒープを純粋に実装する . 一般的にバイナリヒープの実装には配列とそのインデックスを用いることが多いと思います．（上記のウィキペディアにもこの方法が記載されています） しかしがなら，この方法は配列の内容を書き換える必要があるため，純粋ではありません．そこで，今回は以下で提案されている手法を用いました． . A Functional Approach to Standard Binary Heaps . この論文では，純粋なバイナリヒープの挿入，構築，削除の各操作ついてScalaを用いて説明しています． 以降，これらについて簡単に紹介を行います． . ヒープクラス . この論文ではバイナリヒープを表現するためのクラスHeapを以下のように定義しています， . abstract sealed class Heap { def min: Int // ヒープの最小値 def left: Heap //左側の子要素 def right: Heap //右側の子要素 def size: Int //ヒープに含まれる要素数 def height: Int //ヒープの高さ } case class Branch(min: Int, left: Heap, right: Heap, size: Int, height: Int) extends Heap case object Leaf extends Heap { def min: Int = fail(&quot;Leaf.min&quot;) def left: Heap = fail(&quot;Leaf.min&quot;) def right: Heap = fail(&quot;Leaf.right&quot;) def size: Int = 0 def height: Int = 0 } . 上述の通り，Heapクラスのleftとrightを持つ再帰的な構造になっています． また，Heapクラスは抽象クラスであるため，一つ以上の子要素を持つBranchと子要素を持たないLeafとを派生させています． 単純な二分木にはsizeとheightは必須ではありません．しかしながら，今回のようにバイナリヒープを実現するためには非常に重要となってきます． . 挿入 O(log n) . 新たな要素をを挿入する際に気をつけなければいけないことは，要素を挿入したバイナリヒープもまた上述の条件を満たさなければならないということです． そこで，今回の実装では挿入処理を以下の二つの処理に分けて考えます． . 要素をLeafとして最下レベルに追加する． | 1.にて追加した要素を適切な位置まで上へ登らせる（bubbleUp）． | それでは，まずは1.の新たな要素をLeafとして追加する方法について解説します． ノード追加すること自体は言語側でやってくれることなので，基本的には問題になりません． そのため，次にLeafを挿入する場所はどこかを知ることが問題となります． . 二分木に対する操作のパフォーマンスは木の高さに依存するため，可能な限り二分木の高さを抑える必要があります． 従って，新たな要素はleft側から順番に挿入します． バイナリヒープは二分木であるため，ルートから適切にleftまたはrightを選択することで任意の位置に到達することが可能です． そのため，この問題はleftとrightを以下のように4つの場合に分けて考えることで解決することができます． . leftが完全二分木でない場合 -&gt; leftを選択 | leftが完全二分木であるが，rightは完全二分木でない場合 -&gt; rightを選択 | leftもrightも完全二分木であるが，leftの方がrightよりも高い場合 -&gt; rightを選択 | leftもrightも完全二分木であり，高さが等しい場合 -&gt; leftを選択 | これら4つの場合を図に表すと以下のようになります． . . また，Heapが完全二分木であるか否かは以下の条件式で求めることが可能です． . Size==2Height−1Size == 2^{Height} - 1Size==2Height−1 . 次に，2.のbubbleUpの方法について解説します． bubbleUpの処理は単純で，自身の値(min)と子要素の値(min)とを比較し，子要素の値(min)の値の方が小さい場合は要素を入れ替えます． 以上の結果を元に，insertとbubbleUpは以下のように実装することができます． . def bubbleUp(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, Heap(x, lt, rt), r) case (_, Branch(z, lt, rt, _, _)) if (x &gt; z) =&gt; Heap(z, l, Heap(x, lt, rt)) case (_, _) =&gt; Heap(x, l, r) } def insert(x: Int): Heap = if (isEmpty) Heap(x) else if (left.size &lt; math.pow(2, left.height) - 1) bubbleUp(min, left.insert(x), right) else if (right.size &lt; math.pow(2, right.height) - 1) bubbleUp(min, left, right.insert(x)) else if (right.height &lt; left.height) bubbleUp(min, left, right.insert(x)) else bubbleUp(min, left.insert(x), right) . 構築 O(n) . ソートされていない配列からバイナリヒープの構築を試みます． ここでは，構築済みのバイナリヒープをleftとrightに，配列のi番目の要素をminに設定した要素を考えます． しかしながら，配列のi番目の要素が各子要素の値(min)より小さいとは限らないため，全体としてヒープの条件を満たすとは限りません． そこで，ヒープの条件を満たさない場合は，配列のi番目の要素を適切な位置まで降ろす操作(bubbleDown)が必要となります． . bubbleDownはHeapのminの値と各子要素のminの値とを比較し，小さな場合は何もせず， 大きな場合は要素を入れ替えた後に，再帰的にbubbleDownを呼びだします． こうすることで，当該要素を適切な位置まで降ろすことができます． 以上の結果を踏まえ，配列からバイナリヒープを構築する関数heapify及びbubbleUpは以下のように定義できます． . def bubbleDown(x: Int, l: Heap, r: Heap): Heap = (l, r) match { case (Branch(y, _, _, _, _), Branch(z, lt, rt, _, _)) if (z &lt; y &amp;&amp; x &gt; z) =&gt; Heap(z, l, bubbleDown(x, lt, rt)) case (Branch(y, lt, rt, _, _), _) if (x &gt; y) =&gt; Heap(y, bubbleDown(x, lt, rt), r) case (_, _) =&gt; Heap(x, l, r) } def heapify(a: Array[Int]): Heap = { def loop(i: Int): Heap = if (i &lt; a.length) bubbleDown(a(i), loop(2 * i + 1), loop(2 * i + 2)) else Leaf loop(0) } . heapifyは一見するとを$O(n log n)$に見えますが，漸近的には$O(n)$らしいです． 正直，なぜ$O(n)$に成るのかは理解できていませんが，アルゴリズムイントロダクションに詳細が記載されているとあったので，そのうち調べてみようと思います． . 削除 O(log n) . 要素をの削除も挿入と同様， 以下のように二つのの処理に分けて考えることができます． . 最後に挿入した要素をバイナリヒープのルートへ移動させる | 1.でルートへ移動した要素を適切な位置まで降ろす(bubbleDown) | 最後に挿入した要素は挿入処理と同様に二分木を走査し，当該要素を見つけることで実現します． 要素を適切な位置まで降ろす処理(bubbleDown)は構築の際に用いたものと同一です． 以上の結果より，要素を削除する関数removeは以下のように実装されます． なお，floatLeftは左側の，floatRightは右側の子要素の値と親要素の値を交換する関数です. . def remove: Heap = if (isEmpty) fail(&quot;Empty heap.&quot;) else bubbleRootDown(mergeChildren(left, right)) def bubbleRootDown(h: Heap): Heap = if (h.isEmpty) Leaf else Heap.bubbleDown(h.min, h.left, h.right) def mergeChildren(l: Heap, r: Heap): Heap = if (l.isEmpty &amp;&amp; r.isEmpty) Leaf else if (l.size &lt; math.pow(2, l.height) - 1) floatLeft(l.min, mergeChildren(l.left, l.right), r) else if (r.size &lt; math.pow(2, r.height) - 1) floatRight(r.min, l, mergeChildren(r.left, r.right)) else if (r.height &lt; l.height) floatLeft(l.min, mergeChildren(l.left, l.right), r) else floatRight(r.min, l, mergeChildren(r.left, r.right)) def floatLeft(x: Int, l: Heap, r: Heap): Heap = l match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, Heap(x, lt, rt), r) case _ =&gt; Heap(x, l, r) } def floatRight(x: Int, l: Heap, r: Heap): Heap = r match { case Branch(y, lt, rt, _, _) =&gt; Heap(y, l, Heap(x, lt, rt)) case _ =&gt; Heap(x, l, r) } . F#によるプライオリティキュー . バイナリヒープを使ったプライオリティキューの実装です． . PriorityQueue . 参考文献ではScalaによる実装でしたが，自分が普段使いする言語はF#なので，F#で実装してみました． .",
            "url": "https://lab.ar90n.net/algorithm/2020/06/27/purely-binary-heap.html",
            "relUrl": "/algorithm/2020/06/27/purely-binary-heap.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "三次元空間における行列演算の復習",
            "content": "ぱっと思いつかなかったのでメモ． . 任意の単位ベクトルへの射影行列 . 任意の単位ベクトルを$ vec{n}$とすると，$ vec{n}$への射影行列$P_{p}$は以下の様に表されます． . Pp=n⃗n⃗TP_{p} = vec{n} vec{n}^{T}Pp​=n . n . T . 法線ベクトルに直交する平面への射影行列 . 法線ベクトルへの射影を元のベクトルから引くことで，法線ベクトルと直交する平面への射影が可能となります． そのため，法線ベクトルと直交する平面への射影行列$P_{o}$は以下のように表されます． . Po=I−Pp=I−n⃗n⃗T begin{aligned} P_{o} &amp;= I - P_{p} &amp;= I - vec{n} vec{n}^{T} end{aligned}Po​​=I−Pp​=I−n . n . T​ . 任意の単位ベクトルを回転軸とした回転行列 . 任意の単位ベクトル$ vec{n}$を以下のように定義します． n⃗=(nx,ny,nz) vec{n} = left(n_x, n_y, n_z right)n=(nx​,ny​,nz​) . ここで，Z軸方向の単位ベクトル$ vec{e_{z}}$を$ vec{n}$に変換する行列$P$を考えます．$P$はY軸回転$R_{y}$とZ軸回転$R_{z}$の積で以下のように表現できます． cθ=nxnx2+ny2sθ=nynx2+ny2cϕ=nznx2+ny2+nz2sϕ=nx2+ny2nx2+ny2+nz2Rxz=(cϕ0sϕ010−sϕ0cϕ)Rxy=(cθ−sθ0sθcθ0001)P=Rxy∗Rxz begin{aligned} c_{ theta} &amp;= frac{n_{x}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} s_{ theta} &amp;= frac{n_{y}}{ sqrt{n_{x}^{2} + n_{y}^{2}}} c_{ phi} &amp;= frac{n_{z}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} s_{ phi} &amp;= frac{ sqrt{n_{x}^{2} + n_{y}^{2}}}{ sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} R_{xz} &amp;= left( begin{array}{rrr} c_{ phi} &amp; 0 &amp; s_{ phi} 0 &amp; 1 &amp; 0 -s_{ phi}&amp; 0 &amp; c_{ phi} end{array} right) R_{xy} &amp;= left( begin{array}{rrr} c_{ theta} &amp; -s_{ theta} &amp; 0 s_{ theta} &amp; c_{ theta} &amp; 0 0 &amp; 0 &amp; 1 end{array} right) P &amp;= R_{xy} * R_{xz} end{aligned}cθ​sθ​cϕ​sϕ​Rxz​Rxy​P​=nx2​+ny2​​nx​​=nx2​+ny2​​ny​​=nx2​+ny2​+nz2​​nz​​=nx2​+ny2​+nz2​​nx2​+ny2​​​=⎝⎜⎜⎜⎜⎜⎛​cϕ​0−sϕ​​010​sϕ​0cϕ​​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cθ​sθ​0​−sθ​cθ​0​001​⎠⎟⎟⎟⎟⎟⎞​=Rxy​∗Rxz​​ . $P$によって変換されたZ軸を$ vec{e_{z}’}(= vec{n})$とすると，所望の任意の単位ベクトルを回転軸とする回転行列は以下の３つの変換の合成で表すことができます． . $ vec{e_{z}}$を$ vec{e_{z}}’$に変換する$P$ | $ vec{e_{z}}$を回転軸とする回転$R_{a}$ | $ vec{e_{z}}’$を$ vec{e_{z}}$に変換する$P^{T}$ | したがって，最終的な回転行列$R$は以下のように表されます． . Ra=(cos⁡(a)−sin⁡(a)0sin⁡(a)cos⁡(a)0001)R=P∗Ra∗PT=(nx2+(ny2+nz2)cos⁡(a)−nxnycos⁡(a)+nxny−(nz3+(nx2+ny2)nz)sin⁡(a)−nxnzcos⁡(a)+nxnz+nysin⁡(a)−nxnycos⁡(a)+nxny+(nz3+(nx2+ny2)nz)sin⁡(a)ny2+(nx2+nz2)cos⁡(a)−nynzcos⁡(a)+nynz−nxsin⁡(a)−nxnzcos⁡(a)+nxnz−(nx2ny+ny3+nynz2)sin⁡(a)−nynzcos⁡(a)+nynz+(nx3+nxny2+nxnz2)sin⁡(a)nz2+(nx2+ny2)cos⁡(a))=(cos⁡(a)+nx2(1−cos⁡(a))nxny(1−cos⁡(a))−nzsin⁡(a)nxnz(1−cos⁡(a))+nysin⁡(a)nxny(1−cos⁡(a))+nzsin⁡(a)cos⁡(a)+ny2(1−cos⁡(a))nynz(1−cos⁡(a))−nxsin⁡(a)nxnz(1−cos⁡(a))−nysin⁡(a)nynz(1−cos⁡(a))+nxsin⁡(a)cos⁡(a)+nz2(1−cos⁡(a))) begin{aligned} R_{a} &amp;= left( begin{array}{rrr} cos left(a right) &amp; - sin left(a right) &amp; 0 sin left(a right) &amp; cos left(a right) &amp; 0 0 &amp; 0 &amp; 1 end{array} right) R &amp;= P * R_{a} * P^{T} &amp;= left( begin{array}{rrr} mathit{n_{x}}^{2} + { left( mathit{n_{y}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} - { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} + mathit{n_{y}} sin left(a right) - mathit{n_{x}} mathit{n_{y}} cos left(a right) + mathit{n_{x}} mathit{n_{y}} + { left( mathit{n_{z}}^{3} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} mathit{n_{z}} right)} sin left(a right) &amp; mathit{n_{y}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{z}}^{2} right)} cos left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} - mathit{n_{x}} sin left(a right) - mathit{n_{x}} mathit{n_{z}} cos left(a right) + mathit{n_{x}} mathit{n_{z}} - { left( mathit{n_{x}}^{2} mathit{n_{y}} + mathit{n_{y}}^{3} + mathit{n_{y}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; - mathit{n_{y}} mathit{n_{z}} cos left(a right) + mathit{n_{y}} mathit{n_{z}} + { left( mathit{n_{x}}^{3} + mathit{n_{x}} mathit{n_{y}}^{2} + mathit{n_{x}} mathit{n_{z}}^{2} right)} sin left(a right) &amp; mathit{n_{z}}^{2} + { left( mathit{n_{x}}^{2} + mathit{n_{y}}^{2} right)} cos left(a right) end{array} right) &amp;= left( begin{array}{rrr} cos left(a right) + mathit{n_{x}}^{2} left(1- cos left(a right) right) &amp; mathit{n_{x}} mathit{n_{y}} left(1 - cos left(a right) right) - mathit{n_{z}} sin left(a right) &amp; mathit{n_{x}} mathit{n_{z}} left( 1 - cos left(a right) right) + mathit{n_{y}} sin left(a right) mathit{n_{x}} mathit{n_{y}} left( 1 - cos left(a right) right) + mathit{n_{z}} sin left(a right) &amp; cos left(a right) + mathit{n_{y}}^{2} left( 1- cos left(a right) right) &amp; mathit{n_{y}} mathit{n_{z}} left( 1- cos left(a right) right) - mathit{n_{x}} sin left(a right) mathit{n_{x}} mathit{n_{z}} left(1- cos left(a right) right) - mathit{n_{y}} sin left(a right) &amp; mathit{n_{y}} mathit{n_{z}} left(1- cos left(a right) right) + mathit{n_{x}} sin left(a right) &amp; cos left(a right) + mathit{n_{z}}^{2} left( 1- cos left(a right) right) end{array} right) end{aligned}Ra​R​=⎝⎜⎜⎜⎜⎜⎛​cos(a)sin(a)0​−sin(a)cos(a)0​001​⎠⎟⎟⎟⎟⎟⎞​=P∗Ra​∗PT=⎝⎜⎜⎜⎜⎜⎛​nx​2+(ny​2+nz​2)cos(a)−nx​ny​cos(a)+nx​ny​+(nz​3+(nx​2+ny​2)nz​)sin(a)−nx​nz​cos(a)+nx​nz​−(nx​2ny​+ny​3+ny​nz​2)sin(a)​−nx​ny​cos(a)+nx​ny​−(nz​3+(nx​2+ny​2)nz​)sin(a)ny​2+(nx​2+nz​2)cos(a)−ny​nz​cos(a)+ny​nz​+(nx​3+nx​ny​2+nx​nz​2)sin(a)​−nx​nz​cos(a)+nx​nz​+ny​sin(a)−ny​nz​cos(a)+ny​nz​−nx​sin(a)nz​2+(nx​2+ny​2)cos(a)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​cos(a)+nx​2(1−cos(a))nx​ny​(1−cos(a))+nz​sin(a)nx​nz​(1−cos(a))−ny​sin(a)​nx​ny​(1−cos(a))−nz​sin(a)cos(a)+ny​2(1−cos(a))ny​nz​(1−cos(a))+nx​sin(a)​nx​nz​(1−cos(a))+ny​sin(a)ny​nz​(1−cos(a))−nx​sin(a)cos(a)+nz​2(1−cos(a))​⎠⎟⎟⎟⎟⎟⎞​​ .",
            "url": "https://lab.ar90n.net/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "relUrl": "/math/geometry/2020/06/27/linear-algebra-in-3d-coordinates.html",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "5行で書くポアソンブレンディング",
            "content": "はじめに . 画像の滑らかな合成アルゴリズムにポアソンブレンディング(Poisson Image Editting)があります．これは，ポアソン方程式を解くことで元の勾配を保ちながら，境界部分が連続となる合成画像を推定するというものです． ネットを調べると，ポアソン方程式の計算にはSOR法やマルチグリッド法などを実装した高速な連立方程式ソルバを利用することが多いようです．しかしながら，外部のソルバを利用するとプロジェクトの規模が大きくなってしまいます．また，外部のソルバを利用せず，上述のアルゴリズムを自前で実装することは非常に困難な作業です．そこで，ヤコビ法をラプラシアンフィルタで記述し実装を簡略化しました． . やったこと . ラプラシアンフィルタを使用してヤコビ法を記述 | ポアソンブレンディングを５行で実装 | プロジェクトをGithubに作成 | . ポアソン方程式をラプラシアンフィルタで記述する . 参考記事によると，座標$p$における画素値$f_p$は以下の式で求められます． . fp=∑q∈Nfq+4gq−∑q∈Ngq4f_p = frac{ sum_{q in N} f_q + 4 g_{q} - sum_{q in N} g_q}{4}fp​=4∑q∈N​fq​+4gq​−∑q∈N​gq​​ . ここで，ヤコビ法によって$f_p$を求めます．$k$回目のイテレーションにおける座標$p$における画素値を$f_{p}^{k}$とします．すると，$f_{p}^{k}$は以下のように表記することができます． . fpk+1=∑q∈Nfqk+4gp−∑q∈Ngq4=4fpk−4fpk+∑q∈Nfqk+4gp−∑q∈Ngq4=fpk+−4(fpk−gp)+∑q∈Nfqk−gq4=fpk+14Δp(f−g) begin{aligned} f_{p}^{k+1} &amp;= frac{ sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_{q}}{4} &amp;= frac{4f_{p}^{k} -4 f_{p}^{k} + sum_{q in N} f_{q}^{k} + 4 g_{p} - sum_{q in N} g_q}{4} &amp;= f_{p}^{k} + frac{-4 (f_{p}^{k} - g_{p}) + sum_{q in N} f_{q}^{k} - g_q}{4} &amp;= f_{p}^{k} + frac{1}{4} Delta_{p} left(f - g right) end{aligned}fpk+1​​=4∑q∈N​fqk​+4gp​−∑q∈N​gq​​=44fpk​−4fpk​+∑q∈N​fqk​+4gp​−∑q∈N​gq​​=fpk​+4−4(fpk​−gp​)+∑q∈N​fqk​−gq​​=fpk​+41​Δp​(f−g)​ . 以上の結果より，注目領域に$ frac{1}{4} Delta_{p} left(f - g right)$を加算していくことで合成を行います． $ Delta_{p}$は座標$p$におけるラプラシアンを表します．以下にscipyを用いで実装したコードを示します．関数の引数はそれぞれ，target_imgが合成先画像，src_imgが合成元画像, mask_imgが合成領域マスク, iterが反復処理の回数をそれぞれ表します．コードサイズを5行に抑えるため，省いた処理（入力のバリデーション，反復処理の打ち切り）や冗長な処理（target_imgとsrc_imgとの差分を毎ループ計算している）がありますが，アルゴリズムのエッセンスは十分表現できていると思います． . 5行で実装 . from scipy.ndimage import laplace def poisson_blend(target_img, src_img, mask_img, iter: int = 1024): for _ in range(iter): target_img = target_img + 0.25 * mask_img * laplace(target_img - src_img) return target_img.clip(0, 1) . poisson_blendの入力と出力との関係を以下の図に示します．以下の図は，左側から合成元画像(src_img)，合成領域マスク(mask_img)，合成先画像(target_img)，合成画像を表します．境界領域が滑らかに合成されていることが確認できます． . . 上記の関数に加え，結果確認用のノートブックなどを追加したリポジトリを作成しました．よろしければ，こちらも参考にしてください. . 参考 . Poisson Image Editing | ar90n/poisson-blending-in-5lines | .",
            "url": "https://lab.ar90n.net/image%20processing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "relUrl": "/image%20processing/python/2020/05/31/poisson-blending-in-5-lines.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
            "content": "はじめに . Raspberry Pi 4+k3s+rayでクラスタを作成して，分散処理の実験を行います．Raspberry Pi 4 には事前にUbuntu 20.04を導入しておきます． . cgroupの有効化 . 残念ながら，このcgroupの設定が何故必要なのかを理解できていません．しかしながら，Webで調べた限りでは，必要そうなので設定することにします．（設定しない場合はどうなるかを試してはいません） . SDカードをホストマシンにマウントして以下のコマンド実行します．以下の例では，/Vlumes/system-bootにSDカードがマウントされています．マウントポイントについては，環境に応じて適切に書き換えてください． . $ sed -i -e &#39;s/$/ cgroup_memory=1 cgroup_enable=memory cgroup_enable=cpuset/&#39; /Volumes/system-boot/cmdline.txt . 修正したSDカードを用いてシステムを起動します．その後，以下のコマンドで設定の反映を確認できます． . $ cat /proc/cgroups #subsys_name hierarchy num_cgroups enabled cpuset 5 10 1 cpu 4 98 1 cpuacct 4 98 1 blkio 8 98 1 memory 2 147 1 devices 11 98 1 freezer 9 11 1 net_cls 6 10 1 perf_event 7 10 1 net_prio 6 10 1 pids 10 106 1 rdma 3 1 1 . k3sの導入 . リポジトリの手順に従います．注意が必要な点は，マスターノードとワーカーノードとで導入方法が異なる点です．ここでハマらなければ，さくっと導入できると思います．今回，以下の様にマスターノードx1，ワーカーノードx3でk3sクラスタを構成しました． . $ kubectl get nodes NAME STATUS ROLES AGE VERSION k3s-node3 Ready worker 3d12h v1.18.2+k3s1 k3s-node2 Ready worker 3d12h v1.18.2+k3s1 k3s-node1 Ready worker 3d12h v1.18.2+k3s1 k3s-master Ready master 3d18h v1.18.2+k3s1 . rayクラスタのデプロイ . こちらも公式の手順に従います．しかしながら，こちらで使用しているDockerイメージはamd64向けに作成された物であり，aarch64環境では動作しません．そこで，ほぼ等価なイメージをaarch64向けに作成しました．今回は，このイメージを用いてクラスタを作成します．具体的には，ray-cluster.yamlを以下の様に修正します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..0563c934f 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,7 +59,7 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: @@ -120,7 +120,7 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: . 以下のようにコンテナをデプロイします． . $ kubectl create -f ray/doc/kubernetes/ray-namespace.yaml namespace/ray created $ kubectl apply -f ray/doc/kubernetes/ray-cluster.yaml service/ray-head created deployment.apps/ray-head created deployment.apps/ray-worker created $ kubectl -n ray get pods NAME READY STATUS RESTARTS AGE ray-head-7957ff48b6-tj6z2 1/1 Running 0 118s ray-worker-7574c9d77-bs4dx 1/1 Running 0 118s ray-worker-7574c9d77-2868n 1/1 Running 1 118s ray-worker-7574c9d77-x48m7 1/1 Running 0 118s . クラスタの作成が完了したので，テストプログラムを実行します．こちらも公式の手順に従い，example.pyを実行します． . $ kubectl -n ray cp ray/doc/kubernetes/example.py ray-head-7957ff48b6-tj6z2:/example.py $ kubectl -n ray exec ray-head-7957ff48b6-tj6z2 -- python example.py 2020-05-24 14:13:54,824 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. Iteration 0 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 1 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 2 Counter({(&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 2}) Iteration 3 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 13, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3}) Iteration 4 Counter({(&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2}) Iteration 5 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 11, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 8, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 7, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 1}) Iteration 6 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 7 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 12, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 9, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 5, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 5, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 3}) Iteration 8 Counter({(&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 10, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 10, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 6, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 4, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 2, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 2}) Iteration 9 Counter({(&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 10, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 9, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 9, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 8, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 8, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 7, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 7, (&#39;ray-worker-7574c9d77-bs4dx&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 6, (&#39;ray-head-7957ff48b6-tj6z2&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-head-7957ff48b6-tj6z2&#39;): 6, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 5, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-x48m7&#39;): 4, (&#39;ray-worker-7574c9d77-2868n&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-bs4dx&#39;): 4, (&#39;ray-worker-7574c9d77-x48m7&#39;, &#39;ray-worker-7574c9d77-2868n&#39;): 3}) Success! . ベンチマーク . 最後に，作成したクラスタのベンチマークとして，マンデルブロ集合の描画時間を計測します．マンデルブロ集合の描画には以下のコードを用います．画像全体をn_x_grids x n_y_grids個の領域に区切り，各領域毎に並行処理します． . #!/usr/bin/env python import numpy as np from numba import njit import itertools import os import ray import matplotlib.pyplot as plt from timeit import timeit if (os.environ.get(&quot;RAY_HEAD_SERVICE_HOST&quot;) is None): ray.init() else: redis_host = os.environ[&quot;RAY_HEAD_SERVICE_HOST&quot;] ray.init(address=redis_host + &quot;:6379&quot;) n_x_grids = int(os.environ.get(&quot;X_GRIDS&quot;, 32)) n_y_grids = int(os.environ.get(&quot;Y_GRIDS&quot;, 32)) grid_width = int(os.environ.get(&quot;GRID_WIDTH&quot;, 100)) grid_height = int(os.environ.get(&quot;GRID_HEIGHT&quot;, 100)) def grid_range(begin, end, n_grids): ih, it = itertools.tee(np.linspace(begin, end, n_grids + 1)) next(it) return ((h,t) for h,t in zip(ih, it)) @ray.remote def mandelbrot(c, n = 32, th = 200): z = 1j * np.zeros(c.shape) r = np.zeros(c.shape) for i in range(n): mask = np.abs(z) &lt;= th z += (z * z + c - z) * mask.astype(np.int) r[mask] = i # make smooth return r - np.log2(np.log2(np.abs(z) + 1)) def rendering(n_xg, n_yg, gw, gh): res = [] xs = grid_range(-2, 1, n_xg) ys = grid_range(-1, 1, n_yg) for ((xb, xe), (yb, ye)) in itertools.product(xs, ys): x, y = np.meshgrid(np.linspace(xb, xe, gw), np.linspace(yb, ye, gh)) c = x + 1j * y res.append(mandelbrot.remote(c)) res = ray.get(res) return np.concatenate(np.concatenate(np.array(res).reshape(n_yg, n_xg, gh, gw), axis=2),axis=0) benchmark = timeit(lambda: rendering(n_x_grids, n_y_grids, grid_width, grid_height), number=8) / 8 print(f&quot;time: {benchmark}&quot;) img = rendering(n_x_grids, n_y_grids, grid_width, grid_height) plt.figure(dpi=200) plt.imshow(img, cmap=&#39;rainbow&#39;, interpolation=&#39;bilinear&#39;, extent=[-2, 1, -1, 1]) plt.xticks(color=&#39;None&#39;) plt.yticks(color=&#39;None&#39;) plt.tick_params(length=0) plt.savefig(&#39;figure.png&#39;) . また，クラスタの設定も少しだけ修正します．各コンテナに割り当てるメモリの変更と，必要なパッケージをコンテナ起動時に追加します． . diff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml index 853f9dfb2..d2b2c9678 100644 a/doc/kubernetes/ray-cluster.yaml +++ b/doc/kubernetes/ray-cluster.yaml @@ -59,11 +59,11 @@ spec: medium: Memory containers: - name: ray-head - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot; ] args: - - &quot;ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 6379 # Redis port. - containerPort: 6380 # Redis port. @@ -120,11 +120,11 @@ spec: medium: Memory containers: - name: ray-worker - image: rayproject/autoscaler + image: ar90n/autoscaler-py37 imagePullPolicy: Always command: [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;--&quot;] args: - - &quot;ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; + - &quot;conda install -y -c numba numba &amp;&amp; conda install -y matplotlib &amp;&amp; ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block&quot; ports: - containerPort: 12345 # Ray internal communication. - containerPort: 12346 # Ray internal communication. @@ -147,4 +147,4 @@ spec: resources: requests: cpu: 100m - memory: 512Mi + memory: 1024Mi . 実行結果を以下に示します．無事に動作している様です． . $ kubectl -n ray exec ray-head-6785995666-m49kv -- python main.py 2020-05-24 14:57:57,849 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster&#39;s _internal_config. (pid=2799) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2799) return r - np.log2(np.log2(np.abs(z) + 1)) (pid=2780, ip=10.42.1.13) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2780, ip=10.42.4.25) main.py:36: RuntimeWarning: divide by zero encountered in log2 (pid=2783, ip=10.42.0.35) main.py:36: RuntimeWarning: divide by zero encountered in log2 time: 34.654623864378664 . . Rayのワーカーノードの数を変更すると以下の様に処理時間が変化しました． . ワーカーノード数 処理時間[s] . 0 | 45.09195340787119 | . 1 | 48.55051823974645 | . 2 | 38.57156975386897 | . 3 | 34.654623864378664 | . あまり安定のしない微妙な結果となりました．思った以上に並列化される部分意外にボトルネックがあったのかもしれません． . 参考 . Raspberry pi 4におけるK3Sクラスタ構築 | Ray | k3s | .",
            "url": "https://lab.ar90n.net/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "relUrl": "/kubernetes/ray/python/distributed%20systems/2020/05/25/Ray-k3s-raspi4.html",
            "date": " • May 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "都内でソフトウェアエンジニアをやっています． . 画像処理，Python，Web開発など広くポストしてます． . Name . 和田政弘 . GitHub . @ar90n . Twitter . @ar90n . Mail . argon.argon.argon@gmail.com . Skill . 画像処理 | 医療画像処理 | Python | C++ | Web | 組み込み | .",
          "url": "https://lab.ar90n.net/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lab.ar90n.net/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}