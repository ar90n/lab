snippet ____powmod
    def powmod(a, k, m):
		if k == 0:
			return 1
	
		t = powmod(a, k // 2, m)
		res = (t * t) % m
		if k % 2 == 1:
			res = (res * a) % m
	
		return res

snippet ____prime_table
    def prime_table(n):
		t = [True] * (n + 1)
		t[0] = False
		t[1] = False
	
		i = 2
		while i * i <= n:
			for ii in range(2 * i, n + 1, i):
				t[ii] = False
			i += 1
		return [x for x, i in enumerate(t) if i == True]

snippet ____binary_search
    def binary_search(search_range, f, n=100, eps=1e-12):
		l, r = search_range
		c = (l + r) / 2.0
		for i in range(n):
			v = f(c)
			if abs(v) < eps:
				return c
	
			if v > 0:
				r = c
			else:
				l = c
			c = (l + r) / 2.0
	
		return c

snippet ____ternary_search
    def ternary_search( search_range, f, n = 100, eps = 1e-24 ):
		l, r = search_range
		for i in range( n ):
			ll = ( l + l + r ) / 3.0
			rr = ( l + r + r ) / 3.0
	
			vl = f( ll )
			vr = f( rr )
			if abs( vl - vr ) < eps:
				break
	
			if vl > vr :
				r =rr 
			else:
				l =ll 
	
		return ( l + r ) / 2.0

snippet ____UnionFind
    class UnionFind:
		def __init__(self, n):
			self._parents = list(range(n))
			self._ranks = [0] * n
			self._size = [1] * n
	
		def root(self, x):
			if self._parents[x] == x:
				return x
			self._parents[x] = self.root(self._parents[x])
			return self._parents[x]
	
		def size(self, x):
			return self._size[self.root(x)]
	
		def unite(self, x, y):
			rx = self.root(x)
			ry = self.root(y)
			if rx == ry:
				return
	
			if self._ranks[rx] < self._ranks[ry]:
				self._parents[rx] = ry
				self._size[ry] += self._size[rx]
			else:
				self._parents[ry] = rx
				self._size[rx] += self._size[ry]
				if self._ranks[rx] == self._ranks[ry]:
					self._ranks[rx] += 1
	
		def same(self, x, y):
			return self.root(x) == self.root(y)

snippet ____graph
    class DGraph:
		def __init__(self, n, edges):
			self._vertice = [{} for _ in range(n)]
			for e in edges:
				self._vertice[e[0]][e[1]] = e[2] if len(e) == 3 else 1
	
		def __len__(self):
			return len(self._vertice)
	
		def edges(self, n=None):
			srcs = range(len(self)) if n is None else [n]
			return sum([[(s, d, c) for d, c in self._vertice[s].items()] for s in srcs], [])
	
		def transpose(self):
			tedges = [(t, f, c) for f, t, c in self.edges()]
			return DGraph(len(self), tedges)
	
		def cost(self, src, dst):
			return self._vertice[src].get(dst, float('inf'))
	
	class Graph(DGraph):
		def __init__(self, n, edges):
			nd_edges = edges + [(d, s, c) for s, d, c in edges]
			super().__init__(n, nd_edges)
	
		def transpose(self):
			return self

snippet ____prim
    def prim(g, src):
		import heapq
	
		visited = [False] * len(g)
		spanning_tree_edges = []
		edge_heap = []
		heapq.heappush(edge_heap, (0, (src, src)))
		while edge_heap:
			c, (s, d) = heapq.heappop(edge_heap)
			if visited[d]:
				continue
			visited[d] = True
			spanning_tree_edges.append((s, d, c))
	
			for _, nd, ndc in g.edges(d):
				heapq.heappush(edge_heap, (ndc, (d, nd)))
	
		spanning_tree_edges = spanning_tree_edges[1:]
		return Graph(len(g), spanning_tree_edges)

snippet ____maxflow_ek
    def find_maxflow_ek(rg, source, sink):
		def find_source_to_sink_path(rg, source, sink):
			from collections import deque
			import sys
	
			bfs_queue = deque([source])
			bfs_visited = set([])
			parents_map = {source: -1}
			source_to_sink_path = []
	
			flow = sys.float_info.max
			while bfs_queue:
				current_node = bfs_queue.popleft()
				bfs_visited.add(current_node)
	
				if current_node == sink:
					r_current_node = current_node
					r_parent_node = parents_map[r_current_node]
					while r_parent_node != -1:
						capacity = rg[r_parent_node][r_current_node]
						flow = min(flow, capacity)
						source_to_sink_path.append(r_current_node)
						r_current_node = r_parent_node
						r_parent_node = parents_map[r_parent_node]
					source_to_sink_path.append(source)
					source_to_sink_path.reverse()
					return source_to_sink_path, flow, set([])
	
				for next_node in rg[current_node].keys():
					if 0 < rg[current_node][next_node] and next_node not in bfs_visited:
						parents_map[next_node] = current_node
						bfs_queue.append(next_node)
	
			return [], 0.0, set(bfs_visited)
	
		maxflow = 0.0
		while True:
			source_to_sink_path, current_flow, source_nodes = find_source_to_sink_path(
				rg, source, sink
			)
			print(source_to_sink_path, source_nodes)
			if current_flow == 0.0:
				break
	
			maxflow += current_flow
			for from_node, to_node in zip(
				source_to_sink_path[0:-1], source_to_sink_path[1:]
			):
				rg[from_node][to_node] -= current_flow
				rg[to_node][from_node] += current_flow
	
		all_nodes = set()
		for k, v in rg.items():
			all_nodes.add(k)
			for kk in v.keys():
				all_nodes.add(kk)
		sink_nodes = all_nodes - source_nodes
		return source_nodes, sink_nodes, maxflow

snippet ____dijkstra
    def dijkstra(g, src):
		import heapq
	
		min_cost = [float('inf')] * len(g)
	
		node_heap = []
		heapq.heappush(node_heap, (0, src))
		while node_heap:
			cost, node = heapq.heappop(node_heap)
			if min_cost[node] <= cost:
				continue
			min_cost[node] = cost
	
			for _, d, c in g.edges(node):
				dc = min_cost[node] + c
				heapq.heappush(node_heap, (dc, d))
		return min_cost

snippet ____bellman_ford
    def bellman_ford(g, src):
		min_cost = [float('inf')] * len(g)
		min_cost[src] = 0
	
		for _ in range(len(min_cost)):
			is_changed = False
			for s, d, c in g.edges():
				if min_cost[s] + c < min_cost[d]:
					is_changed = True
					min_cost[d] = min_cost[s] + c
			if not is_changed:
				break
		return min_cost

snippet ____bfs
    def bfs(g, src):
		from collections import deque
	
		visited = [False] * len(g)
		queue = deque([src])
		while queue:
			n = queue.popleft()
			if visited[n]:
				continue
			visited[n] = True
	
			for _, d, _ in g.edges(n):
				queue.append(d)
			yield n

snippet ____warshall_floyd
    def warshall_floyd(g):
		n = len(g)
		costs = [[float('inf') for i in range(n)] for j in range(n)]
		for i in range(n):
			costs[i][i] = 0
		for s, d, c in g.edges():
			costs[s][d] = c
	
		for k in range(n):
			for i in range(n):
				for j in range(n):
					costs[i][j] = min(costs[i][j], costs[i][k] + costs[k][j])
		return costs

snippet ____dfs
    def dfs(g, src):
		visited = [False] * len(g)
		stack = [src]
		while stack:
			n = stack.pop()
			if visited[n]:
				continue
			visited[n] = True
	
			for _, d, _ in g.edges(n):
				#yield d
				stack.append(d)
			yield n