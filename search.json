[
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "",
    "text": "WeaviateというGo実装の類似ベクトル検索エンジンで使用しているdot積が非常に早そうだったので再度ベンチマークを取ってみました。"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#やったこと",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#やったこと",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "やったこと",
    "text": "やったこと\n\nWeaviateのdot積をベンチマーク対象に追加\nベンチマーク条件変更\n\nデータ型をfloat32に変更\nGOMAXPROCSを1に設定"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#weaviateのdot積について",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#weaviateのdot積について",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "Weaviateのdot積について",
    "text": "Weaviateのdot積について\nWeaviateのdot積、avoに生成されたアセンブリコードとして提供されています。 動作環境はAVX2がサポートされている必要がありますが、環境では非常に高速な動作が期待できます。"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#対象コード",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#対象コード",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "対象コード",
    "text": "対象コード\n単純なループによる実装\n\nfunc CalcDot(a, b []float32) float32 {\n    var dot float32 = 0.0\n    size := len(a)\n    for i := 0; i < size; i++ {\n        dot += a[i] * b[i]\n    }\n    return dot\n}\n\nループアンロールによる実装（N=2）\n\nfunc CalcDotUnroll2(a, b []float32) float32 {\n    const N = 2\n    var dot float32 = 0.0\n\n    i := 0\n    size := len(a)\n    prologue_size := size % N\n    for ; i < prologue_size; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        dot += mul0 + mul1\n    }\n\n    return dot\n}\n\nループアンロールによる実装（N=4）\n\nfunc CalcDotUnroll4(a, b []float32) float32 {\n    const N = 4\n    var dot float32 = 0.0\n\n    i := 0\n    size := len(a)\n    prologue_size := size % N\n    for ; i < prologue_size; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        mul2 := a[i+2] * b[i+2]\n        mul3 := a[i+3] * b[i+3]\n        dot += mul0 + mul1 + mul2 + mul3\n    }\n\n    return dot\n}\n\nループアンロールによる実装（N=8）\n\nfunc CalcDotUnroll8(a, b []float32) float32 {\n    const N = 8\n    var dot float32 = 0.0\n\n    i := 0\n    size := len(a)\n    prologue_size := size % N\n    for ; i < prologue_size; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        mul2 := a[i+2] * b[i+2]\n        mul3 := a[i+3] * b[i+3]\n        mul4 := a[i+4] * b[i+4]\n        mul5 := a[i+5] * b[i+5]\n        mul6 := a[i+6] * b[i+6]\n        mul7 := a[i+7] * b[i+7]\n        dot += mul0 + mul1 + mul2 + mul3 + mul4 + mul5 + mul6 + mul7 \n    }\n\n    return dot\n}\n\nGonumによる実装（blas）\n\nimport (\n    \"gonum.org/v1/gonum/blas/blas32\"\n)\n\nfunc CalcDotByGonumBlas(a, b []float32) float32 {\n    size := len(a)\n    av := blas32.Vector{\n        N: size,\n        Inc:  1,\n        Data: a,\n    }\n    bv := blas32.Vector{\n        N: size,\n        Inc:  1,\n        Data: b,\n    }\n    return blas32.Dot(av, bv)\n}\n\nWeaviateによる実装（asm）\n\nimport (\n    \"github.com/semi-technologies/weaviate/adapters/repos/db/vector/hnsw/distancer/asm\"\n)\n\nfunc CalcDotByWeaviateAsm(a, b []float32) float32 {\n    return asm.Dot(a, b)\n}"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#ベンチマーク",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#ベンチマーク",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "ベンチマーク",
    "text": "ベンチマーク\n実行環境\n\n$lscpu\n\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nAddress sizes:                   43 bits physical, 48 bits virtual\nCPU(s):                          32\nOn-line CPU(s) list:             0-31\nThread(s) per core:              2\nCore(s) per socket:              16\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       AuthenticAMD\nCPU family:                      23\nModel:                           113\nModel name:                      AMD Ryzen 9 3950X 16-Core Processor\nStepping:                        0\nFrequency boost:                 enabled\nCPU MHz:                         2680.379\nCPU max MHz:                     4761.2300\nCPU min MHz:                     2200.0000\nBogoMIPS:                        6986.90\nVirtualization:                  AMD-V\nL1d cache:                       512 KiB\nL1i cache:                       512 KiB\nL2 cache:                        8 MiB\nL3 cache:                        64 MiB\nNUMA node0 CPU(s):               0-31\nVulnerability Itlb multihit:     Not affected\nVulnerability L1tf:              Not affected\nVulnerability Mds:               Not affected\nVulnerability Meltdown:          Not affected\nVulnerability Mmio stale data:   Not affected\nVulnerability Retbleed:          Mitigation; untrained return thunk; SMT enabled with STIBP protection\nVulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl and seccomp\nVulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization\nVulnerability Spectre v2:        Mitigation; Retpolines, IBPB conditional, STIBP always-on, RSB filling\nVulnerability Srbds:             Not affected\nVulnerability Tsx async abort:   Not affected\nFlags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba ibpb stibp vmmcall fsgsbase bmi1 avx2 smep bmi2 cqm rdt_a rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local clzero irperf xsaveerptr rdpru wbnoinvd arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif v_spec_ctrl umip rdpid overflow_recov succor smca sme sev sev_es\n\n\n検証用データ生成\n\nimport (\n    \"math/rand\"\n)\n\nN := 2048\nveca := make([]float32, N)\nvecb := make([]float32, N)\nfor i := 0; i < N; i++ {\n    veca[i] = rand.Float32()\n    vecb[i] = rand.Float32()\n}\n\nベンチマークコード\n\nimport (\n    \"testing\"\n    \"reflect\"\n    \"runtime\"\n)\n\nruntime.GOMAXPROCS(1)\n\nfunc bench(f func() float32) func(b *testing.B) {\n    return func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            f()\n        }\n    }\n}\n\ntype Result struct {\n    Size int\n    Benchmark map[string]testing.BenchmarkResult\n}\n\nresults := []Result{}\nfor _, size := range []int{32, 256, 2048} {\n    type BenchmarkFunc struct {\n        Name string\n        Func func(a, b []float32) float32\n    }\n\n    curVeca := veca[:size]\n    curVecb := vecb[:size]\n    bs := map[string]testing.BenchmarkResult{}\n    for _, e := range []BenchmarkFunc{\n        {Name: \"CalcDot\",            Func: CalcDot},\n        {Name: \"CalcDotUnroll2\",     Func: CalcDotUnroll2},\n        {Name: \"CalcDotUnroll4\",     Func: CalcDotUnroll4},\n        {Name: \"CalcDotUnroll8\",     Func: CalcDotUnroll8},\n        {Name: \"CalcDotByGonumBlas\", Func: CalcDotByGonumBlas},\n        {Name: \"CalcDotByWeaviateAsm\", Func: CalcDotByWeaviateAsm},\n    } {\n        bs[e.Name] = testing.Benchmark(bench(func() float32 {\n            e.Func(curVeca, curVecb)\n        }))\n    }\n    results = append(results, Result{Size: size, Benchmark: bs})\n}\n\nベンチマーク結果\n\n\nCode\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc calcNsPerOp(b *testing.BenchmarkResult) uint64 {\n    return uint64(b.T) / uint64(b.N)\n}\n\nfunc makeRow(funcName string, benchmark *testing.BenchmarkResult) string {\n    nsPerOp := calcNsPerOp(benchmark)\n    return fmt.Sprintf(\"<tr><td>%s</td><td>%d</td><td>%d</td><td>%d</td></tr>\", funcName,  benchmark.N, benchmark.T, nsPerOp)\n}\n\nfunc makeTable(results map[string]testing.BenchmarkResult, size int) string {\n    var rows []string\n    for name, result := range results {\n        rows = append(rows, makeRow(name, &result))\n    }\n    sort.Strings(rows)\n    return fmt.Sprintf(`<table class=\"dataframe\"><caption>size=%d</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr>%s</table>`, size, strings.Join(rows, \"\\n\"))\n}\n\ntables := []string{}\nfor _, r := range results {\n    tables = append(tables, makeTable(r.Benchmark, r.Size))\n}\ndisplay.HTML(strings.Join(tables, \"\\n\"))\n\n\n\nsize=32関数名回数時間[ns]1回あたりの時間[ns]CalcDot34697411799082313400\nCalcDotByGonumBlas33695812042227443573\nCalcDotByWeaviateAsm45707211186025992447\nCalcDotUnroll231940712890248054035\nCalcDotUnroll435375813221243803737\nCalcDotUnroll837566312590823363351\nsize=256関数名回数時間[ns]1回あたりの時間[ns]CalcDot92368120582191113054\nCalcDotByGonumBlas34182612395094643626\nCalcDotByWeaviateAsm45867311268619582456\nCalcDotUnroll272632125182975617235\nCalcDotUnroll486812122778322514143\nCalcDotUnroll893368122830032613155\nsize=2048関数名回数時間[ns]1回あたりの時間[ns]CalcDot13098121430720392709\nCalcDotByGonumBlas32007712167202033801\nCalcDotByWeaviateAsm43903011193759412549\nCalcDotUnroll295251176658556123533\nCalcDotUnroll412124118854378598032\nCalcDotUnroll813207120021223690876\n\n\n\n\nCode\nimport (\n    \"math\"\n    \"bytes\"\n    \"gonum.org/v1/plot\"\n    \"gonum.org/v1/plot/plotter\"\n    \"gonum.org/v1/plot/plotutil\"\n    \"gonum.org/v1/plot/vg\"\n    \"gonum.org/v1/plot/vg/draw\"\n)\n\nfunc displayPlot(p *plot.Plot) {\n    var buf bytes.Buffer\n    c, err := p.WriterTo(6*vg.Inch, 6*vg.Inch, \"png\")\n    if err != nil {\n        panic(err)\n    }\n    if _, err := c.WriteTo(&buf); err != nil {\n        panic(err)\n    }\n    Display(display.PNG(buf.Bytes()))\n}\n\n\np := plot.New()\np.Title.Text = \"Benchmark of dot product\"\np.X.Label.Text = \"Function\"\np.Y.Label.Text = \"Duration per op[ns]\"\np.X.Tick.Label.Rotation = math.Pi / 2.5\np.X.Tick.Label.XAlign = draw.XRight\np.Legend.Top = true\n\nnames := []string{}\nfor name, _ := range results[0].Benchmark {\n    names = append(names, name)\n}\nsort.Strings(names)\np.NominalX(names...)\n\n\nfor i, r := range results {\n    var values plotter.Values\n    for _, name := range names {\n        b := r.Benchmark[name]\n        values = append(values, float64(calcNsPerOp(&b)))\n    }\n    bar, _ := plotter.NewBarChart(values, vg.Points(20))\n    bar.LineStyle.Width = vg.Length(0)\n    bar.Color = plotutil.Color(i)\n    bar.Offset = vg.Points(float64(i - 1) * 20)\n    p.Add(bar)\n    p.Legend.Add(fmt.Sprintf(\"size=%d\", r.Size), bar)\n}\n\ndisplayPlot(p)"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#まとめ",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#まとめ",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "まとめ",
    "text": "まとめ\nすべての測定でWeaviateのアセンブリ実装が最速であることがわかりました。"
  },
  {
    "objectID": "posts/2022-11-16-dot-benchmark-in-go-again.html#参考",
    "href": "posts/2022-11-16-dot-benchmark-in-go-again.html#参考",
    "title": "続・Goによるdot積のベンチマーク",
    "section": "参考",
    "text": "参考\n\n\n[1] Weavite. GitHub repository. https://github.com/semi-technologies/weaviate; GitHub.\n\n\n[2] Tokyo, W.W.G. 2021. Go言語を楽しむ5つのレシピ: コタツと蜜柑とゴーファーとわたし. インプレスR&D."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Python\n        \n    \n        C++\n        \n    \n        Go\n        \n    \n        Jupyter Notebook\n        \n    \n        C\n        \n    \n        Rust\n        \n    \n        TypeScript\n        \n    \n        JavaScript"
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "",
    "text": "Jupyter Notebookはカーネルを切り替えることにより，様々な言語で開発することができます．ここでは，Rustのカーネル実装であるevcxr_jupyterを用いて，NotebookによるRust開発に挑戦してみます．"
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#やったこと",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#やったこと",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "やったこと",
    "text": "やったこと\n\nevcxr_jupyterの導入\n外部Crateの導入\nデータ表示のカスタマイズ\nplottersによるグラフの描画"
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#evcxr_jupyterの導入",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#evcxr_jupyterの導入",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "evcxr_jupyterの導入",
    "text": "evcxr_jupyterの導入\njupyter-langsのRustに関する部分をお借りしました．当該箇所を自分のDockerfileにコピペで特に問題なく動作しました．使用するだけならば，jupyter-langsを直接使うのが一番手っ取り早いと思います．それにしても，jupyter-langsはすごいですね．これだけカーネルを導入するのは色々と大変だったと思います．ありがたいです．"
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#外部crateの導入",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#外部crateの導入",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "外部Crateの導入",
    "text": "外部Crateの導入\n外部Crateの導入はCode Cellに以下の様な記述を追加することで実現します．\n:dep Crate名 = バージョン\n初回評価時はコンパイルを行うため少し時間がかかります．以下に，base64を導入する例を示します．\n\n:dep base64 = \"0.10.1\"\n\n//From Tour of the EvCxR Jupyter Kernel\n//https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb\nbase64::encode(&vec![1, 2, 3, 4])\n\n\"AQIDBA==\""
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#データ表示のカスタマイズ",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#データ表示のカスタマイズ",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "データ表示のカスタマイズ",
    "text": "データ表示のカスタマイズ\nevcxr_jupyterは以下のフォーマットでMIME Type と Content を標準出力に出力することで，HTMLに埋め込んで表示することが可能です．\nEVCXR_BEGIN_CONTENT <<MIME Type>>\n\n<< Content >>\n\nEVCXR_END_CONTENT\n具体的には，以下の様に表を出力したり，\n\nprintln!(r#\"EVCXR_BEGIN_CONTENT text/html\n    \n<table>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n</tr>\n</table>\n    \nEVCXR_END_CONTENT\"#);\n\n\n    \n\n\n1\n2\n3\n\n\n4\n5\n6\n\n\n7\n8\n9\n\n\n    \n\n\n画像を出力したりすることが可能です\n\nprintln!(r#\"EVCXR_BEGIN_CONTENT image/png\n    \niVBORw0KGgoAAAANSUhEUgAAAJAAAACQEAQAAAAd3/ZwAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0T//xSrMc0AABKWSURBVHja7Z15eBRF+se/IeFSIkFgOTwICRIEFOQQBM8FFVHWC5afN8pyyLHoKrqgCAqIBEVAXcEbBEEQiIt4ggIKrAhClOWKhCQkIeQgIQkhJDPz/f0xsMNcSR9VXTOhP8/Tz5N0Vb/1vtXf6a6u6q6KIEnY2BiklmoHbMIbW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFZGMKW0A2prAFFIQ3IoGICOD551V7EtqccwJaHOcWxsM5gGtH4Dx7VwB/d7n/nj4d+OneIMaOAM8sd9t7LV91ZIrgOUR5fxLwbMNIcqJ3Htc4Mn6Ydz6APNXJ396Li73zFHyjOkLrOaeuQBvv9v7/3Qhgwh/e+xY7gYPv+h/72oXe/7/RDZj8oPe+zyerjlABqhUsipymnivBJw6STv88vbP8rywAOXMqyf5kdkrg9DPbvgkk65AL3w6c3jCJ5Lf+5X61zpNn/z2qa0osNUZACw55n8yBX5DHizzpudOqFoeo7cBQT5nlF5JjbvFOf/YZ1TUllhpzC9tym/f/n90BNIwBtnUFSt8HZqRb48dzzYDjjYC9CcAF0cCb33qnr2+ruqbEEkHWjC9Tm3cAju5R7YU2XNlARAvVXoghbK5AR/sCmxYB5Uv80xy/hY94AKC0PEAM5wGb/wlk/J9q73Si+h6qhcKp3u2IWdHksZme9NwlctozbZbLsbt/nMf3ksXk/DLv9PTBqmtcO2EhoH0LAp+IsTPJH14hu30j9gS/vYZ03eEuu/Q38sGbxNpv5SLXfUJOSgicvvGk6hrXTli0gdKGAq0/sKasJjuBvGQAj3j2FZUCjaKti3fbHKD7OOvKM0NYtIHqWPjkMuAIvMQDADEF1sZb74S15ZkhPAT0onVlLR0AcIT3vsJF1sZb927zNqwiLAQUddC6ssqdwOxEwPm7+//iImBYJ2vjrbvS2vLMEDICmtXSPaodEQE8vAJYtQY4vBNwuoBlAn+RFzwPTLsU2JENlD4DpD/qn+fpGCDqSqDtbKBhI2Dlnf550icBJ6YAuw4BiTlAi0HifHwvA3AlA0c+BtZeA4zI8NTNE0vM2xeK6lb8GWQPMczbT2bFkyzwLzullz5bR9oHjuFoFLkgnazfTm4soUTIuHNle/EV3XMBufUu0jWg+vJ3axgri/kzmX+ThmB6kDvjyX77bQFZRiIFCucz8rcK/T7suC64zdjPyaIf9dtMaUb2f1VcbMPTVZ8pb0JGQNtzxFTwhgSSLuN+bB7hb7PzLLI0yVx8v4C88JT5+L7oqfpMeRMyAirJMlexkxuQ5U7zfpBk+mjyH7XJW64k3zxBOvLF2HU8Rc5NNhdn9iJ15ygQIdUTfV4ccPKQ/uO2XQd036Tae+3sTQc6/hNwLdN/rHMXUMviboWqsPwx/mhfYFNjYNt64LdNwIF4IC0NeKOPfvH0mgccc4WXeADg8lZA6Wrg3s/1Hzv5LSB9GnBgL/D7y8Avc4FN5QpH8a283PmOqpvZxvyJdITRoGNAniSnvi6uTlSM4kdZKda8LDF2pm0HnrscQD0rvZfAbOB5AM3rAMNGmzd3OBa41OIQLL2FXUagicOcjZlZwHNdAZxnpedy+dsoYOGD5u30mGe975Y3oteOAO54x9ixCfdY6akxLp4E9B4O3JgKXPUBEPMX7ce+PRAYZXAcbH4ZMKK+goCtvmdWbpLbzR9qW7e3yC9/JZ1R2urn2TXGyilZbPWZdKOkH+i9wepPrIpt/TXV143zP+T1r+uzOylBxVl0o2Q0vtcsFaWqp89W4P5+QFnr4Hlq9QCSdH4gcMNkhUFZJtUhZOkK8o8k8tqr1F8NVG7RL5M5l1RdXT9drN1eK5f7Rf3iVNKVbe0VSKqAMluRk0aTvTPVn7RQ3PK+rbr+xr5ksN31nvsLWCs+o5b3FLYbiHYCpZ0VXl5DnI49gZ0fAVEJgdNL3wei/2auDEdrIDJVXgzy2kBbgNIIeY7XBHb/B3h7cPD0BkOBmy4xVwYbyo1Baj/Qjnigm0T11xQKTwIxAXrV03YDra8wbverdUC/PnJ9l/oU1vUgkNhBbgA1gcVDAu9/zcTwxphb5IsHsKAn2rUG6LwL+P0F+cGEK5dsATKu8d5XdBRo1NyYvTqtgOISoK4F37NJ7weqNQD4+kf5gYQzh3sBZaO89y0qMW5vV11rxANYNBZWsQ+oe3ngtKmdgPGtgDqvAqnJwA2zgKxtnvR2kcDICd7H/PgosDLevF9Gxtb2r5JTR7lbgaY93X9XTgDqvOKd3vkiYFU3oOXtwKExwNVtgZLdgW0VxQANC+X46YfsfoK0E+So9YH7K9o8QTLJO/++Wv75dpd457n3oJh+mBQj/SQPkftvJQfVEdsnlPaEp4jPS/3Ti+t7u5HeNbitQRNPz5T2ra7IDCFFQMXdyU8jyNit1YzhXOF/rOOyABWyyjuPMAG9bSLI1eTcruIEVNTytN3pZNOHvdN6bQ3sQr3+VdtsmER+0FPu7LHCBbQkUXul9XrX//iC2wLnLX3Lk0eYgFLMxZq7R5yAnKfPxN55/mkRd5H0ebHfuUyf/VfzRJ9pN8Ib0aMaa8+7ZRjw/XTP/xVdgdGPBc6bc1T87Tuir7njGw0Q48fIH4Fap1ui2z72T2cS8OUc731LHq3OqjdPNxXjq79zgpm7V/+vr00R+UCXqvOURYq/Av0x1HicJPnzXEFXwpUem9s3BM83MJecv4j8yzX6yxj/qZwrkJQ20IJIsQ3Mjz/zti9MQEsNBLebzIkk32ktxodHXvKxv4zs8bTY+ntxMUlJo/TSHuOX5QD3mZyJ9I6NwPQjwJU+40UDU8U8xl9/rb78mQ8CqSPF1lPpFuB8n05E5/lA4hpgooCe5HldgbHbxfrshRxdulm70NgvZvxjZObVwe2KugKp3lKq+Szp5I/ksslk7Vhj9heaecrUiFQBkWSMjtvZ/O1k8UfV26wJAkreor0OXTPInzaRV2foK4N1ZJ9dyQLK1vjmYbMxZOVu7XbDWUD1HyLTvjRepykvk327aCtr3wSZZ9eNlLEwZxqwIB5ouVNb/oTNQNQ5MGr/yDag4E2g1W3GbbSZAMTeoS1vuxnAjD8DFZ3lxSRcQLvWA81SgZE63gNqYXDUOZzolgrM3gjUv8C8rabdtOed+ANQN7mKRfNMIlRA8zsBV/UFCnQ+PZwvqEMulNkeBzQeD6QI+LE06KX/mOtWyVm+U6iAXrrB2HERk8UHFqq0PQocMDmTBg3ORjJ9urHjqkKogOZuMXZc2V/FBxbKJHwKlD5m/PhTBn+o8yS0eIWaHLQdSPsZ6L1W33F5t4sPLNSZOkd73o1pwJf3e7Z8neOC8cOAPcuBsU4JgUh5tvsv+e9a2h9t49vrMx/Oj/Fnb3ldqo/12I3mylg0xr2QsCzkzA/UHhjgBIo7Ahf8t/rsB/cAWAlA0pNCMDZrjD7vYeDjEcDKHmLL/7ADML6aPDQxip59EGgRJ9Znfwcl02iStl9KuY6eWWHvAz2lL5Yj6eSF+eKuQNEZJAurLvOogbcb/tcTfbvssyt5coWFFwOFU7Xlzc+T/EsJxK36sje/FDjcErjsGn3HBaPkUiBvRdV5Dn9i3H5iTzF+VoU0Ac1dAAzRMaXd/p/kB+tLxC36jznvFLBA0FR9ALCnmlvUnqeM2352EjBhMIDnxPnri3gB7QemFABP6Hzt4QcJbxxWiwEBAcANOwDMFOPChszgaacOAg/HmLP/ynJg+HTAtUOMv36IvidOWmXsft2ypfYyhL1Q9qrxOBf1EdcW+i6fpM+L88eakSMGiivjoSOiz7Qb4S+UNXkWKEg0dmznxdrz7hIwKeX6x6vPE5MCdPnOf/+Bu4GEJPM+nKFeP2AUgOi2wIYkYGOGONtncOUBEU3E2hQuoG/6A/2+Eh+8ShzZQKTP25XlLYH6R1R7pp2PWwMPSpjoQngb6NYvgcpmwKa1wO01eJC0XjYQY3LuHtn0zgK+eRco7y9HPADk9wMVjiRnUH2vr5nNEeSF9Mf/rt63QNuTiWTuNNlnVlIbKBDOPwFRKvp5BBHoFgYASYnA3c+q9s6fknVAAwumdgEsmqk+9VNrgrGaLoK/0BDFnmesK0u6gCoI9JD5WYlCLrZwPXs99PgVKD5uTVnSBfR8XaDQwl+EldTKAYZIbwAYY+hPAFzyy5HaBvo+GejTWX4QsgnWBgKAQ52AuN9UexiYTxzAfZFyy5B3BWpVM8RTHa2TgVETVXsRmPujgIokuWXIE1A6EGdwVZ5w47VeQNRdqr0ITFSZXPtSb2HHmwKrC4Et7wPf/BXICNM1vqq6hZ0h6xjQZgdQbnCAVhTN2gP9XECvr4A7rwaa5Uou0JruJjeOX8n8MnLgneo72/Rszkht8RVPI4coWAek+9Nk7hKyMtnKs+lGyarNKT2Btj9rzz94HfCaia8YzFDvBaDxUH3HVJ4EctsZL/NfvYGXl2rP/0M2cKPJmVAMY71mydlL9f/K5txftc3K5WTFLhXRiGXZav11M3amOn8tF1D5W8Yv1au7um24niRzd5Ab3icnZ5Dt3vXkuc9JnmisrkIDUTCGHNuerD2ejJtFPteFXD+AzEklnYc9+Ta8YbxujikSkeUCWjbG3P2+n4aXyTo8qqYyA3GqN1m7Y9X+9rmJfLO3uXqZFa0mPkvbQK7jQGQfALJerzyL1NZA6xBY6GW1A7intjVlnVwM1HvA2vgsXfIyZRAsEQ8A7FhvZWTBWbPBurK2yfjytBosFdDFgq91LesCdweZ7vZrk1P4CiEPWBjktdnm94kvLmGRghitvmeW9iX3ZpCp68jMYjJ3Kln4JLnyZn33/FWDSDrdNstnkI/69L9E5pE8rqZdcIbi7/39njKbrDjdr1R4KXnnQ/rinl+HLMwm8+qTWa+Qhx4j9y0gC6eqiVHJY3xATpJRE7VVYseR/ocff8E/X8llakPa2dzHp0Ok02dizfzD+gTkcKqNyRcly34Hovh6wPGytry9X/TfFz3Gf98f36qNaXOa9//3PQ7U8lmZsHETIErH7P7ZyWpj8iVkBLRHx9JLyyYBLp+5iLIr/PNtvVFtTEnDvP//7HcAnbz3lXUDHDrW9volU3teKwgZAX03XHve4+8AL84FKoYDyANyZgD3BnhkX70ZKNyt3a5ISuYB63zWvajMAt7vB7DQ/X9FbWC8ztkzksrVxBMU1ffQM8QPN9iJdqj6PA8lk78+RjpbyI3BdT+5uyM5clT1Pt0yw3inYSihZDA1EBFBlgiPmqi9baSFcZ2BwWOBKy4HGgiYZaOsCNjbCFhxAph5vjg/63cDTgZ5lzw0ztj/nAkNPsp0/7rih5MvFZBbZ5DHu5M8qf8RX+sWM5p8PJZcEkP+kkEe3ksef4Us/8j9aoTjZ9KRQJ5qRxYPI7OuJncUk8tqk2OdZIsP5Pg17/QKjSVZ5PYcMpHkle3daYmSr6J6CZkrUFUU/QNo9LpqL6zj0CEgNla1F9oImUZ0VVReqNoDa6mw6KNAEYSFgCrGqfbAWso/VO2BdsJDQNvM2wgnyitVe6CdsBDQqSBfgM5eChzoAQy8U7WH+rj2C2DvVcB7gwOnl4fTxOuqW/FaKO171lNKV/dLaeVnreKcXybnaUjW9keSx/fKTeQXw8kmDk96Th/VNa6dsHgKA4ATNwOZEcBlK4BaDb3TnDuBqC6qPdRO6Qrg/IE+O0cCKRFA04uAGAmLosgibARUHa1Ohs93ZxwCIIwaylURFm0gLdy63H9fo0TgwPeAoykww6Kfyahk4NQRIOtm4IqX/NN7Z6LGiAdAeLSBtPChz9qs42uTp1ye9MKRVbdLtM6oH3NB1elpJzxlOv9NJnbwTp80WnVNiaXGCKioCRn3jvskrd8VOM/tAwKf9I8ucqcXd6haHNmnF0cJthp17NbA5W6PI5FMNthFZrZSXVNiqTEC0sKmtf4nfc587zzBVhmaH+edb+kR/zyfRqiO0HpqTCNaC47mQO2zZsSfnA9M8X0bcA9wbRqw+aw1zBqvB47GAZGx3lnfiQJGnPUlRHF3IPoc6/SUs9xTiBKVA3zdH3jgCmBUT2BKPgBfAbUHlpQCsWftWkd/8QDAcAdQvg94YQvwrwIgurq1m2og59QVSA8rugHjegEvbARGhth7yKGELSAbU9SYfiAbNdgCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU9gCsjGFLSAbU/w/IpTqp4TSsCgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMTEtMTFUMDE6MzQ6MTMrMDA6MDAnCoLDAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTExLTExVDAxOjM0OjEzKzAwOjAwVlc6fwAAAABJRU5ErkJggg==\n    \nEVCXR_END_CONTENT\"#);\n\n\n\n\nまた，fn evcxr_display(&self)となる関数（トレイト？）を任意の型に対して実装することで，その型をNotebookに出力することが可能となります． 以下に，image::RgbImageに対して，fn evcxr_display(&self)を実装した例を示します．\n\n:dep image = \"0.23\"\n\n//From Tour of the EvCxR Jupyter Kernel\n//https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb\nextern crate image;\nextern crate base64;\npub trait EvcxrResult {fn evcxr_display(&self);}\nimpl EvcxrResult for image::RgbImage {\n    fn evcxr_display(&self) {\n        let mut buffer = Vec::new();\n        image::png::PNGEncoder::new(&mut buffer).encode(&**self, self.width(), self.height(),\n            image::ColorType::Rgb8).unwrap();\n        let img = base64::encode(&buffer);\n        println!(\"EVCXR_BEGIN_CONTENT image/png\\n{}\\nEVCXR_END_CONTENT\", img);        \n    }\n}\n\nimage::ImageBuffer::from_fn(256, 256, |x, y| {\n    if (x as i32 - y as i32).abs() < 3 {\n        image::Rgb([0, 0, 255])\n    } else {\n        image::Rgb([0, 0, 0])\n    }\n})\n\nThe type of the variable figure was redefined, so was lost."
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#plottersによるグラフの描画",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#plottersによるグラフの描画",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "plottersによるグラフの描画",
    "text": "plottersによるグラフの描画\nplottersとはRustで記述されたグラフを描画するためのCrateです．詳細については，まだ作成途中とのことですが，こちらの資料に詳しくまとまっていました．また，日本語の資料としては，こちらの記事が大変わかりやすくまとまっていました．\n以下に，プロット機能を用いて二次関数とマンデルブロ集合を描画する礼を示します．\n\n:dep plotters = { git = \"https://github.com/38/plotters\", default_features = true, features = [\"evcxr\"] }\n\n\n// From Plotters Tutorial with Jupyter\n// https://plotters-rs.github.io/plotters-doc-data/evcxr-jupyter-integration.html\n\nextern crate plotters;\nuse plotters::prelude::*;\n\nevcxr_figure((640, 480), |root| {\n    root.fill(&WHITE);\n    let mut chart = ChartBuilder::on(&root)\n        .caption(\"y=x^2\", (\"Arial\", 50).into_font())\n        .margin(5)\n        .x_label_area_size(30)\n        .y_label_area_size(30)\n        .build_ranged(-1f32..1f32, -0.1f32..1f32)?;\n\n    chart.configure_mesh().draw()?;\n\n    chart.draw_series(plotters::series::LineSeries::new(\n        (-50..=50).map(|x| x as f32 / 50.0).map(|x| (x, x * x)),\n        &RED,\n    )).unwrap()\n        .label(\"y = x^2\")\n        .legend(|(x,y)| PathElement::new(vec![(x,y), (x + 20,y)], &RED));\n\n    chart.configure_series_labels()\n        .background_style(&WHITE.mix(0.8))\n        .border_style(&BLACK)\n        .draw()?;\n    Ok(())\n})\n\nFontconfig error: Cannot load default config file\nFontconfig error: Cannot load default config file\nFontconfig warning: ignoring C.UTF-8: not a valid language tag\n\n\n\n\n\ny=x^2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n\n0.2\n\n\n\n0.4\n\n\n\n0.6\n\n\n\n0.8\n\n\n\n\n-0.8\n\n\n\n-0.6\n\n\n\n-0.4\n\n\n\n-0.2\n\n\n\n0.0\n\n\n\n0.2\n\n\n\n0.4\n\n\n\n0.6\n\n\n\n0.8\n\n\n\n1.0\n\n\n\n\n\n\ny = x^2\n\n\n\n\n\n\n\n// From mandelbrot.rs\n// https://github.com/38/plotters/blob/master/examples/mandelbrot.rs\n\nuse plotters::prelude::*;\nuse std::ops::Range;\n\nfn mandelbrot_set(\n    real: Range<f64>,\n    complex: Range<f64>,\n    samples: (usize, usize),\n    max_iter: usize,\n) -> impl Iterator<Item = (f64, f64, usize)> {\n    let step = (\n        (real.end - real.start) / samples.0 as f64,\n        (complex.end - complex.start) / samples.1 as f64,\n    );\n    return (0..(samples.0 * samples.1)).map(move |k| {\n        let c = (\n            real.start + step.0 * (k % samples.0) as f64,\n            complex.start + step.1 * (k / samples.0) as f64,\n        );\n        let mut z = (0.0, 0.0);\n        let mut cnt = 0;\n        while cnt < max_iter && z.0 * z.0 + z.1 * z.1 <= 1e10 {\n            z = (z.0 * z.0 - z.1 * z.1 + c.0, 2.0 * z.0 * z.1 + c.1);\n            cnt += 1;\n        }\n        return (c.0, c.1, cnt);\n    });\n}\n\nevcxr_figure((640, 480), |root| {\n    root.fill(&WHITE);\n\n    let mut chart = ChartBuilder::on(&root)\n        .margin(20)\n        .x_label_area_size(10)\n        .y_label_area_size(10)\n        .build_cartesian_2d(-2.1f64..0.6f64, -1.2f64..1.2f64)?;\n\n    chart\n        .configure_mesh()\n        .disable_x_mesh()\n        .disable_y_mesh()\n        .draw()?;\n\n    let plotting_area = chart.plotting_area();\n\n    let range = plotting_area.get_pixel_range();\n\n    let (pw, ph) = (range.0.end - range.0.start, range.1.end - range.1.start);\n    let (xr, yr) = (chart.x_range(), chart.y_range());\n\n    for (x, y, c) in mandelbrot_set(xr, yr, (pw as usize, ph as usize), 100) {\n        if c != 100 {\n            plotting_area.draw_pixel((x, y), &HSLColor(c as f64 / 100.0, 1.0, 0.5))?;\n        } else {\n            plotting_area.draw_pixel((x, y), &BLACK)?;\n        }\n    }\n    Ok(())\n})\n\nFontconfig error: Cannot load default config file\nFontconfig error: Cannot load default config file\nFontconfig warning: ignoring C.UTF-8: not a valid language tag\n\n\n\n\n\n\n-1.0\n\n\n\n-0.5\n\n\n\n0.0\n\n\n\n0.5\n\n\n\n1.0\n\n\n\n\n-2.0\n\n\n\n-1.5\n\n\n\n-1.0\n\n\n\n-0.5\n\n\n\n0.0\n\n\n\n0.5"
  },
  {
    "objectID": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#参考",
    "href": "posts/2020-11-15-rust-on-nodebook-with-evcxr-jupyter.html#参考",
    "title": "evcxr_jupyter - Rust on Notebook",
    "section": "参考",
    "text": "参考\n\n\n[1] Evcxr. GitHub repository. https://github.com/google/evcxr; GitHub.\n\n\n[2] Jupyter-lang. GitHub repository. https://github.com/HeRoMo/jupyter-langs; GitHub.\n\n\n[3] RustのドローイングライブラリPlottersの紹介. https://lab.mo-t.com/blog/rust-plotters."
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "",
    "text": "Raspberry Pi 4+k3sで構築したクラスタに関するメモです．"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#やったこと",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#やったこと",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "やったこと",
    "text": "やったこと\n\nPC(master) + Raspberry Pi 4(worker)という構成でk3sクラスタを構築\ngrafana + ptometheus + loki + node-exporter + promtailという構成で監視基盤を構築"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#role関連の設定",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#role関連の設定",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "Role関連の設定",
    "text": "Role関連の設定\nクラスタの監視を行うためには適切にサービスディスカバリを行う必要があります．そこで，サービスディスカバリに必要な権限を持つClusterRoleと対応するServiceAccountを定義します． /metricsにアクセスするためにはRoleではなくClusterRoleである必要があるようです．(monitoringネームスペース外にアクセスするから？)\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: monitoring\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: monitoring\nrules:\n- apiGroups: [\"\"]\n  resources:\n  - nodes\n  - nodes/proxy\n  - services\n  - endpoints\n  - pods\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups:\n  - extensions\n  resources:\n  - ingresses\n  verbs: [\"get\", \"list\", \"watch\"]\n- nonResourceURLs: [\"/metrics\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: monitoring\nroleRef:\n  kind: ClusterRole\n  name: monitoring\n  apiGroup: rbac.authorization.k8s.io\nsubjects:\n- kind: ServiceAccount\n  name: monitoring\n  namespace: monitoring\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: monitoring\n  namespace: monitoring"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#promtailの導入",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#promtailの導入",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "promtailの導入　",
    "text": "promtailの導入　\nとりあえず，ホストのログ(/var/log/*log)をmasterで稼働しているlokiに送信します．各podのログ収集については中途半端な設定となっています．（多分動かない） 各ログにはhostnameタグにホスト名を設定しています．これは，spec.nodeNameを環境変数NODE_NAMEに設定し，起動引数に--client.external-labels=hostname=$(NODE_NAME)を追加することで実現しています．\nlokiはk3sクラスタ内ではなく，master上のDockerコンテナとしてホストされています．また，promtailはworkerとmaster両ノードにデプロイされます． そのため，両環境下から\bk3s-masterの名前解決を行うため，dnsPolicyをNoneとして明示的にdnsサーバーを設定しています． これは，ClusterFirstではクラスタ外にあるk3s-masterの名前解決を行うことができず，Defaultではworkerとmasterとで共通の舐め解決設定を作り出すことができなかったためです．\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: promtail-config\n  namespace: monitoring\ndata:\n  config.yaml: |\n    server:\n      http_listen_port: 9080\n      grpc_listen_port: 0\n    positions:\n      filename: /tmp/positions.yaml\n    clients:\n      - url: http://k3s-master:3100/loki/api/v1/push\n    scrape_configs:\n    - job_name: system\n      static_configs:\n      - targets:\n          - localhost\n        labels:\n          job: varlogs\n          __path__: /var/log/*log\n    - job_name: kubernetes-pods-app\n      kubernetes_sd_configs:\n      - role: pod\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: promtail\n  namespace: monitoring\nspec:\n  selector:\n    matchLabels:\n      app: promtail\n  template:\n    metadata:\n      labels:\n        app: promtail\n    spec:\n      dnsPolicy: None\n      dnsConfig:\n        nameservers:\n          - 10.0.100.1\n      serviceAccountName: monitoring\n      containers:\n      - name: promtail\n        image: grafana/promtail:latest\n        env:\n        - name: TZ\n          value: Asia/Tokyo\n        - name: NODE_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: spec.nodeName\n        args:\n        - --config.file=/etc/promtail/config.yaml \n        - --client.external-labels=hostname=$(NODE_NAME)\n        ports:\n        - name: webui\n          containerPort: 9080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/promtail\n        - name: varlog\n          mountPath: /var/log\n        - name: secret-volume\n          mountPath: /var/run/secrets\n        - name: run\n          mountPath: /run/promtail\n      volumes:\n      - name: config-volume\n        configMap:\n          name: promtail-config\n      - name: varlog\n        hostPath:\n          path: /var/log\n      - name: secret-volume\n        hostPath:\n          path: /var/run/secrets\n      - name: run\n        hostPath:\n          path: /run/promtail"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#node-exporterの導入",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#node-exporterの導入",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "node-exporterの導入",
    "text": "node-exporterの導入\nnode-exporterもworkerとmaster両環境にデプロイされます．\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: node-exporter\n  namespace: monitoring\nspec:\n  selector:\n    matchLabels:\n      app: node-exporter\n  template:\n    metadata:\n      labels:\n        app: node-exporter\n      annotations:\n        prometheus.io/scrape: 'true'\n        prometheus.io/port: '9100'\n        prometheus.io/path: /metrics\n    spec:\n      dnsPolicy: Default\n      serviceAccountName: monitoring\n      containers:\n      - name: node-exporter\n        image: prom/node-exporter:latest\n        env:\n        - name: TZ\n          value: Asia/Tokyo\n        - name: NODE_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: spec.nodeName\n        args:\n        - --path.procfs=/host/proc\n        - --path.sysfs=/host/sys\n        - --collector.filesystem.ignored-mount-points\n        - ^/(sys|proc|dev|host|etc|rootfs/var/lib/docker/containers|rootfs/var/lib/docker/overlay2|rootfs/run/docker/netns|rootfs/var/lib/docker/aufs)($$|/)\n        ports:\n        - containerPort: 9100\n          name: http\n        volumeMounts:\n        - name: proc\n          mountPath: /host/proc\n        - name: sys\n          mountPath: /host/sys\n        - name: rootfs\n          mountPath: /rootfs\n      volumes:\n      - name: proc\n        hostPath:\n          path: /proc\n      - name: sys\n        hostPath:\n          path: /sys\n      - name: rootfs\n        hostPath:\n          path: /rootfs"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#lokiprometheusgrafanaの導入",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#lokiprometheusgrafanaの導入",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "loki，prometheus，grafanaの導入",
    "text": "loki，prometheus，grafanaの導入\nこれらのソフトウェアはDockerコンテナとしてホストされています．docker-compose.ymlは以下の通りです．\nversion: \"3.2\"\n\nnetworks:\n  monitoring:\n\nservices:\n  loki:\n    image: grafana/loki:latest\n    ports:\n      - \"3100:3100\"\n    command: -config.file=/etc/loki/local-config.yaml\n    volumes:\n      - type: bind\n        source: ./loki/local-config.yml\n        target: /etc/loki/local-config.yaml\n    networks:\n      - monitoring\n    restart: always\n\n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - type: bind\n        source: ./grafana/provisioning\n        target: /etc/grafana/provisioning\n      - type: volume\n        source: grafana_data\n        target: /var/lib/grafana\n    networks:\n      - monitoring\n    restart: always\n\nvolumes:\n  grafana_data:\nlocal-config.yamlは以下の通りです．デフォルトから特に変更していなかったと思います．\nauth_enabled: false\n\nserver:\n  http_listen_port: 3100\n\ningester:\n  lifecycler:\n    address: 127.0.0.1\n    ring:\n      kvstore:\n        store: inmemory\n      replication_factor: 1\n    final_sleep: 0s\n  chunk_idle_period: 1h       # Any chunk not receiving new logs in this time will be flushed\n  max_chunk_age: 1h           # All chunks will be flushed when they hit this age, default is 1h\n  chunk_target_size: 1048576  # Loki will attempt to build chunks up to 1.5MB, flushing first if chunk_idle_period or max_chunk_age is reached first\n  chunk_retain_period: 30s    # Must be greater than index read cache TTL if using an index cache (Default index read cache TTL is 5m)\n  max_transfer_retries: 0     # Chunk transfers disabled\n\nschema_config:\n  configs:\n    - from: 2020-10-24\n      store: boltdb-shipper\n      object_store: filesystem\n      schema: v11\n      index:\n        prefix: index_\n        period: 24h\n\nstorage_config:\n  boltdb_shipper:\n    active_index_directory: /loki/boltdb-shipper-active\n    cache_location: /loki/boltdb-shipper-cache\n    cache_ttl: 24h         # Can be increased for faster performance over longer query periods, uses more disk space\n    shared_store: filesystem\n  filesystem:\n    directory: /loki/chunks\n\ncompactor:\n  working_directory: /loki/boltdb-shipper-compactor\n  shared_store: filesystem\n\nlimits_config:\n  reject_old_samples: true\n  reject_old_samples_max_age: 168h\n\nchunk_store_config:\n  max_look_back_period: 0s\n\ntable_manager:\n  retention_deletes_enabled: false\n  retention_period: 0s\n\nruler:\n  storage:\n    type: local\n    local:\n      directory: /loki/rules\n  rule_path: /loki/rules-temp\n  alertmanager_url: http://localhost:9093\n  ring:\n    kvstore:\n      store: inmemory\n  enable_api: true"
  },
  {
    "objectID": "posts/2021-08-21-k3s-cluster-on-rp4.html#参考",
    "href": "posts/2021-08-21-k3s-cluster-on-rp4.html#参考",
    "title": "k3sクラスタ on Raspberry Pi 4",
    "section": "参考",
    "text": "参考\n\nLokiとpromtailことはじめ\nKubernetesの全NodeをPrometheusで監視する方法"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "",
    "text": "USBハブとUSBシリアルコンバータとを組み合わせることで，USB(1ch) to TTL(4ch) の変換ケーブルを作成しました．"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#やったこと",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#やったこと",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "やったこと",
    "text": "やったこと\n\ntype-cコネクタ，USBハブコントローラ基板，USBシリアルコンバータを組み合わせてUSB(1ch) to TTL(4ch)変換ケーブルを作成"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#回路設計",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#回路設計",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "回路設計",
    "text": "回路設計\n特別なことは特に何もしていません．CH330のデータシートに従って単純に部品を繋いで行きました．type-cコネクタはVCC端子より5vを取得するため， ccを5.1kΩでプルダウンしています．\n今回，EasyEDAを使って回路図を起こしてみたのですが中々使い勝手がよかったです．ブラウザ内で全てが完結するので環境構築が非常に簡単です．私は使用しませんでしたがPCBエディタとの連携機能もあるようです．また，各種ボード(USB1とHUB1)とケーブル(TTL1からTTL4)のピン番号はシステムの都合上割り当てています．そのため，実際にはピン番号はありません．何か良い方法があると良いのですが．"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#実装",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#実装",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "実装",
    "text": "実装\n可能な限りケーブルの様に使いたかったので，USBハブコントローラ背面にカプトンテープを貼り，その上にUSBシリアルコンバータを実装しました．\n\n次にケーブルを取り付け全体をグルーガンで固定します．\n\n最後に熱収縮ケーブルで全体をさらに固定して完成です．"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#動作確認",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#動作確認",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "動作確認",
    "text": "動作確認\nlsusbコマンドを実行すると以下のデバイスを確認できました．意図した通りに動作しているようです．\nBus 020 Device 018: ID 1a40:0101 TERMINUS TECHNOLOGY INC. USB 2.0 Hub\nBus 020 Device 021: ID 1a86:7523 1a86 USB2.0-Serial\nBus 020 Device 029: ID 1a86:7523 1a86 USB2.0-Serial\nBus 020 Device 024: ID 1a86:7523 1a86 USB2.0-Serial\nBus 020 Device 010: ID 1a86:7523 1a86 USB2.0-Serial"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#後から気が付いたこと",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#後から気が付いたこと",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "後から気が付いたこと",
    "text": "後から気が付いたこと\n今回はUSBハブとUSBシリアルコンバータとを組み合わせて所望の機能を実現しました．しかしながら，調べてみると同様の機能をワンチップで実現するICがあるようです．次に同様のものを作る時はこちらを使いたいですね．"
  },
  {
    "objectID": "posts/2021-08-26-make-usb-to-ttlx4.html#参考",
    "href": "posts/2021-08-26-make-usb-to-ttlx4.html#参考",
    "title": "USB to TTLx4ケーブルの作成",
    "section": "参考",
    "text": "参考\n\nUSB 转串口芯片 CH330\n組込み技術ラボ"
  },
  {
    "objectID": "posts/2022-11-05-develop-octoprint-plugin.html",
    "href": "posts/2022-11-05-develop-octoprint-plugin.html",
    "title": "OctoPrintのプラグインを作ってみる",
    "section": "",
    "text": "OctoPrintからSwitchBot PlugのOn/Offを制御するプラグインを作ってみました。 今回、このプラグインの作成を通してハマった点のメモを残しておきます。"
  },
  {
    "objectID": "posts/2022-11-05-develop-octoprint-plugin.html#やったこと",
    "href": "posts/2022-11-05-develop-octoprint-plugin.html#やったこと",
    "title": "OctoPrintのプラグインを作ってみる",
    "section": "やったこと",
    "text": "やったこと\n\nOctoPrintからSwitchBot PlugのOn/Offを制御するプラグインを作成"
  },
  {
    "objectID": "posts/2022-11-05-develop-octoprint-plugin.html#作ったものについて",
    "href": "posts/2022-11-05-develop-octoprint-plugin.html#作ったものについて",
    "title": "OctoPrintのプラグインを作ってみる",
    "section": "作ったものについて",
    "text": "作ったものについて\n常時3Dプリンタを起動しているのは無駄なので、電源の管理にSwitchBot Plugを使ってみました。スマホからSwitchBot Plugを操作することはできるのですが、折角なのでOctoPrintから操作したいと思いプラグインを作成しました。\n\n\n\n\n\nこのプラグインを導入すると、以下の様にSwitchBot PlugのOn/Offを制御するボタンがサイドバーに出現します。\n\n仕組みとしては、シンプルにフロントエンドのボタン押下に応じてSwitchBot APIを叩くだけです。SwitchBot APIはサーバー側から呼び出しています。後から振り返ってみると、フロントエンド側から直接SwitchBot APIを叩いても良かったかなと思っています。"
  },
  {
    "objectID": "posts/2022-11-05-develop-octoprint-plugin.html#octoprintプラグインについて",
    "href": "posts/2022-11-05-develop-octoprint-plugin.html#octoprintプラグインについて",
    "title": "OctoPrintのプラグインを作ってみる",
    "section": "OctoPrintプラグインについて",
    "text": "OctoPrintプラグインについて\nOctoPrintプラグインの作成については、Plugin Tutorialを参考にするのが手っ取り早いと思います。 このチュートリアルでは、プラグインの保存先として~/.octoprint/pluginsが紹介されています。 しかしながら、私の環境では上記ディレクトリに配置したプラグインは読み込まれませんでした。 その様な場合、プラグインの保存先ディレクトリはOctoPrintのブートログから確認することができます。\n...\n\n2022-11-02 01:18:22,845 - octoprint.util.connectivity.connectivity_checker - INFO - Resolving octoprint.org is working\n2022-11-02 01:18:22,846 - octoprint.plugin.core - INFO - Loading plugins from /Users/argon/workspace/OctoPrint/src/octoprint/plugins, /Users/argon/Library/Application Support/OctoPrint/plugins and installed plugin packages...\n2022-11-02 01:18:23,148 - octoprint.plugin.core - INFO - Plugin Pi Support Plugin (2022.6.13) did not pass check, not loading.\n\n...\nまた、上記チュートリアルで作成するプラグインはフロントエンド側の処理のみで完結しています。 そこで、ここではサーバー側との連携について少しだけメモを残しておくことにします。\n\nサーバー側で処理を行う\nOctoPrintプラグインにおいて、フロントエンド<->サーバー間の連携は単純にWebAPIを介して行われます。 サーバー側で処理を行う場合、以下の何かのクラスを継承して必要なメソッドを実装します。\n\noctoprint.plugin.SimpleApiPlugin\noctoprint.plugin.BlueprintPlugin\n\n前者は、GETとPOSTに応じたget_api_commandsとon_api_commandとを実装することでAPIを提供します。 後者はFlaskのBlueprintを利用してAPIを提供します。\n今回は以下の様にBlueprintPluginを継承してAPIを提供しています。\nclass SwitchBotPlugPlugin(\n    octoprint.plugin.SettingsPlugin,\n    octoprint.plugin.AssetPlugin,\n    octoprint.plugin.TemplatePlugin,\n    octoprint.plugin.BlueprintPlugin,\n):\n\n    ...\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/turnon\", methods=[\"POST\"])\n    def turnon(self):\n        self._logger.info(\"turnon\")\n        ...\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/turnoff\", methods=[\"POST\"])\n    def turnoff(self):\n        self._logger.info(\"turnoff\")\n        ...\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/status\", methods=[\"GET\"])\n    def status(self):\n        self._logger.info(\"status\")\n        ...\n\n\nJavaScript Clientについて\nサーバー側から提供されるのは単純なWeb APIであるため、フロントエンドからはfetchやaxiosなどを用いて呼び出すことももちろん可能です。 しかしながら、OctoPrintではOctoPrintClientというクラスが提供されており、準備したWeb API用のクライアントをinjectionして、このクラスを経由して使用することが推奨されてるようです。\n以下にサンプルコードを参考に自作プラグイン用クライアントをinjectionする例を示します。\n(function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"OctoPrintClient\"], factory);\n    } else {\n        factory(window.OctoPrintClient);\n    }\n})(window || this, function(OctoPrintClient) {\n    var SwitchBotPlug = function(base) {\n        this.base = base;\n        this.baseUrl = OctoPrint.getBlueprintUrl(\"switchbot_plug\");\n    };\n\n    SwitchBotPlug.prototype.turnon = function() {\n        const url = `${this.baseUrl}/turnon`;\n        return OctoPrint.post(url, {}, {contentType: \"application/json\"});\n    };\n\n    SwitchBotPlug.prototype.turnoff = function() {\n        const url = `${this.baseUrl}/turnoff`;\n        return OctoPrint.post(url, {}, {contentType: \"application/json\"});\n    };\n\n    SwitchBotPlug.prototype.status = function() {\n        const url = `${this.baseUrl}/status`;\n        return OctoPrint.get(url)\n    };\n\n    OctoPrintClient.registerPluginComponent(\"switchbot_plug\", SwitchBotPlug);\n    return SwitchBotPlug;\n});"
  },
  {
    "objectID": "posts/2022-11-05-develop-octoprint-plugin.html#参考",
    "href": "posts/2022-11-05-develop-octoprint-plugin.html#参考",
    "title": "OctoPrintのプラグインを作ってみる",
    "section": "参考",
    "text": "参考\n\n\n[1] Häußge, G. 2022. OctoPrint. https://docs.octoprint.org/en/master/."
  },
  {
    "objectID": "posts/2022-11-30-pypypy.html",
    "href": "posts/2022-11-30-pypypy.html",
    "title": "ほとんどPythonで作るWebアプリケーション",
    "section": "",
    "text": "少し前にGoでWebアプリを作成するgogogoというプロジェクトに倣って、 ほとんどPythonのみでWebアプリケーションを作成してみました。"
  },
  {
    "objectID": "posts/2022-11-30-pypypy.html#やったこと",
    "href": "posts/2022-11-30-pypypy.html#やったこと",
    "title": "ほとんどPythonで作るWebアプリケーション",
    "section": "やったこと",
    "text": "やったこと\n\npypypyというPythonによるWebアプリケーションを作成"
  },
  {
    "objectID": "posts/2022-11-30-pypypy.html#作ったものについて",
    "href": "posts/2022-11-30-pypypy.html#作ったものについて",
    "title": "ほとんどPythonで作るWebアプリケーション",
    "section": "作ったものについて",
    "text": "作ったものについて\nWebsocketでメッセージをやり取りするシンプルなチャットを作成しました。\ndemo\n\n\nフロントエンド\nフロントエンドはalfort-domというElm-likeな自作フレームワークを使用しています。 CSSは得意では無いため、MVP.cssを使用しています。\n\n\nバックエンド\nApigateway + Lambdaという構成です。ほぼほぼサンプルのチャットアプリケーションをそのまま流用しています。\n\n\nインフラ\n構成管理にはAWS CDKを使用しています。構成管理の設定はdeploy.pyというファイルに必要なスタックをベタ書きしています。"
  },
  {
    "objectID": "posts/2022-11-30-pypypy.html#参考",
    "href": "posts/2022-11-30-pypypy.html#参考",
    "title": "ほとんどPythonで作るWebアプリケーション",
    "section": "参考",
    "text": "参考\n\n\n[1] Annoy. GitHub repository. https://github.com/koki-develop/gogogo; GitHub."
  },
  {
    "objectID": "posts/2021-01-06-install-starship.html",
    "href": "posts/2021-01-06-install-starship.html",
    "title": "starshipの導入",
    "section": "",
    "text": "startshipを使用するためには，事前にNerdFontを導入する必要があります． そこで，今回はCicaを使用しました． 導入はリリースページから配布されているアーカイブをダウンロードしttfファイルをダブルクリックで完了です．"
  },
  {
    "objectID": "posts/2021-01-06-install-starship.html#startshipを導入する",
    "href": "posts/2021-01-06-install-starship.html#startshipを導入する",
    "title": "starshipの導入",
    "section": "startshipを導入する",
    "text": "startshipを導入する\nbrewを使ってstartshipを導入します．\n$ brew install starship\n以下のように良い感じです．"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html",
    "href": "posts/2022-10-24-simple-voice-changer.html",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "",
    "text": "音声の生成過程をソースとフィルタによってモデル化する手法として、ソースフィルタモデル[4]が知られています。 今回、このフィルタをARモデルを用いて実装し、ソースフィルタモデルによるシンプルなボイスチェンジャを作成しました。"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#やったこと",
    "href": "posts/2022-10-24-simple-voice-changer.html#やったこと",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "やったこと",
    "text": "やったこと\n\nARモデルを用いてスペクトル包絡を推定\nそのスペクトル包絡を用いてボイスチェンジャを実装"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#ソースフィルタモデルによる音声合成",
    "href": "posts/2022-10-24-simple-voice-changer.html#ソースフィルタモデルによる音声合成",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "ソースフィルタモデルによる音声合成",
    "text": "ソースフィルタモデルによる音声合成\nソースフィルタモデルは、音声の生成仮定をソースとフィルタによってモデル化します。 ここで、ソースとは声帯による生成音を、フィルタとは声道による音響的な変化をそれぞれ表します。 この時、ソースとフィルタの関係を線形であると仮定すると、以下の様に表現することができます。\n\\[\nY\\left(z\\right) = H\\left(z\\right)X\\left(z\\right)\n\\]\n上式において、\\(Y\\left(z\\right)\\)は音声信号を、\\(X\\left(s\\right)\\)はソースを、\\(H\\left(z\\right)\\)はフィルタをそれぞれ表します。 また、フィルタ\\(H\\left(z\\right)\\)はスペクトル包絡を、ソース\\(X\\left(z\\right)\\)は基本周波数成分をそれぞれ表現していると考えることができます。"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#arモデルによるフィルタの実装",
    "href": "posts/2022-10-24-simple-voice-changer.html#arモデルによるフィルタの実装",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "ARモデルによるフィルタの実装",
    "text": "ARモデルによるフィルタの実装\nソースフィルタモデルにおけるフィルタの実装方法には様々な手法ががあります。 ここでは、シンプルな手法であるARモデル[3]を用いました。 ARモデルは、以下の様に表現することができます。\n\\[\ny\\left(n\\right) = \\sum_{k=1}^{p}a_{k}y\\left(n-k\\right) + \\epsilon\\left(n\\right)\n\\]\nここで、\\(y\\left(n\\right)\\)はフィルタの出力および観測信号を、\\(a_{k}\\)はAR係数を、\\(\\epsilon\\left(n\\right)\\)はノイズをそれぞれ表します。 一般的に、AR係数の推定は誤差\\(e\\left(n\\right)\\)を最小化するように行われます。 このAR係数の推定には様々な手法があります。最も単純な方法は、以下の様にN個の関係式から最小二乗法を用いて推定する方法です。\n\\[\\begin{align}\n\\mathbf{y}&=\n\\begin{pmatrix}\ny\\left(p\\right) \\\\\ny\\left(p + 1\\right) \\\\\n\\vdots \\\\\ny\\left(N - 1\\right) \\\\\n\\end{pmatrix} \\\\\n&= \\begin{pmatrix}\ny\\left(p - 1\\right) &  \\cdots & y\\left(0\\right) \\\\\n\\vdots & \\ddots & \\vdots \\\\\ny\\left(N - 2\\right) &  \\cdots & y\\left(N - 1 - p\\right) \\\\\n\\end{pmatrix}\n\\begin{pmatrix}\na_{1} \\\\\n\\vdots \\\\\na_{p} \\\\\n\\end{pmatrix}\\\\\n&= \\mathbf{D} \\mathbf{a} \\\\\n\\mathbf{a} &= \\left(\\mathbf{D}^{T}\\mathbf{D}\\right)^{-1}\\mathbf{D}^{T}\\mathbf{y}\n\\end{align}\\]\nしかしながら、この最小二乗法によって推定されたAR係数は必ずしも安定ではありません。 そのため、自己相関関数を用いてAR係数を推定する方法がよく用いられます。 自己相関法では、以下の様に定義する信号\\(y'\\left(n\\right)\\)を用いてAR係数の推定を行います。\n\\[\\begin{align}\ny'\\left(n\\right) = \\left\\{\n\\begin{array}{ll}\ny\\left(n\\right) & \\mathrm{if}\\ n = 0, \\dots , N - 1 \\\\\n0 & \\mathrm{others}\n\\end{array}\n\\right.\n\\end{align}\\]\nまた、自己相関関数\\(r\\left(k\\right)\\)を以下の様に定義します。\n\\[\\begin{align}\nr\\left(k\\right) &= \\sum_{n=-\\infty}^{\\infty}y'\\left(n\\right)y'\\left(n + k\\right)\n\\end{align}\\]\nすると、AR係数は以下の様に推定することができます。\n\\[\\begin{align}\n\\mathbf{r}&=\n\\begin{pmatrix}\nr\\left(1\\right) \\\\\nr\\left(2\\right) \\\\\n\\vdots \\\\\nr\\left(p\\right) \\\\\n\\end{pmatrix} \\\\\n&= \\begin{pmatrix}\nr\\left(0\\right) & r\\left(1\\right) & \\cdots & y\\left(p - 1\\right) \\\\\nr\\left(1\\right) & r\\left(0\\right) & \\cdots & y\\left(p - 2\\right) \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\ny\\left(p - 1\\right) & r\\left(p - 2\\right) & \\cdots & y\\left(0\\right) \\\\\n\\end{pmatrix}\n\\begin{pmatrix}\na_{1} \\\\\n\\vdots \\\\\na_{p} \\\\\n\\end{pmatrix}\\\\\n&= \\mathbf{R} \\mathbf{a} \\\\\n\\mathbf{a} &= \\mathbf{R}^{-1}\\mathbf{r}\n\\end{align}\\]\nなお、上述の行列\\(\\mathbf{R}\\)はテプリッツ行列[2]と呼ばれる特殊な形式となります。 今回は取り扱いませんが、テプリッツ行列の逆行列はレビンソン・ダービンのアルゴリズムを用いることで高速に計算することが可能です。\n以下に、最小二乗法と自己相関法によるAR係数の推定を行うコードとその実行結果を示します。\n\nimport numpy as np\nimport numpy.typing as npt\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\ndef calc_ar_coeff_by_lsm(y: npt.NDArray[np.float32], p: int) -> npt.NDArray[np.float32]:\n    stride = y.strides[0]\n    D = np.fliplr(np.lib.stride_tricks.as_strided(y, (len(x) - p, p), (stride, stride)))\n    Y = y[p:]\n    A = -np.linalg.solve(D.T @ D, D.T @ Y).astype(np.float32)\n    return np.concatenate([np.array([1]), A])\n\n\ndef calc_ar_coeff_by_autocorrelation(y: npt.NDArray[np.float32], p: int) -> npt.NDArray[np.float32]:\n    y = np.concatenate([np.zeros(p - 1, dtype=np.float32), y, np.zeros(p - 1, dtype=np.float32)])\n    Y = np.fliplr(np.lib.stride_tricks.sliding_window_view(y, p))\n    r = Y.T @ np.concatenate([y[p:], np.array([0])])\n    R = Y.T @ Y\n    A = -np.linalg.solve(R, r).astype(np.float32)\n    return np.concatenate([np.array([1]), A])\n\nns = 4096\nt = np.linspace(0, 2 * np.pi, ns)\nx = 0.8 * np.sin(0.1 * ns * t) + 0.5 * np.sin(0.2 * ns * t) + 0.3 * np.sin(0.4 * ns * t)\n\na_lsm = calc_ar_coeff_by_lsm(x, 6)\na_autocorr = calc_ar_coeff_by_autocorrelation(x, 6)\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nw_lsm, h_lsm = signal.freqz(1, a_lsm)\nax.plot(w_lsm / (2 * np.pi), 20 * np.log10(np.abs(h_lsm)), label='lsm')\nw_autocorr, h_autocorr = signal.freqz(1, a_lsm)\nax.plot(w_autocorr / (2 * np.pi), 20 * np.log10(np.abs(h_autocorr)), label='autocorr')\nax.plot(w_lsm / (2 * np.pi), 20 * np.log10(np.abs(np.fft.fft(x))[:2048:4]), label='fft')\nax.set_xlabel('normalized frequency')\nax.set_ylabel('gain [dB]')\nax.legend()\nplt.show()"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#パルス列と白色雑音によるソースの実装",
    "href": "posts/2022-10-24-simple-voice-changer.html#パルス列と白色雑音によるソースの実装",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "パルス列と白色雑音によるソースの実装",
    "text": "パルス列と白色雑音によるソースの実装\n参考文献[4]によると、音声合成では有声音をパルス列で、無声音を白色雑音で表現すると良いとされているようです。 しかしながら、今回の目的はボイスチェンジャの実装であるため、これらの区別は行わずそれぞれを単一のソースとして扱います。\n以下にパルス列と白色雑音を生成するコードを示します。\n\ndef gen_pulse(ns: int, f: float) -> npt.NDArray[np.float32]:\n    while True:\n        x = np.zeros(ns, dtype=np.float32)\n        interval = int(1.0 / f)\n        for i in range(0, ns, interval):\n            x[i] = 1.0\n        yield x\n\ndef gen_white_noise(ns: int) -> npt.NDArray[np.float32]:\n    while True:\n        yield np.random.normal(-1, 1, ns)"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#ボイスチェンジャの実装",
    "href": "posts/2022-10-24-simple-voice-changer.html#ボイスチェンジャの実装",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "ボイスチェンジャの実装",
    "text": "ボイスチェンジャの実装\nフィルタとソースの実装が完了したので、それらを組み合わせてボイスチェンジャを実装します。 以下にコードを示します。\n\nfrom datasets import load_dataset\nfrom typing import Literal\n\ncommon_voice = load_dataset(\"common_voice\", \"ja\")\naudio = common_voice[\"train\"][0][\"audio\"][\"array\"]\nsampling_rate = common_voice[\"train\"][0][\"audio\"][\"sampling_rate\"]\n\ndef synth_voice(clip: npt.NDArray[np.float32], /, sampling_freq: float, source_freq: float = 0.00001, chunk_ms: float = 6, p: int = 64, source_type: Literal['pluse', 'noise'] = 'pluse') -> npt.NDArray[np.float32]:\n    chunk_size = int(sampling_rate * chunk_ms / 1000)\n    clip_length = (clip.size // chunk_size) * chunk_size\n    clip = clip[:clip_length]\n    chunks = clip.reshape((-1, chunk_size))\n\n    ret = []\n    source = gen_white_noise(chunk_size) if source_type == 'noise' else gen_pulse(chunk_size, source_freq)\n    for chunk, source in zip(chunks, source):\n        a = calc_ar_coeff_by_autocorrelation(chunk, p)\n        source = np.concatenate([source, np.zeros(source.size, dtype=np.float32)])\n        y = signal.lfilter(np.array([1]), a, source)\n        ret.append(y)\n    ret = np.vstack(ret)\n    ret[1:, :chunk_size] += ret[:-1, chunk_size:]  # overlap add\n    return np.concatenate(ret[:, :chunk_size])"
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#結果",
    "href": "posts/2022-10-24-simple-voice-changer.html#結果",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "結果",
    "text": "結果\nパルスで駆動したデータは雑音が目立ちますね。やはり単純にパルスやノイズで駆動するだけでは綺麗な音声にはならない様です。 あとは、もう少しチャンク間の結合を工夫すれば良いのかもしれません。\n\n白色雑音\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nパルス列(\\(200\\mathrm{Hz}\\))\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nパルス列(\\(300\\mathrm{Hz}\\))\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nパルス列(\\(400\\mathrm{Hz}\\))\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element."
  },
  {
    "objectID": "posts/2022-10-24-simple-voice-changer.html#参考",
    "href": "posts/2022-10-24-simple-voice-changer.html#参考",
    "title": "ARモデルによるシンプルなボイスチェンジャ",
    "section": "参考",
    "text": "参考\n\n\n[1] Lim, J.S. et al. 1992. 現代ディジタル信号処理理論とその応用. 丸善.\n\n\n[2] Wikipedia 2022. テプリッツ行列 — Wikipedia, the free encyclopedia. http://ja.wikipedia.org/w/index.php?title=テプリッツ行列.\n\n\n[3] Wikipedia 2022. 自己回帰モデル — Wikipedia, the free encyclopedia. http://ja.wikipedia.org/w/index.php?title=自己回帰モデル&oldid=90026540.\n\n\n[4] 山本龍一. and 高道慎之介. 2021. Pythonで学ぶ音声合成. インプレス."
  },
  {
    "objectID": "posts/2021-02-01-getting-started-with-glutin.html",
    "href": "posts/2021-02-01-getting-started-with-glutin.html",
    "title": "glutinに入門してみる",
    "section": "",
    "text": "glutin に入門した記録です． Objファイルをロードして，スタンフォードバニーを表示するサンプルプログラムを作成します．"
  },
  {
    "objectID": "posts/2021-02-01-getting-started-with-glutin.html#glutinとは",
    "href": "posts/2021-02-01-getting-started-with-glutin.html#glutinとは",
    "title": "glutinに入門してみる",
    "section": "glutinとは",
    "text": "glutinとは\nRustで記述されたOpenGLのラッパーライブラリです． OpenGLのラッパーライブラリには抽象度が高いものから低いものまで様々あります． 本ライブラリは，それらの中でも抽象度が低い，低レベルな機能を提供することを目的としたライブラリです． したがって，OpenGL相当の非常にプリミティブな機能しか提供されていません．\nglutinの実装の興味深い点に，ユーザが指定したAPIのバインディングをビルド時に動的に生成する点が挙げられます． この機能の利用方法については， サンプルプログラムの動作を通じて後述します．"
  },
  {
    "objectID": "posts/2021-02-01-getting-started-with-glutin.html#サンプルプログラムの解析",
    "href": "posts/2021-02-01-getting-started-with-glutin.html#サンプルプログラムの解析",
    "title": "glutinに入門してみる",
    "section": "サンプルプログラムの解析",
    "text": "サンプルプログラムの解析\n\nサンプルプログラムの実行\nリポジトリページにある手順に従ってサンプルプログラムを実行します．\n$ git clone https://github.com/rust-windowing/glutin\n$ cd glutin\n$ cargo run --example window\nすると，以下のようなウィンドウが表示されます．\n\n\n\nsample\n\n\n\n\ngl_bindings.rsの生成\nそれでは，このサンプルプログラムの詳細をみていきます．\nまず，Cargo.tomlを見てみます．すると，以下のようにbuild.rsがbuild scriptが設定されていることが確認できます．\n[package]\nname = \"glutin_examples\"\n\n...\n\nbuild = \"build.rs\"\n\n...\n\n[build-dependencies]\ngl_generator = \"0.14\"\nbuild.rsを確認すると，１２行目から１４行目において，GLES 2.0のバインディングを生成していることが確認できます． この処理は，gl_generatorを用いて実現されています．\nuse gl_generator::{Api, Fallbacks, Profile, Registry};\nuse std::env;\nuse std::fs::File;\nuse std::path::PathBuf;\n\nfn main() {\n    let dest = PathBuf::from(&env::var(\"OUT_DIR\").unwrap());\n\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    let mut file = File::create(&dest.join(\"gl_bindings.rs\")).unwrap();\n    Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, [])\n        .write_bindings(gl_generator::StructGenerator, &mut file)\n        .unwrap();\n}\n次に，実際にどのようあファイルが生成されているかを確認します． 環境変数OUT_DIRはcargoによって設定されてしまうため，任意の値を設定することができません． そこで，以下のように環境変数名を変更します．\n$ git diff\ndiff --git a/glutin_examples/build.rs b/glutin_examples/build.rs\nindex 77f6fa5..4ff7c4e 100644\n--- a/glutin_examples/build.rs\n+++ b/glutin_examples/build.rs\n@@ -4,7 +4,7 @@ use std::fs::File;\n use std::path::PathBuf;\n\n fn main() {\n-    let dest = PathBuf::from(&env::var(\"OUT_DIR\").unwrap());\n+    let dest = PathBuf::from(&env::var(\"TMP_OUT_DIR\").unwrap());\n\n     println!(\"cargo:rerun-if-changed=build.rs\");\nそして，ビルドするとgl_bindings.rsというファイルが作成されていることが確認できます． ファイルの内容を確認すると，GLES 2.0に利用されるデータ構造のバインディングか確認できます．\n$ TMP_OUT_DIR=`pwd` cargo build --example window\n$ ls gl_bindings.rs\ngl_bindings.rs\n$ head -n 32 gl_bindings.rs\n\n        mod __gl_imports {\n            pub use std::mem;\n            pub use std::marker::Send;\n            pub use std::os::raw;\n        }\n\n\n        pub mod types {\n            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]\n\n// Common types from OpenGL 1.1\npub type GLenum = super::__gl_imports::raw::c_uint;\npub type GLboolean = super::__gl_imports::raw::c_uchar;\npub type GLbitfield = super::__gl_imports::raw::c_uint;\npub type GLvoid = super::__gl_imports::raw::c_void;\npub type GLbyte = super::__gl_imports::raw::c_char;\npub type GLshort = super::__gl_imports::raw::c_short;\npub type GLint = super::__gl_imports::raw::c_int;\npub type GLclampx = super::__gl_imports::raw::c_int;\npub type GLubyte = super::__gl_imports::raw::c_uchar;\npub type GLushort = super::__gl_imports::raw::c_ushort;\npub type GLuint = super::__gl_imports::raw::c_uint;\npub type GLsizei = super::__gl_imports::raw::c_int;\npub type GLfloat = super::__gl_imports::raw::c_float;\npub type GLclampf = super::__gl_imports::raw::c_float;\npub type GLdouble = super::__gl_imports::raw::c_double;\npub type GLclampd = super::__gl_imports::raw::c_double;\npub type GLeglImageOES = *const super::__gl_imports::raw::c_void;\npub type GLchar = super::__gl_imports::raw::c_char;\npub type GLcharARB = super::__gl_imports::raw::c_char;\n次に，ターゲットのAPIをApi::Glに変更して'gl_bindings.rsを生成してみます. すると，先ほど生成したgl_bindings.rsとは内容が異なることが確認できます． このように，ターゲットや機能に合わせて，バックエンドを静的に切り替えて使用することが可能です．\n$ mv gl_bindings.rs gl_bindings_gles2.rs\n$ git diff\ndiff --git a/glutin_examples/build.rs b/glutin_examples/build.rs\nindex 77f6fa5..7e149bd 100644\n--- a/glutin_examples/build.rs\n+++ b/glutin_examples/build.rs\n@@ -4,12 +4,12 @@ use std::fs::File;\n use std::path::PathBuf;\n\n fn main() {\n-    let dest = PathBuf::from(&env::var(\"OUT_DIR\").unwrap());\n+    let dest = PathBuf::from(&env::var(\"TMP_OUT_DIR\").unwrap());\n\n     println!(\"cargo:rerun-if-changed=build.rs\");\n\n     let mut file = File::create(&dest.join(\"gl_bindings.rs\")).unwrap();\n-    Registry::new(Api::Gles2, (3, 3), Profile::Core, Fallbacks::All, [])\n+    Registry::new(Api::Gl, (3, 3), Profile::Core, Fallbacks::All, [])\n         .write_bindings(gl_generator::StructGenerator, &mut file)\n         .unwrap();\n }\n$ TMP_OUT_DIR=`pwd` cargo build --example window\n$ diff gl_bindings.rs gl_bindings_gles2.rs | head -n 32\n121a122\n> #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_ATOMIC_COUNTER_BUFFERS: types::GLenum = 0x92D9;\n123a125,126\n> #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_PROGRAM: types::GLenum = 0x8259;\n> #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_RESOURCES: types::GLenum = 0x92F5;\n128a132\n> #[allow(dead_code, non_upper_case_globals)] pub const ACTIVE_VARIABLES: types::GLenum = 0x9305;\n129a134,136\n> #[allow(dead_code, non_upper_case_globals)] pub const ALIASED_POINT_SIZE_RANGE: types::GLenum = 0x846D;\n> #[allow(dead_code, non_upper_case_globals)] pub const ALL_BARRIER_BITS: types::GLenum = 0xFFFFFFFF;\n> #[allow(dead_code, non_upper_case_globals)] pub const ALL_SHADER_BITS: types::GLenum = 0xFFFFFFFF;\n130a138\n> #[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS: types::GLenum = 0x0D55;\n133,135d140\n< #[allow(dead_code, non_upper_case_globals)] pub const AND: types::GLenum = 0x1501;\n< #[allow(dead_code, non_upper_case_globals)] pub const AND_INVERTED: types::GLenum = 0x1504;\n< #[allow(dead_code, non_upper_case_globals)] pub const AND_REVERSE: types::GLenum = 0x1502;\n136a142\n> #[allow(dead_code, non_upper_case_globals)] pub const ANY_SAMPLES_PASSED_CONSERVATIVE: types::GLenum = 0x8D6A;\n138a145,152\n> #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_SIZE: types::GLenum = 0x92FB;\n> #[allow(dead_code, non_upper_case_globals)] pub const ARRAY_STRIDE: types::GLenum = 0x92FE;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BARRIER_BIT: types::GLenum = 0x00001000;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER: types::GLenum = 0x92C0;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_BINDING: types::GLenum = 0x92C1;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_INDEX: types::GLenum = 0x9301;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_SIZE: types::GLenum = 0x92C3;\n> #[allow(dead_code, non_upper_case_globals)] pub const ATOMIC_COUNTER_BUFFER_START: types::GLenum = 0x92C2;\n141,146d154\n< #[allow(dead_code, non_upper_case_globals)] pub const BACK_LEFT: types::GLenum = 0x0402;\n< #[allow(dead_code, non_upper_case_globals)] pub const BACK_RIGHT: types::GLenum = 0x0403;\n< #[allow(dead_code, non_upper_case_globals)] pub const BGR: types::GLenum = 0x80E0;\n\n\nウィンドウの表示とポリゴンの描画\n先ほど実行したサンプルプログラムに対応するコードはこちらになります． それでは，こちらの内容を先頭から紹介していきます．\nまずは，supportモジュールと利用するglutinのモジュールのインポートです． supportモジュールは，ポリゴンの生成と描画，頂点シェーダ，フラグメントシェーダなど，サンプルプログラムに表示された三角形を描画するための処理が含まれています．\nmod support;\n\nuse glutin::event::{Event, WindowEvent};\nuse glutin::event_loop::{ControlFlow, EventLoop};\nuse glutin::window::WindowBuilder;\nuse glutin::ContextBuilder;\n次にmain関数です．main関数では，まず初めにイベントループ，ウィンドウ，このウインドウと紐づいたGLコンテキストを作成します． コード中のwindowed_contextとは，ウインドウとこのウィンドウに紐づいたGLコンテキストとを表現する構造体になります．\nfn main() {\n    let el = EventLoop::new();\n    let wb = WindowBuilder::new().with_title(\"A fantastic window!\");\n\n    let windowed_context = ContextBuilder::new().build_windowed(wb, &el).unwrap();\n\n    let windowed_context = unsafe { windowed_context.make_current().unwrap() };\n\n    println!(\"Pixel format of the window's GL context: {:?}\", windowed_context.get_pixel_format());\n\n    ...\n\n}\n次にコンテキストの取得を行います．この処理は，support::loadによって実現します． support::loadでは，以下のような処理が実行されます．\n\n頂点シェーダとフラグメントシェーダのコンパイル\nシェーダプログラムの作成\n三角形のポリゴンを表す頂点バッファオブジェクトと頂点配列オブジェクトの作成\n上記各種リソースのGLコンテキストへの割り当て\n\nこのコンテキストは上述のGLコンテキストを内部に持ち，各種描画処理を移譲します．\n    let gl = support::load(&windowed_context.context());\n最後にイベントハンドラです．このイベントハンドラは先ほど作成したイベントループ渡され，何かイベントが発生するたびに呼び出されます． 従って，イベントハンドラでは，発生したイベントの識別とそのイベントに対応する振る舞いを記述する必要があります． 各イベントに対する振る舞いについては，コード中にコメントとして追記しました．\n    el.run(move |event, _, control_flow| {\n        println!(\"{:?}\", event);\n        *control_flow = ControlFlow::Wait;\n\n        match event {\n            Event::LoopDestroyed => return, // イベントループか破棄されたのでインベントハンドラから抜ける\n            Event::WindowEvent { event, .. } => match event {\n                WindowEvent::Resized(physical_size) => windowed_context.resize(physical_size), // ウインドウをリサイズ\n                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit, // ウインドウを閉じる\n                _ => (),\n            },\n            Event::RedrawRequested(_) => { \n                gl.draw_frame([1.0, 0.5, 0.7, 1.0]); // ポリゴンの描画．\n                windowed_context.swap_buffers().unwrap(); // オフスクリーンに描画した結果を表示する\n            }\n            _ => (),\n        }\n    });"
  },
  {
    "objectID": "posts/2021-02-01-getting-started-with-glutin.html#スタンフォードバニーを表示する",
    "href": "posts/2021-02-01-getting-started-with-glutin.html#スタンフォードバニーを表示する",
    "title": "glutinに入門してみる",
    "section": "スタンフォードバニーを表示する",
    "text": "スタンフォードバニーを表示する\nObjファイルを読み取り，スタンフォードバニーを描画するサンプルプログラムを作成しました． このサンプルを実行すると，以下のような画面が表示されます．\n\n\n\nsample\n\n\n全体の構成は，glutinのサンプルプログラムを大きく変更はありません， 従って，比較的容易に読み取ることが可能かと思います． しかしながら，幾つか新しい試みを行っているため，それらについて紹介します．\n\ngl_bindings.rsのソースツリーへの取り込み\n前述した通り，gl_bindings.rsはビルド時に動的に生成されます．従って，これらが提供する型を編集時に取得することはできません． そのため，このままではコード補完や静的解析を行うことができません． Rustによる開発では，これらのツールは非常に重要であるため，このままでは非常に辛い開発が強いられます．\nそこで，gl_buildings.rsをソースツリーに取り込んでしまうことにしました． 具体的には，以下のようにgl_bindings.rsの保存先を変更します．\nfn main() {\n    let mut dest = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    dest.push(\"src\");\n\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    let mut file = File::create(&dest.join(\"gl_bindings.rs\")).unwrap();\n    Registry::new(Api::Gl, (3, 1), Profile::Core, Fallbacks::All, [])\n        .write_bindings(gl_generator::StructGenerator, &mut file)\n        .unwrap();\n}\nこの変更により，初回のビルド以降は以下のようにgl_bindings.rsがソースツリー内に存在します． 従って，コード補完や静的解析が適切に動作します．\n$ ls ./src\ncontext.rs      gl_bindings.rs  main.rs         obj.rs          shader.rs\n注意点としては，gl_bindings.rsは動的に生成されるものなのでリポジトリに含んではいけないことです． 従って，以下のように.gitignoreに追加します．\n$ cat .gitignore\nsrc/gl_bindings.rs\ntarget\n\n\nObjファイルについて\nObjファイルと呼ばれるファイルフォーマットには様々なものがあります． ここで使用するのは，3Dモデルを表現するために用いられるObjファイルです． また，Objファイルは頂点，面，法線など様々なデータを格納することができます． ここでは，以下のように頂点とそれらによって構成される面のみを対象とします．\nv <頂点番号1> <X座標1> <Y座標1> <Z座標1>\nv <頂点番号2> <X座標2> <Y座標2> <Z座標2>\n\n...\n\nf <面番号1> <頂点番号i> <頂点番号j> <頂点番号k>\n\n..."
  },
  {
    "objectID": "posts/2021-02-01-getting-started-with-glutin.html#参考",
    "href": "posts/2021-02-01-getting-started-with-glutin.html#参考",
    "title": "glutinに入門してみる",
    "section": "参考",
    "text": "参考\n\n\n[1] Glutin. https://docs.rs/glutin/0.26.0/glutin/."
  },
  {
    "objectID": "posts/2020-06-27-purely-binary-heap.html",
    "href": "posts/2020-06-27-purely-binary-heap.html",
    "title": "純粋なバイナリヒープ",
    "section": "",
    "text": "純粋なヒープを実装する場合，Braun Treeなど色々と適したデータ構造があるらしいですね． でも、あまり詳しくないので今回は馴染みの深いバイナリヒープを実装する方法について調べてみました．"
  },
  {
    "objectID": "posts/2020-06-27-purely-binary-heap.html#バイナリヒープとは",
    "href": "posts/2020-06-27-purely-binary-heap.html#バイナリヒープとは",
    "title": "純粋なバイナリヒープ",
    "section": "バイナリヒープとは？",
    "text": "バイナリヒープとは？\n二分木を用いて実装したヒープです．ヒープとは以下の性質をもつデータ構造です．\n\n木構造をもつ\n常に子要素の値は親要素の値以上\n\nヒープ自身の詳細についてはこの記事を参考にしてください．"
  },
  {
    "objectID": "posts/2020-06-27-purely-binary-heap.html#バイナリヒープを純粋に実装する",
    "href": "posts/2020-06-27-purely-binary-heap.html#バイナリヒープを純粋に実装する",
    "title": "純粋なバイナリヒープ",
    "section": "バイナリヒープを純粋に実装する",
    "text": "バイナリヒープを純粋に実装する\n一般的にバイナリヒープの実装には配列とそのインデックスを用いることが多いと思います．（上記のウィキペディアにもこの方法が記載されています） しかしがなら，この方法は配列の内容を書き換える必要があるため，純粋ではありません．そこで，今回は以下で提案されている手法を用いました．\nA Functional Approach to Standard Binary Heaps\nこの論文では，純粋なバイナリヒープの挿入，構築，削除の各操作ついてScalaを用いて説明しています． 以降，これらについて簡単に紹介を行います．\n\nヒープクラス\nこの論文ではバイナリヒープを表現するためのクラスHeapを以下のように定義しています，\nabstract sealed class Heap {\n    def min: Int // ヒープの最小値\n    def left: Heap //左側の子要素\n    def right: Heap //右側の子要素\n    def size: Int //ヒープに含まれる要素数\n    def height: Int //ヒープの高さ\n}\ncase class Branch(min: Int, left: Heap, right: Heap, size: Int, height: Int) extends Heap\ncase object Leaf extends Heap {\n    def min: Int = fail(\"Leaf.min\")\n    def left: Heap = fail(\"Leaf.min\")\n    def right: Heap = fail(\"Leaf.right\")\n    def size: Int = 0\n    def height: Int = 0\n}\n上述の通り，Heapクラスのleftとrightを持つ再帰的な構造になっています． また，Heapクラスは抽象クラスであるため，一つ以上の子要素を持つBranchと子要素を持たないLeafとを派生させています． 単純な二分木にはsizeとheightは必須ではありません．しかしながら，今回のようにバイナリヒープを実現するためには非常に重要となってきます．\n\n\n挿入 O(log n)\n新たな要素をを挿入する際に気をつけなければいけないことは，要素を挿入したバイナリヒープもまた上述の条件を満たさなければならないということです． そこで，今回の実装では挿入処理を以下の二つの処理に分けて考えます．\n\n要素をLeafとして最下レベルに追加する．\n1.にて追加した要素を適切な位置まで上へ登らせる（bubbleUp）．\n\nそれでは，まずは1.の新たな要素をLeafとして追加する方法について解説します． ノード追加すること自体は言語側でやってくれることなので，基本的には問題になりません． そのため，次にLeafを挿入する場所はどこかを知ることが問題となります．\n二分木に対する操作のパフォーマンスは木の高さに依存するため，可能な限り二分木の高さを抑える必要があります． 従って，新たな要素はleft側から順番に挿入します． バイナリヒープは二分木であるため，ルートから適切にleftまたはrightを選択することで任意の位置に到達することが可能です． そのため，この問題はleftとrightを以下のように4つの場合に分けて考えることで解決することができます．\n\nleftが完全二分木でない場合 -> leftを選択\nleftが完全二分木であるが，rightは完全二分木でない場合 -> rightを選択\nleftもrightも完全二分木であるが，leftの方がrightよりも高い場合 -> rightを選択\nleftもrightも完全二分木であり，高さが等しい場合 -> leftを選択\n\nこれら4つの場合を図に表すと以下のようになります．\n\nまた，Heapが完全二分木であるか否かは以下の条件式で求めることが可能です．\n\\[\nSize == 2^{Height} - 1\n\\]\n次に，2.のbubbleUpの方法について解説します． bubbleUpの処理は単純で，自身の値(min)と子要素の値(min)とを比較し，子要素の値(min)の値の方が小さい場合は要素を入れ替えます． 以上の結果を元に，insertとbubbleUpは以下のように実装することができます．\ndef bubbleUp(x: Int, l: Heap, r: Heap): Heap = (l, r) match {\n    case (Branch(y, lt, rt, _, _), _) if (x > y) =>\n    Heap(y, Heap(x, lt, rt), r)\n    case (_, Branch(z, lt, rt, _, _)) if (x > z) =>\n    Heap(z, l, Heap(x, lt, rt))\n    case (_, _) => Heap(x, l, r)\n}\n\ndef insert(x: Int): Heap =\n    if (isEmpty) Heap(x)\n    else if (left.size < math.pow(2, left.height) - 1)\n        bubbleUp(min, left.insert(x), right)\n    else if (right.size < math.pow(2, right.height) - 1)\n        bubbleUp(min, left, right.insert(x))\n    else if (right.height < left.height)\n        bubbleUp(min, left, right.insert(x))\n    else bubbleUp(min, left.insert(x), right)\n\n\n構築 O(n)\nソートされていない配列からバイナリヒープの構築を試みます． ここでは，構築済みのバイナリヒープをleftとrightに，配列のi番目の要素をminに設定した要素を考えます． しかしながら，配列のi番目の要素が各子要素の値(min)より小さいとは限らないため，全体としてヒープの条件を満たすとは限りません． そこで，ヒープの条件を満たさない場合は，配列のi番目の要素を適切な位置まで降ろす操作(bubbleDown)が必要となります．\nbubbleDownはHeapのminの値と各子要素のminの値とを比較し，小さな場合は何もせず， 大きな場合は要素を入れ替えた後に，再帰的にbubbleDownを呼びだします． こうすることで，当該要素を適切な位置まで降ろすことができます． 以上の結果を踏まえ，配列からバイナリヒープを構築する関数heapify及びbubbleUpは以下のように定義できます．\ndef bubbleDown(x: Int, l: Heap, r: Heap): Heap = (l, r) match {\n    case (Branch(y, _, _, _, _), Branch(z, lt, rt, _, _))\n    if (z < y && x > z) => Heap(z, l, bubbleDown(x, lt, rt))\n        case (Branch(y, lt, rt, _, _), _)\n        if (x > y) => Heap(y, bubbleDown(x, lt, rt), r)\n            case (_, _) => Heap(x, l, r)\n}\n\ndef heapify(a: Array[Int]): Heap = {\n    def loop(i: Int): Heap =\n    if (i < a.length) bubbleDown(a(i), loop(2 * i + 1), loop(2 * i + 2))\n        else Leaf\n            loop(0)\n}\nheapifyは一見するとを\\(O(n\\log n)\\)に見えますが，漸近的には\\(O(n)\\)らしいです． 正直，なぜ\\(O(n)\\)に成るのかは理解できていませんが，アルゴリズムイントロダクションに詳細が記載されているとあったので，そのうち調べてみようと思います．\n\n\n削除 O(log n)\n要素をの削除も挿入と同様， 以下のように二つのの処理に分けて考えることができます．\n\n最後に挿入した要素をバイナリヒープのルートへ移動させる\n1.でルートへ移動した要素を適切な位置まで降ろす(bubbleDown)\n\n最後に挿入した要素は挿入処理と同様に二分木を走査し，当該要素を見つけることで実現します． 要素を適切な位置まで降ろす処理(bubbleDown)は構築の際に用いたものと同一です． 以上の結果より，要素を削除する関数removeは以下のように実装されます． なお，floatLeftは左側の，floatRightは右側の子要素の値と親要素の値を交換する関数です.\ndef remove: Heap =\n    if (isEmpty) fail(\"Empty heap.\")\n    else bubbleRootDown(mergeChildren(left, right))\n\ndef bubbleRootDown(h: Heap): Heap =\n    if (h.isEmpty) Leaf\n    else Heap.bubbleDown(h.min, h.left, h.right)\n\ndef mergeChildren(l: Heap, r: Heap): Heap =\n    if (l.isEmpty && r.isEmpty) Leaf\n    else if (l.size < math.pow(2, l.height) - 1)\n        floatLeft(l.min, mergeChildren(l.left, l.right), r)\n    else if (r.size < math.pow(2, r.height) - 1)\n        floatRight(r.min, l, mergeChildren(r.left, r.right))\n    else if (r.height < l.height)\n        floatLeft(l.min, mergeChildren(l.left, l.right), r)\n    else floatRight(r.min, l, mergeChildren(r.left, r.right))\n\ndef floatLeft(x: Int, l: Heap, r: Heap): Heap = l match {\n    case Branch(y, lt, rt, _, _) => Heap(y, Heap(x, lt, rt), r)\n    case _ => Heap(x, l, r)\n}\n\ndef floatRight(x: Int, l: Heap, r: Heap): Heap = r match {\n    case Branch(y, lt, rt, _, _) => Heap(y, l, Heap(x, lt, rt))\n    case _ => Heap(x, l, r)\n}\n\n\nF#によるプライオリティキュー\nバイナリヒープを使ったプライオリティキューの実装です．\nPriorityQueue\n参考文献ではScalaによる実装でしたが，自分が普段使いする言語はF#なので，F#で実装してみました．"
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "",
    "text": "このUSB-NICをUbuntu 20.04から使用するために行った作業記録です．"
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#やったこと",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#やったこと",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "やったこと",
    "text": "やったこと\n\nネットワークデバイスを有効\nnetplanで静的IPアドレスを設定"
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#現状の確認",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#現状の確認",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "現状の確認",
    "text": "現状の確認\nUSBポートに差し込んだのみでは，ネットワークデバイスとして使用可能な状態にはなりませんでした． まずは，USBデバイスとして適切に認識されていることを確認します．\n$ lsusb\nBus 002 Device 002: ID 0b95:1790 ASIX Electronics Corp. AX88179 Gigabit Ethernet\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 002: ID 8087:0a2a Intel Corp.\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nASIX Electronics Corp. AX88179 Gigabit Ethernet このデバイスが対象のUSB-NICであるようです．"
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#ネットワークデバイスとして認識する",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#ネットワークデバイスとして認識する",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "ネットワークデバイスとして認識する",
    "text": "ネットワークデバイスとして認識する\n参考サイトの方法に従ってネットワークデバイスとして認識させます．\n$ sudo lshw -c Network\n...\n  *-network:0 DISABLED\n       description: Ethernet interface\n       physical id: 1\n       bus info: usb@2:4\n       logical name: enx000ec6853d1a\n       serial: 00:0e:c6:85:3d:1a\n       size: 10Mbit/s\n       capacity: 1Gbit/s\n       capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation\n       configuration: autonegotiation=off broadcast=yes driver=ax88179_178a duplex=half link=no multicast=yes port=MII speed=10Mbit/s\n...\n$ sudo ifconfig enx000ec6853d1a up\n$ ifconfig\n...\nenx000ec6853d1a: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet6 fe80::20e:c6ff:fe85:3d1a  prefixlen 64  scopeid 0x20<link>\n        ether 00:0e:c6:85:3d:1a  txqueuelen 1000  (イーサネット)\n        RX packets 39  bytes 3635 (3.6 KB)\n        RX errors 0  dropped 32  overruns 0  frame 0\n        TX packets 7  bytes 882 (882.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n..."
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#etccloudcloud.cfg.d50-curtin-networking.cfgにenx000ec6853d1aの設定を追加",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#etccloudcloud.cfg.d50-curtin-networking.cfgにenx000ec6853d1aの設定を追加",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "/etc/cloud/cloud.cfg.d/50-curtin-networking.cfgにenx000ec6853d1aの設定を追加",
    "text": "/etc/cloud/cloud.cfg.d/50-curtin-networking.cfgにenx000ec6853d1aの設定を追加\n$ cat /etc/cloud/cloud.cfg.d/50-curtin-networking.cfg\nnetwork:\n  ethernets:\n    enp2s0:\n      addresses: []\n      dhcp4: true\n    enx000ec6853d1a:\n      addresses:\n      - 10.0.100.1/24\n      gateway4: 10.0.0.1\n      dhcp4: false\n  version: 2\n$ sudo cloud-init clean -r\nここでシステムが再起動します．その後，以下の様に設定確認します．\n$ ifconfig\n...\nenx000ec6853d1a: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.0.100.1  netmask 255.255.255.0  broadcast 10.0.100.255\n        inet6 fe80::20e:c6ff:fe85:3d1a  prefixlen 64  scopeid 0x20<link>\n        ether 00:0e:c6:85:3d:1a  txqueuelen 1000  (イーサネット)\n        RX packets 2163  bytes 212391 (212.3 KB)\n        RX errors 0  dropped 1734  overruns 0  frame 0\n        TX packets 18  bytes 1900 (1.9 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n..."
  },
  {
    "objectID": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#参考",
    "href": "posts/2020-10-17-usb-nic-in-ubuntu-server.html#参考",
    "title": "Ubuntu 20.04 LTS Server でUSB-NICを使う",
    "section": "参考",
    "text": "参考\n\n\n[1] Ubuntu 16.04.5で有線LANが繋がらない. https://qiita.com/tackey/items/794ea92e5cb31f9febbc."
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "",
    "text": "普段SSHで管理しているサーバーが，ネットワーク関連のトラブルに見舞われると，いつも通りにログインできず色々と大変です． そこで，Ubuntu 20.04をシリアルコンソール経由で操作する環境を構築します．"
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html#やったこと",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html#やったこと",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "やったこと",
    "text": "やったこと\n\nUSB-TTLケーブルによる代用シリアルケーブルの作成\nudevによるケーブル挿入をトリガーとしたシリアルコンソールの有効化"
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html#ケーブル作成",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html#ケーブル作成",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "ケーブル作成",
    "text": "ケーブル作成\n特殊なケースを除くと，最近のPCにはシリアルポートが付属していません． そこで，２本のUSB-TTL変換ケーブルを直結することでシリアルケーブルの代用とします． 今回，安価に購入可能なこちらのケーブルを使用しました． 代用ケーブルの作成は，両ケーブルのピンソケットを切断し，以下の様に緑と白を交差して結線します．\n<赤> ---------------- <赤>\n<緑> -------\\/------- <緑>\n<白> -------/\\------- <白>\n<黒> ---------------- <黒>\n作成したケーブルの動作確認は両端をUSBポートに挿入し，接続したマシンで以下の様にcuコマンドを実行します． 接続が適切に行われると，一方の端末で入力した文字列が他方の端末に表示されると思います． （同一マシンでも可能です）\n$ sudo cu -l /dev/ttyUSB0 # <- ttyUSB0の部分は環境によります"
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html#シリアルコンソールの有効化",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html#シリアルコンソールの有効化",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "シリアルコンソールの有効化",
    "text": "シリアルコンソールの有効化\n代用ケーブルを接続したマシンにて，以下のコマンド実行するとシリアルコンソールを有効化することができます．\n$ sudo systemctl enable serial-getty@ttyUSB0.service  # <- ttyUSB0の部分は環境によります\n$ sudo systemctl start serial-getty@ttyUSB0.service  # <- ttyUSB0の部分は環境によります\nその後，もう一方を接続したマシンにて，cuコマンドを用いて接続します．すると，以下の様にログインプロンプトが確認できます．(slimeはホスト名です)\n$ sudo cu -l /dev/ttyUSB0 # <- ttyUSB0の部分は環境によります\nPassword:\nConnected.\n\nslime login:"
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html#udevによるシリアルコンソールの自動起動",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html#udevによるシリアルコンソールの自動起動",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "udevによるシリアルコンソールの自動起動",
    "text": "udevによるシリアルコンソールの自動起動\n常時ケーブルを刺しっぱなしにするのは不便なので，ケーブルを挿入したタイミングで，シリアルコンソールが有効化されるように設定します． ですが，普通にUSB-TTL変換ケーブルを使いたい時もあるので，単純にttyUSB0を関しするだけでは都合が悪そうです． そこで，特定のVendor IDとProduct IDを持つUSB-Serialデバイスが接続された場合のみシリアルコンソールを有効化します． Vendor IDとProduct IDは以下のコマンドで確認します．\n$ udevadm test-builtin usb_id /sys/class/tty/ttyUSB0\nLoad module index\nParsed configuration file /usr/lib/systemd/network/99-default.link\nParsed configuration file /usr/lib/systemd/network/73-usb-net-by-mac.link\nCreated link configuration context.\nID_VENDOR=Prolific_Technology_Inc.\nID_VENDOR_ENC=Prolific\\x20Technology\\x20Inc.\nID_VENDOR_ID=067b\nID_MODEL=USB-Serial_Controller\nID_MODEL_ENC=USB-Serial\\x20Controller\nID_MODEL_ID=2303\nID_REVISION=0300\nID_SERIAL=Prolific_Technology_Inc._USB-Serial_Controller\nID_TYPE=generic\nID_BUS=usb\nID_USB_INTERFACES=:ff0000:\nID_USB_INTERFACE_NUM=00\nID_USB_DRIVER=pl2303\nUnload module index\nUnloaded link configuration context.\nID_VENDOR_ID=067b および ID_MODEL_ID=2303 とあるので，Vendor IDが067bかつProduct IDが2303であることが確認できます． これは，今回使用するケーブルはPL2303を使っているためです.従って，PL2303が接続されるとシリアルコンソールが有効化されることになります．\n以上の結果を元に，以下の様にudevの設定を追加します．\n$ cat /etc/udev/rules.d/65-serial-console.rules\nACTION==\"remove\", GOTO=\"serial_end\"\nSUBSYSTEM!=\"tty\", GOTO=\"serial_end\"\n\nENV{ID_VENDOR_ID}==\"067b\", ENV{ID_MODEL_ID}==\"2303\", ENV{SYSTEMD_WANTS}+=\"serial-getty@ttyUSB$env{.ID_PORT}.service\"\n\nLABEL=\"serial_end\"\n1,2行目は，USB-TTLケーブル挿入時以外は処理をスキップすることを表しています． 4行目はVendor IDが067bかつProduct IDが2303である場合，対応するttyUSBに対してserial-gettyサービスを有効化することを表しています．\n設定後，以下のコマンドでケーブル挿入の前後でserial-getty@ttyUSB0.serviceが有効化されていることを確認できます．\n\nケーブル挿入前\n\n$sudo systemctl status serial-getty@ttyUSB0.service\n● serial-getty@ttyUSB0.service - Serial Getty on ttyUSB0\n     Loaded: loaded (/lib/systemd/system/serial-getty@.service; enabled; vendor preset: enabled)\n     Active: inactive (dead) since Sun 2021-05-23 03:26:14 UTC; 2s ago\n       Docs: man:agetty(8)\n             man:systemd-getty-generator(8)\n             http://0pointer.de/blog/projects/serial-console.html\n    Process: 3803 ExecStart=/sbin/agetty -o -p -- \\u --keep-baud 115200,38400,9600 ttyUSB0 $TERM (code=killed, signal=HUP)\n   Main PID: 3803 (code=killed, signal=HUP)\n\nMay 23 03:26:14 slime systemd[1]: Stopped Serial Getty on ttyUSB0.\n\nケーブル挿入後\n\n$ sudo systemctl status serial-getty@ttyUSB0.service\n● serial-getty@ttyUSB0.service - Serial Getty on ttyUSB0\n     Loaded: loaded (/lib/systemd/system/serial-getty@.service; enabled; vendor preset: enabled)\n     Active: active (running) since Sun 2021-05-23 03:26:21 UTC; 1s ago\n       Docs: man:agetty(8)\n             man:systemd-getty-generator(8)\n             http://0pointer.de/blog/projects/serial-console.html\n   Main PID: 4494 (agetty)\n      Tasks: 1 (limit: 76982)\n     Memory: 348.0K\n     CGroup: /system.slice/system-serial\\x2dgetty.slice/serial-getty@ttyUSB0.service\n             └─4494 /sbin/agetty -o -p -- \\u --keep-baud 115200,38400,9600 ttyUSB0 vt220\n\nMay 23 03:26:21 slime systemd[1]: Started Serial Getty on ttyUSB0."
  },
  {
    "objectID": "posts/2021-05-26-use-serial-console-in-ubuntu.html#参考",
    "href": "posts/2021-05-26-use-serial-console-in-ubuntu.html#参考",
    "title": "Ubuntu 20.04をシリアルコンソール経由で操作する",
    "section": "参考",
    "text": "参考\n\nUbuntu 15.10 でシリアルコンソールを有効にする\nUbuntu Weekly Recipe 第555回　いま，あらためてudev\nRaspberry Pi 2 + systemd + udevで、USBデバイス挿入時にサービスを起動する"
  },
  {
    "objectID": "posts/2020-12-13-introduction-to-typenum.html",
    "href": "posts/2020-12-13-introduction-to-typenum.html",
    "title": "型レベル整数ライブラリtypenumの紹介",
    "section": "",
    "text": "型レベル整数とは，型によって整数を表現する方法です．この型とは整数を表すi32や文字列を表すStringと同様のものです．すなわち，１を表す型や，2を表す型を定義し，それらによって整数を型レベルで表現します．\n型レベル整数の嬉しい点として，型レベル整数による式はコンパイル時に評価されることが挙げられます．これによって，各種定数を容易に設定することが可能となります．\nRustにて型レベル整数の実装として，typenumというクレートがあります．ここでは，このtypenumの簡単な使用方法を紹介します．"
  },
  {
    "objectID": "posts/2020-12-13-introduction-to-typenum.html#やったこと",
    "href": "posts/2020-12-13-introduction-to-typenum.html#やったこと",
    "title": "型レベル整数ライブラリtypenumの紹介",
    "section": "やったこと",
    "text": "やったこと\n\ntypenumによる型レベル整数の定義\ntypenumによってサポートされる演算の評価"
  },
  {
    "objectID": "posts/2020-12-13-introduction-to-typenum.html#実際に型レベル整数を使ってみる",
    "href": "posts/2020-12-13-introduction-to-typenum.html#実際に型レベル整数を使ってみる",
    "title": "型レベル整数ライブラリtypenumの紹介",
    "section": "実際に型レベル整数を使ってみる",
    "text": "実際に型レベル整数を使ってみる\nそれでは，実際にtypenumを使用して整数の演算を行っていきます．まず，1+2を計算する例を以下に示します． ここで，P1とP2はそれぞれ1と2を，Sumは加算を表します．また，to_i32()は型レベル整数が示す値をi32へ変換する処理です．\n\n:dep typenum\n//above line is magic for adding crate\n\nuse typenum::*;\n\ntype A = Sum<P1, P2>; // A is P3\nassert_eq!(A::to_i32(), 3); //  A::to_i32() == 3\n\n以上の結果より，適切に型レベルで1+2が計算出来たことがわかります．　次はもう少し複雑な例について考えます．以下に示すコードは，型レベル整数を用いて，((1 + 2 ) * 3 - 4) / 5を計算します．ここで，Quotは除算を，Diffは減算を，Prodは乗算を表します．\n\nuse typenum::*;\n\ntype A = Quot<Diff<Prod<Sum<P1, P2>, P3>, P4>, P5>; // A is P1\nassert_eq!(A::to_i32(), 1); //  A::to_i32() == 1\n\nここでは，最低限の演算しか紹介しませんでしたが，typenumにはこれら以外にも多くの機能が実装されています．興味のある方は，是非確認してみてください．"
  },
  {
    "objectID": "posts/2020-12-13-introduction-to-typenum.html#参考",
    "href": "posts/2020-12-13-introduction-to-typenum.html#参考",
    "title": "型レベル整数ライブラリtypenumの紹介",
    "section": "参考",
    "text": "参考\n\n\n[1] Typenum. https://docs.rs/typenum/1.12.0/typenum/index.html."
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "",
    "text": "Raspberry Pi 4+k3s+rayでクラスタを作成して，分散処理の実験を行います．Raspberry Pi 4 には事前にUbuntu 20.04を導入しておきます．"
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html#cgroupの有効化",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html#cgroupの有効化",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "cgroupの有効化",
    "text": "cgroupの有効化\n残念ながら，このcgroupの設定が何故必要なのかを理解できていません．しかしながら，Webで調べた限りでは，必要そうなので設定することにします．（設定しない場合はどうなるかを試してはいません）\nSDカードをホストマシンにマウントして以下のコマンド実行します．以下の例では，/Vlumes/system-bootにSDカードがマウントされています．マウントポイントについては，環境に応じて適切に書き換えてください．\n$ sed -i -e 's/$/ cgroup_memory=1 cgroup_enable=memory cgroup_enable=cpuset/' /Volumes/system-boot/cmdline.txt    \n修正したSDカードを用いてシステムを起動します．その後，以下のコマンドで設定の反映を確認できます．\n$ cat /proc/cgroups  \n#subsys_name    hierarchy       num_cgroups     enabled  \ncpuset  5       10      1  \ncpu     4       98      1  \ncpuacct 4       98      1  \nblkio   8       98      1  \nmemory  2       147     1  \ndevices 11      98      1  \nfreezer 9       11      1  \nnet_cls 6       10      1  \nperf_event      7       10      1  \nnet_prio        6       10      1  \npids    10      106     1  \nrdma    3       1       1"
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html#k3sの導入",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html#k3sの導入",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "k3sの導入",
    "text": "k3sの導入\nリポジトリの手順に従います．注意が必要な点は，マスターノードとワーカーノードとで導入方法が異なる点です．ここでハマらなければ，さくっと導入できると思います．今回，以下の様にマスターノードx1，ワーカーノードx3でk3sクラスタを構成しました．\n$ kubectl get nodes\nNAME         STATUS   ROLES    AGE     VERSION\nk3s-node3    Ready    worker   3d12h   v1.18.2+k3s1\nk3s-node2    Ready    worker   3d12h   v1.18.2+k3s1\nk3s-node1    Ready    worker   3d12h   v1.18.2+k3s1\nk3s-master   Ready    master   3d18h   v1.18.2+k3s1"
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html#rayクラスタのデプロイ",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html#rayクラスタのデプロイ",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "rayクラスタのデプロイ",
    "text": "rayクラスタのデプロイ\nこちらも公式の手順に従います．しかしながら，こちらで使用しているDockerイメージはamd64向けに作成された物であり，aarch64環境では動作しません．そこで，ほぼ等価なイメージをaarch64向けに作成しました．今回は，このイメージを用いてクラスタを作成します．具体的には，ray-cluster.yamlを以下の様に修正します．\ndiff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml\nindex 853f9dfb2..0563c934f 100644\n--- a/doc/kubernetes/ray-cluster.yaml\n+++ b/doc/kubernetes/ray-cluster.yaml\n@@ -59,7 +59,7 @@ spec:\n           medium: Memory\n       containers:\n         - name: ray-head\n-          image: rayproject/autoscaler\n+          image: ar90n/autoscaler-py37\n           imagePullPolicy: Always\n           command: [ \"/bin/bash\", \"-c\", \"--\" ]\n           args:\n@@ -120,7 +120,7 @@ spec:\n           medium: Memory\n       containers:\n       - name: ray-worker\n-        image: rayproject/autoscaler\n+        image: ar90n/autoscaler-py37\n         imagePullPolicy: Always\n         command: [\"/bin/bash\", \"-c\", \"--\"]\n         args:\n以下のようにコンテナをデプロイします．\n$ kubectl create -f ray/doc/kubernetes/ray-namespace.yaml\nnamespace/ray created\n$ kubectl apply -f ray/doc/kubernetes/ray-cluster.yaml\nservice/ray-head created\ndeployment.apps/ray-head created\ndeployment.apps/ray-worker created\n$ kubectl  -n ray get pods\nNAME                         READY   STATUS    RESTARTS   AGE\nray-head-7957ff48b6-tj6z2    1/1     Running   0          118s\nray-worker-7574c9d77-bs4dx   1/1     Running   0          118s\nray-worker-7574c9d77-2868n   1/1     Running   1          118s\nray-worker-7574c9d77-x48m7   1/1     Running   0          118s\nクラスタの作成が完了したので，テストプログラムを実行します．こちらも公式の手順に従い，example.pyを実行します．\n$ kubectl -n ray cp ray/doc/kubernetes/example.py ray-head-7957ff48b6-tj6z2:/example.py\n$ kubectl -n ray exec ray-head-7957ff48b6-tj6z2 -- python example.py\n2020-05-24 14:13:54,824 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster's _internal_config.\nIteration 0\nCounter({('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 8, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 6, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 3, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 1})\nIteration 1\nCounter({('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 12, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 10, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 7, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 4, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 2, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 2})\nIteration 2\nCounter({('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 12, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 11, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 10, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 8, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 4, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 3, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 2})\nIteration 3\nCounter({('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 13, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 10, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 8, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 5, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 4, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 3, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 3})\nIteration 4\nCounter({('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 11, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 11, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 10, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 9, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 7, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 7, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 6, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 6, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 5, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 3, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 3, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 2, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 2, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 2})\nIteration 5\nCounter({('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 11, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 11, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 8, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 8, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 7, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 3, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 2, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 2, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 1})\nIteration 6\nCounter({('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 12, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 10, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 4, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 2})\nIteration 7\nCounter({('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 12, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 10, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 9, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 8, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 5, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 5, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 3, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 3})\nIteration 8\nCounter({('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 10, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 10, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 10, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 8, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 6, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 4, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 3, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 3, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 2, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 2})\nIteration 9\nCounter({('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-bs4dx'): 10, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-bs4dx'): 9, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-2868n'): 9, ('ray-worker-7574c9d77-bs4dx', 'ray-head-7957ff48b6-tj6z2'): 8, ('ray-head-7957ff48b6-tj6z2', 'ray-worker-7574c9d77-x48m7'): 8, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-2868n'): 7, ('ray-worker-7574c9d77-x48m7', 'ray-head-7957ff48b6-tj6z2'): 7, ('ray-worker-7574c9d77-bs4dx', 'ray-worker-7574c9d77-x48m7'): 6, ('ray-head-7957ff48b6-tj6z2', 'ray-head-7957ff48b6-tj6z2'): 6, ('ray-worker-7574c9d77-2868n', 'ray-head-7957ff48b6-tj6z2'): 6, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-bs4dx'): 5, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-x48m7'): 4, ('ray-worker-7574c9d77-2868n', 'ray-worker-7574c9d77-2868n'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-bs4dx'): 4, ('ray-worker-7574c9d77-x48m7', 'ray-worker-7574c9d77-2868n'): 3})\nSuccess!"
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html#ベンチマーク",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html#ベンチマーク",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "ベンチマーク",
    "text": "ベンチマーク\n最後に，作成したクラスタのベンチマークとして，マンデルブロ集合の描画時間を計測します．マンデルブロ集合の描画には以下のコードを用います．画像全体をn_x_grids x n_y_grids個の領域に区切り，各領域毎に並行処理します．\n#!/usr/bin/env python\nimport numpy as np\nfrom numba import njit\nimport itertools\nimport os\nimport ray\nimport matplotlib.pyplot as plt\nfrom timeit import timeit\n\nif (os.environ.get(\"RAY_HEAD_SERVICE_HOST\") is None):\n    ray.init()\nelse:\n    redis_host = os.environ[\"RAY_HEAD_SERVICE_HOST\"]\n    ray.init(address=redis_host + \":6379\")\n\nn_x_grids = int(os.environ.get(\"X_GRIDS\", 32))\nn_y_grids = int(os.environ.get(\"Y_GRIDS\", 32))\ngrid_width = int(os.environ.get(\"GRID_WIDTH\", 100))\ngrid_height = int(os.environ.get(\"GRID_HEIGHT\", 100))\n\ndef grid_range(begin, end, n_grids):\n    ih, it = itertools.tee(np.linspace(begin, end, n_grids + 1))\n    next(it)\n    return ((h,t) for h,t in zip(ih, it))\n\n@ray.remote\ndef mandelbrot(c, n = 32, th = 200):\n    z = 1j * np.zeros(c.shape)\n    r = np.zeros(c.shape)\n    for i in range(n):\n        mask = np.abs(z) <= th\n        z += (z * z + c - z) * mask.astype(np.int)\n        r[mask] = i\n    # make smooth\n    return r - np.log2(np.log2(np.abs(z) + 1))\n\ndef rendering(n_xg, n_yg, gw, gh):\n    res = []\n    xs = grid_range(-2, 1, n_xg)\n    ys = grid_range(-1, 1, n_yg)\n    for ((xb, xe), (yb, ye)) in itertools.product(xs, ys):\n        x, y = np.meshgrid(np.linspace(xb, xe, gw), np.linspace(yb, ye, gh))\n        c = x + 1j * y\n        res.append(mandelbrot.remote(c))\n    res = ray.get(res)\n    return np.concatenate(np.concatenate(np.array(res).reshape(n_yg, n_xg, gh, gw), axis=2),axis=0)\n\nbenchmark = timeit(lambda: rendering(n_x_grids, n_y_grids, grid_width, grid_height), number=8) / 8\nprint(f\"time: {benchmark}\")\n\nimg = rendering(n_x_grids, n_y_grids, grid_width, grid_height)\nplt.figure(dpi=200)\nplt.imshow(img, cmap='rainbow', interpolation='bilinear', extent=[-2, 1, -1, 1])\nplt.xticks(color='None')\nplt.yticks(color='None')\nplt.tick_params(length=0)\nplt.savefig('figure.png')\nまた，クラスタの設定も少しだけ修正します．各コンテナに割り当てるメモリの変更と，必要なパッケージをコンテナ起動時に追加します．\ndiff --git a/doc/kubernetes/ray-cluster.yaml b/doc/kubernetes/ray-cluster.yaml\nindex 853f9dfb2..d2b2c9678 100644\n--- a/doc/kubernetes/ray-cluster.yaml\n+++ b/doc/kubernetes/ray-cluster.yaml\n@@ -59,11 +59,11 @@ spec:\n           medium: Memory\n       containers:\n         - name: ray-head\n-          image: rayproject/autoscaler\n+          image: ar90n/autoscaler-py37\n           imagePullPolicy: Always\n           command: [ \"/bin/bash\", \"-c\", \"--\" ]\n           args:\n-            - \"ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block\"\n+            - \"conda install -y -c numba numba && conda install -y matplotlib && ray start --head --node-ip-address=$MY_POD_IP --redis-port=6379 --redis-shard-ports=6380,6381 --num-cpus=$MY_CPU_REQUEST --object-manager-port=12345 --node-manager-port=12346 --block\"\n           ports:\n             - containerPort: 6379 # Redis port.\n             - containerPort: 6380 # Redis port.\n@@ -120,11 +120,11 @@ spec:\n           medium: Memory\n       containers:\n       - name: ray-worker\n-        image: rayproject/autoscaler\n+        image: ar90n/autoscaler-py37\n         imagePullPolicy: Always\n         command: [\"/bin/bash\", \"-c\", \"--\"]\n         args:\n-          - \"ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block\"\n+          - \"conda install -y -c numba numba && conda install -y matplotlib && ray start --node-ip-address=$MY_POD_IP --num-cpus=$MY_CPU_REQUEST --address=$RAY_HEAD_SERVICE_HOST:$RAY_HEAD_SERVICE_PORT_REDIS_PRIMARY --object-manager-port=12345 --node-manager-port=12346 --block\"\n         ports:\n           - containerPort: 12345 # Ray internal communication.\n           - containerPort: 12346 # Ray internal communication.\n@@ -147,4 +147,4 @@ spec:\n         resources:\n           requests:\n             cpu: 100m\n-            memory: 512Mi\n+            memory: 1024Mi\n実行結果を以下に示します．無事に動作している様です．\n$ kubectl -n ray exec ray-head-6785995666-m49kv -- python main.py\n2020-05-24 14:57:57,849 WARNING worker.py:809 -- When connecting to an existing cluster, _internal_config must match the cluster's _internal_config.\n(pid=2799) main.py:36: RuntimeWarning: divide by zero encountered in log2\n(pid=2799)   return r - np.log2(np.log2(np.abs(z) + 1))\n(pid=2780, ip=10.42.1.13) main.py:36: RuntimeWarning: divide by zero encountered in log2\n(pid=2780, ip=10.42.4.25) main.py:36: RuntimeWarning: divide by zero encountered in log2\n(pid=2783, ip=10.42.0.35) main.py:36: RuntimeWarning: divide by zero encountered in log2\ntime: 34.654623864378664\n\nRayのワーカーノードの数を変更すると以下の様に処理時間が変化しました．\n\n\n\nワーカーノード数\n処理時間[s]\n\n\n\n\n0\n45.09195340787119\n\n\n1\n48.55051823974645\n\n\n2\n38.57156975386897\n\n\n3\n34.654623864378664\n\n\n\nあまり安定のしない微妙な結果となりました．思った以上に並列化される部分意外にボトルネックがあったのかもしれません．"
  },
  {
    "objectID": "posts/2020-05-25-Ray-k3s-raspi4.html#参考",
    "href": "posts/2020-05-25-Ray-k3s-raspi4.html#参考",
    "title": "Raspberry Pi 4 + k3s + Rayで分散処理を試す",
    "section": "参考",
    "text": "参考\n\n\n[1] k3s. GitHub repository. https://github.com/rancher/k3s; GitHub.\n\n\n[2] Raspberry pi 4におけるK3Sクラスタ構築. https://qiita.com/Tsu_hao_Zhang/items/7d4f5d62bed584766881.\n\n\n[3] Ray. GitHub repository. https://github.com/ray-project/ray; GitHub."
  },
  {
    "objectID": "posts/2021-03-30-ray-tracing-in-weekend.html",
    "href": "posts/2021-03-30-ray-tracing-in-weekend.html",
    "title": "Rustでレイトレーシングをしてみる",
    "section": "",
    "text": "Rustの勉強を兼ねて，こちらを参考にレイトレーシングを写経してみました．"
  },
  {
    "objectID": "posts/2021-03-30-ray-tracing-in-weekend.html#メモ",
    "href": "posts/2021-03-30-ray-tracing-in-weekend.html#メモ",
    "title": "Rustでレイトレーシングをしてみる",
    "section": "メモ",
    "text": "メモ\n\n十分な数のRayを計算しなければ綺麗な画像は得られない．レイトレーシング結果のサンプルで，画素が黒く欠損しているのは十分な数のRayを計算していないから\nRayによってランダムにサンプリングすることで，ブラーやボケやアンチエイリアシングを表現する\n思っていたよりも単純"
  },
  {
    "objectID": "posts/2021-03-30-ray-tracing-in-weekend.html#結果",
    "href": "posts/2021-03-30-ray-tracing-in-weekend.html#結果",
    "title": "Rustでレイトレーシングをしてみる",
    "section": "結果",
    "text": "結果\n\n1週目 \n2週目"
  },
  {
    "objectID": "posts/2021-03-30-ray-tracing-in-weekend.html#参考",
    "href": "posts/2021-03-30-ray-tracing-in-weekend.html#参考",
    "title": "Rustでレイトレーシングをしてみる",
    "section": "参考",
    "text": "参考\n\n\n[1] Shirley, P. 2020. Ray tracing in one weekend.\n\n\n[2] Shirley, P. 2020. Ray tracing: The next week."
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "",
    "text": "ファイルの格納先(ファイルシステム，S3，GCS等)毎にIO処理を記述すると，プログラムが複雑になりがちです．ここでは，それらを統一的に取り扱うことができるsmart_openについて述べます．"
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#やったこと",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#やったこと",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "やったこと",
    "text": "やったこと\n\nsmart_openの導入\nsmart_openによるファイルシステム，クラウドストレージ，Webからのファイル読み込み"
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#smart_openについて",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#smart_openについて",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "smart_openについて",
    "text": "smart_openについて\nsmart_openはビルトインのopenを置き換えることで，様々なプロトコルを用いてファイルをオープンすることを可能にします．現状のプロトコルに対応している様です．\n\nS3\nGCS\nBlob Storage\nHDFS\nファイルシステム\nSSH\nSCP\nSFTP\nHTTP\n\nまた，以下形式で圧縮されたファイルを透過的に扱うことができます．\n\ngzip\nbzip2\n\nここでは，ファイルシステム，S3，GCS，HTTPによるファイルアクセスを評価します．\n従って，以下のようにクラウドストレージをサポートするsmart_openを導入します．\n$ pip install smart_open[all]\n他の導入方法については，リポジトリのREADMEを参考にしてください．"
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#クラウドストレージwebからファイルを読み込む",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#クラウドストレージwebからファイルを読み込む",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "クラウドストレージ，Webからファイルを読み込む",
    "text": "クラウドストレージ，Webからファイルを読み込む\n通常，クラウドストレージ上のファイルにアクセスするには専用のSDKを使用することが多いと思います． また，HTTPプロトコルでアクセスするには，urllibやrequests等を使用することが多いと思います． そのため，リソースに応じてこれらのライブラリを適切に取り扱う必要があります．\nsmart_openはこれらのライブラリを適切にラップします．従って，これらのファイルをファイルシステム上にあるかの様に取り扱うことが可能となります．\nここでは，TIFFファイルをGCS, S3, HTTP, ファイルシステム経由で読み込み表示するサンプルを示します．なお，事前に適切な認証情報を設定しておく必要があります．\n\nfrom smart_open import open\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\nsources = {\n    \"S3\": \"s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF\",\n    \"HTTP\":  \"https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF\",\n    \"FILESYSTEM\": \"/tmp/LC80030172015001LGN00_BQA.TIF\"\n}\n\nfor protocol, url in sources.items():\n    with open(url, \"rb\") as fp:\n        img = Image.open(fp)\n        plt.figure()\n        plt.title(f\"from {protocol}\")\n        plt.imshow(img, cmap='gray')"
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#pathlib.path経由でsmart_openを使うことはできるようですが",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#pathlib.path経由でsmart_openを使うことはできるようですが",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "pathlib.Path経由でsmart_openを使うことはできるようですが",
    "text": "pathlib.Path経由でsmart_openを使うことはできるようですが\nいかなるリソースもopenで同様に取り扱うことができる事はとても便利です．しかしながら，strでリソースを指定するのは少し大変です．なので，pathlib.Pathでリソースを指定できると便利です．\nsmart_openはpathlib.Path.openをフックすることできるようです．しかしながら，pathlib.Pathがファイルパスしか扱えない(//が/に置換されてしまう)ので，すこし微妙かもしれません．．\n\nfrom pathlib import Path\nPath(\"https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF\")\n\nPosixPath('https:/s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF')"
  },
  {
    "objectID": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#参考",
    "href": "posts/2020-10-21-accessing-file-with-unified-pythonic-api.html#参考",
    "title": "smart_openによる統一的なファイルアクセス",
    "section": "参考",
    "text": "参考\n\n\n[1] Smartopen. GitHub repository. https://github.com/RaRe-Technologies/smart_open; GitHub."
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html",
    "title": "KD木と次元の呪い",
    "section": "",
    "text": "取り扱うデータが高次元になると次元の呪いと呼ばれる問題が生じることが広く知られています． この次元の呪いが示す問題は, 使用される文脈に応じて様々であると思います． ここでは，KD木[2]を用いた近傍探索における問題について考察します．"
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#やったこと",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#やったこと",
    "title": "KD木と次元の呪い",
    "section": "やったこと",
    "text": "やったこと\n\nデータの次元が高くなるにつれてKD木による近傍探索の効率が低下することを実験的に検証\n高次元データの特徴からKD木の探索が非効率的になる原因を考察"
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#kd木による近傍探索",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#kd木による近傍探索",
    "title": "KD木と次元の呪い",
    "section": "KD木による近傍探索",
    "text": "KD木による近傍探索\nここでは，KD木を用いた近傍探索について考えます．KD木は軸並行な超平面を分離平面として，探索空間を再帰的に二つの超矩形に分割します． 従って，近傍探索は根からクエリが存在する側の超矩形を選択する深さ優先探索によって実現します．\n選ばれなかった側の超矩形に対する探索は，現在の最近傍までの距離\\(r_q\\)が，クエリから分離平面までの距離\\(r_d\\)より小さい場合（最近傍がクエリから半径\\(r_d\\)の超球内に存在）は省略することができます．これは，分離平面の向こう側には現状の最近傍よりも良いデータは存在しないためです．この性質により，KD木を用いることで探索範囲を狭めることができます．"
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#次元の変化に対する近傍探索のパフォーマンス検証",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#次元の変化に対する近傍探索のパフォーマンス検証",
    "title": "KD木と次元の呪い",
    "section": "次元の変化に対する近傍探索のパフォーマンス検証",
    "text": "次元の変化に対する近傍探索のパフォーマンス検証\nデータ数Nを32768, データ次元Dを\\(1 \\dots 1024\\)まで変化させた時，線形探索およびKD木による最近傍点探索に必要な時間を測定しました． データのサンプルとクエリは，各次元の値が\\([0.0 \\dots 1.0]\\)に一様に分布する乱数としました．\n以下に上述の測定を行うコードとその結果を示します．\n\nimport numpy as np\nimport timeit\nfrom scipy.spatial import KDTree\n\n\nN = 32768\nn = 32\n\nresult = []\nfor i in range(11):\n    D = 2 ** i\n    heystack = np.random.random((N,D))\n    kd_tree = KDTree(heystack)\n    needle = np.random.random(D)\n    \n    flat_scan = lambda:np.argmin(np.linalg.norm(heystack - needle, axis=1))\n    kd_tree_search = lambda: kd_tree.query(needle)\n    \n    flat_scan_time = timeit.timeit(flat_scan, number=n) / n\n    kd_tree_time = timeit.timeit(kd_tree_search, number=n) / n\n    result.append((flat_scan_time, kd_tree_time))\nresult = np.array(result)\n\n\n\n\n\n\n上図からデータの次元が高くなるにつれて，線形探索とKD木による探索との探索時間の差が小さくなっていることが確認できます． このことから，高次元データに対してはKD木が上手く機能していないことがわかります．"
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#高次元データの性質",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#高次元データの性質",
    "title": "KD木と次元の呪い",
    "section": "高次元データの性質",
    "text": "高次元データの性質\nd次元における1辺の長さが\\(2r\\)の超立方体と半径\\(r\\)の超球の体積をそれぞれ\\(V_C\\left(d\\right)\\)および\\(V_S\\left(d\\right)\\)とします．するとこれらは以下のように表されます．\n\\[\n\\begin{aligned}\nV_C\\left(d\\right) &= \\left(2r\\right)^{d} \\\\\nV_S\\left(d\\right) &= \\frac{r^{d}\\pi^{\\frac{d}{2}}}{\\frac{d}{2}\\Gamma\\left(\\frac{d}{2}\\right)}\n\\end{aligned}\n\\]\n次にこれらの比\\(\\frac{V_S}{V_C}\\)を考えます．\n\\[\n\\begin{aligned}\n\\frac{V_S\\left(d\\right)}{V_C\\left(d\\right)} &= \\frac{\\frac{r^{d}\\pi^{\\frac{d}{2}}}{\\frac{d}{2}\\Gamma\\left(\\frac{d}{2}\\right)}}{ \\left(2r\\right)^{d}}\\\\\n&= \\left(\\frac{\\sqrt{\\pi}}{2}\\right)^{d}\\frac{1}{\\frac{d}{2}\\Gamma\\left(\\frac{d}{2}\\right)}\n\\end{aligned}\n\\]\nここで\n\\[\n\\begin{aligned}\n\\frac{\\pi}{2} &\\simeq 0.886\\\\\n& \\lt 1\n\\end{aligned}\n\\]\nとなるので，\n\\[\n\\begin{aligned}\n\\lim_{d \\rightarrow \\infty} \\frac{V_S\\left(d\\right)}{V_C\\left(d\\right)} &= 0\n\\end{aligned}\n\\]\nとなります．　また，実際に\\(\\frac{V_S\\left(d\\right)}{V_C\\left(d\\right)}\\)を計算した結果を以下に示します．この結果より，\\(\\frac{V_S\\left(d\\right)}{V_C\\left(d\\right)}\\)は高速に\\(0\\)へ収束することが確認できます．\n\nimport math\nfrom scipy.special import gamma\nimport pandas as pd\n\ndef vs_over_vc(d: int) -> float:\n    return ((math.sqrt(math.pi) / 2) ** d) / gamma(d / 2 + 1)\n\npd.DataFrame([(i, vs_over_vc(i)) for i in range(1, 10)], columns=[\"d\", \"vs/vc\"]).set_index(\"d\")\n\n\n\n\n\n  \n    \n      \n      vs/vc\n    \n    \n      d\n      \n    \n  \n  \n    \n      1\n      1.000000\n    \n    \n      2\n      0.785398\n    \n    \n      3\n      0.523599\n    \n    \n      4\n      0.308425\n    \n    \n      5\n      0.164493\n    \n    \n      6\n      0.080746\n    \n    \n      7\n      0.036912\n    \n    \n      8\n      0.015854\n    \n    \n      9\n      0.006442\n    \n  \n\n\n\n\n次に，KD木において探索領域が1辺の長さが\\(2r_d\\)の超立方体に区切られ，クエリがその中心に位置する場合を考えます． ここで，データは探索領域中に一様に分布するものとします．すると，クエリを中心とした半径\\(r_d\\)の超球内にデータが存在する確率は$ \\(となります．この値はデータの次元が高くなるほど小さくなります．したがって、高次元データにおいては，クエリを中心とした半径\\)r_d$の超球内にはほとんどデータが存在せず，大多数は超立方体の角に存在すると考えられます．\nまた，上述の結果について超立方体の対角線に着目すると非常に面白い性質を確認できます．ここで，d次元における１辺の長さが\\(r\\)である超立方体の対角線の長さ\\(d_{d}\\left(r\\right)\\)を考えます．この\\(d_{d}\\left(r\\right)\\)は以下の様に求めることができます．\n\\[\n\\begin{aligned}\nd_{d}\\left(r\\right) &= \\sqrt{\\sum^{d}r^{2}}\\\\\n&= \\sqrt{d}r\n\\end{aligned}\n\\]\n以上の結果より，\\(d\\)次元の超立方体の対角線の長さは\\(\\sqrt{d}\\)に比例して大きくなることがわかります．これは，データの大多数が超立方体の角に存在するという前述の結果とも一致します．この性質について非常に興味深い図があったので紹介します[1]．\n\n\n\n\n\nclass\n\n\n上図は左から，2次元，4次元，\\(d\\)次元における超立方体と超球との関係のイメージです．\\(d_{2}\\left(1\\right) = \\sqrt{2}\\)であることから，超立方体が超球に内包されています．また\\(d_{4}\\left(1\\right) = 2\\)であることから，超立方体が超球に内接しています．同様に\\(d_{d}\\left(1\\right)=\\sqrt{d}\\)であることから，超立方体の角が超球の外へ飛び出しています．\nこの図はあくまでもイメージです．従って実際の高次元空間はこんなにも単純ではないのかもしれません．しかしながら， 低次元では超球に内包されていた超立方体が 高次元ではその角が超球をはみ出してしまう という性質は直感に反しており非常に興味深いと思いました．\n先に述べた通り，KD木による高速な近傍探索は最近傍がクエリから半径\\(r_d\\)の超球内に存在する場合に探索を省略することができるためでした．従って，この条件が成立しない高次元データでは探索を省略することはできません．この結果，KD木による探索の効率はデータの次元が高くなるにつれて低下します．"
  },
  {
    "objectID": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#参考文献",
    "href": "posts/2022-02-16-kdtree-and-curse-of-dimensionality.html#参考文献",
    "title": "KD木と次元の呪い",
    "section": "参考文献",
    "text": "参考文献\n\n\n[1] Guruswami, V. and Kannanb, R. 2012. Computer science theory for the information age, spring 2012. https://www.cs.cmu.edu/~venkatg/teaching/CStheory-infoage/.\n\n\n[2] Wikipedia 2022. Kd木 — Wikipedia, the free encyclopedia. http://ja.wikipedia.org/w/index.php?title=Kd%E6%9C%A8."
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "",
    "text": "以前の記事で，smart_openによって統一的にファイルアクセスが可能であることを紹介しました． しかしながら，//を適切に扱うことができないため，URLを扱うには問題がありました． そこで，この問題を解決しsmart_openをラップしたpaaaaathを作成しました．"
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#やったこと",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#やったこと",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "やったこと",
    "text": "やったこと\n\npaaaaathの導入\npaaaaathによるクラウドストレージ上のファイルを操作"
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#paaaaathについて",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#paaaaathについて",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "paaaaathについて",
    "text": "paaaaathについて\npaaaaathはローカルマシン上のファイルパスのみでは無く，http, s3, gcsといったプロトコルのURLもpathlib.Pathと同様に取り扱うことができます．ファイルの読み書きはsmart_openに処理を委譲することで実現します．また，s3, gcsについては，mkdir, iterdirs, exitsといった処理にも対応しています．サポートしている機能の詳細については，リポジトリを確認してくさい．\n以下にpipを用いたpaaaaathの導入方法を示します．ここでは，extrasとしてallを指定しました．ほかにも，http, gcs,s3 が指定可能です．allはこれら全てを指定することと同義です．\n$ pip install paaaaath[all]"
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#クラウドストレージwebからファイルを読み込む",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#クラウドストレージwebからファイルを読み込む",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "クラウドストレージ，Webからファイルを読み込む",
    "text": "クラウドストレージ，Webからファイルを読み込む\nsmart_openによるサンプルをpaaaaathを用いて書き直しました．Pathlikeオブジェクトとして取り扱うことができるので，全体的にシンプルになっていることが確認できると思います．こちらも，事前に適切な認証情報を設定しておく必要があります．\n\nfrom paaaaath import Path\nimport matplotlib.pyplot as plt\nimport imageio\n\nsources = {\n    \"S3\": \"s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF\",\n    \"HTTP\":  \"https://s3-us-west-2.amazonaws.com/landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF\",\n    \"FILESYSTEM\": \"/tmp/LC80030172015001LGN00_BQA.TIF\"\n}\n\nfor protocol, url in sources.items():\n    img = imageio.imread(Path(url).read_bytes())\n    plt.figure()\n    plt.title(f\"from {protocol}\")\n    plt.imshow(img, cmap='gray')"
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#クラウドストレージ上のファイルを操作する",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#クラウドストレージ上のファイルを操作する",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "クラウドストレージ上のファイルを操作する",
    "text": "クラウドストレージ上のファイルを操作する\npaaaaathを用いてクラウドストレージ上のファイルを読み書きする例を以下に示します．\n\nsample_path = Path(\"s3://paaaaath-examples/sample.txt\")\nsample_path.write_text(\"paaaaath example\")\nassert sample_path.read_text() == \"paaaaath example\"\n\nまた，paaaaathはPathlikeオブジェクトを提供します．そのため，単純なファイルの読み書きだけでは無く，より多くの機能を提供することが可能です．以下に，iterdirを用いてクラウドストレージ上のファイル一覧を取得する例を示します．\n\npaths = list(Path(sources[\"S3\"]).parent.iterdir())\nassert paths[0].exists()\npaths      \n\n[S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B1.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B1.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B10.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B10.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B11.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B11.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B2.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B2.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B3.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B3.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B4.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B4.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B5.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B5.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B6.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B6.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B7.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B7.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B8.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B8.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B9.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_B9.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_BQA.TIF.ovr'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_MTL.json'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_MTL.txt'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_thumb_large.jpg'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/LC80030172015001LGN00_thumb_small.jpg'),\n S3Path('s3://landsat-pds/L8/003/017/LC80030172015001LGN00/index.html')]"
  },
  {
    "objectID": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#参考",
    "href": "posts/2021-06-06-accessing-file-wiht-unified-pythonic-api2.html#参考",
    "title": "paaaaathによる統一的なファイルアクセス",
    "section": "参考",
    "text": "参考\n\n\n[1] Smartopen. GitHub repository. https://github.com/RaRe-Technologies/smart_open; GitHub."
  },
  {
    "objectID": "posts/2021-08-01-writing-simple-ping-example.html",
    "href": "posts/2021-08-01-writing-simple-ping-example.html",
    "title": "Pythonでpingの実装してみる",
    "section": "",
    "text": "ネットワークの疎通確認を行う際など，pingコマンドにお世話になっている方は多いと思います．私も勿論その一人です． ですが，実際pingは何をしているのか？という点は前々理解していませんでした．そこで，pythonにてpingのサブセット（エコー要求とエコー応答のみ）を実装してみました．"
  },
  {
    "objectID": "posts/2021-08-01-writing-simple-ping-example.html#やったこと",
    "href": "posts/2021-08-01-writing-simple-ping-example.html#やったこと",
    "title": "Pythonでpingの実装してみる",
    "section": "やったこと",
    "text": "やったこと\n\nPythonでpingコマンドのサブセットを実装\nエコー要求に対してエコー応答が返信されることを確認"
  },
  {
    "objectID": "posts/2021-08-01-writing-simple-ping-example.html#icmpについて",
    "href": "posts/2021-08-01-writing-simple-ping-example.html#icmpについて",
    "title": "Pythonでpingの実装してみる",
    "section": "ICMPについて",
    "text": "ICMPについて\nICMPとはInternet Control Message Protocolの略称です．名前の通り，インターネットの通信に関する情報の送信に用いられます． pingコマンドは，このプロトコルのエコー要求とエコー応答という二つのメッセージをやりとりすることで，端末間の疎通確認を行います．\nエコー要求とエコー応答のパケットフォーマットは以下の通りです．\n\n\n\nicmp spec\n\n\nなお，これらのメッセージはIPデータグラムのペイロードとして送受信されます．"
  },
  {
    "objectID": "posts/2021-08-01-writing-simple-ping-example.html#pythonによる実装",
    "href": "posts/2021-08-01-writing-simple-ping-example.html#pythonによる実装",
    "title": "Pythonでpingの実装してみる",
    "section": "Pythonによる実装",
    "text": "Pythonによる実装\n\nエコー要求とエコー応答に対応するデータ構造\n上述のパケットフォーマットにおけるTypeは，エコー要求では8が，エコー応答では0が設定されます． 従って，以下のようにICMPTypeとして定義することができます．\n\nfrom enum import Enum\n\nclass ICMPType(Enum):\n    ECHOREPLY = 0\n    ECHO = 8\n\n    def __int__(self):\n        return self.value\n\nまた，パケットフォーマットからチェックサムフィールドを確認することができます． このチェックサムは以下の手順で計算します．\n\nチェックサムフィールドを0で埋める\nパケットを16ビット単位で区切る（パケット長が奇数バイトである場合は0x00を末尾に追加）\n16ビット単位で区切ったデータを1の補数で加算していき合計値を求める\n加算結果の1の補数を最終結果とする．この時，0の表現としては0xffffを用いる．\n\n以上の手順でチェックサムを計算する関数calc_checksumを以下のように定義します．\n\ndef calc_checksum(data: bytes) -> int:\n    if len(data) % 2 == 1:\n        data += b\"\\x00\"\n    u16_counts = len(data) // 2\n    checksum = sum(struct.unpack(f\"!{u16_counts}H\", data))\n    while 0xFFFF < checksum:\n        checksum = (checksum & 0xFFFF) + (checksum >> 16)\n    if checksum != 0xFFFF:\n        checksum = ~checksum\n    return checksum & 0xFFFF\n\n以下に示すICMPEchoがエコー要求とエコー応答を表現するデータ構造となります．checksumがコンストラクタ引数として指定されなかった場合は，calc_checksumにて計算します．\nICMPEchoはネットワークを通して送受信されます．従って，シリアライズを行うto_bytesと，デシリアライズを行うfrom_bytesを実装しています．\n\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport struct\n\n@dataclass(frozen=True)\nclass ICMPEcho:\n    type: ICMPType\n    code: int\n    id: int\n    seq: int\n    data: bytes\n    checksum: Optional[int] = None\n\n    def __post_init__(self):\n        if self.checksum is None:\n            object.__setattr__(self, \"checksum\", 0)\n            object.__setattr__(self, \"checksum\", calc_checksum(self.to_bytes()))\n\n    def to_bytes(self) -> bytes:\n        return struct.pack(\n            f\"!BBHHH{len(self.data)}s\",\n            int(self.type),\n            self.code,\n            self.checksum,\n            self.id,\n            self.seq,\n            self.data,\n        )\n\n    @classmethod\n    def from_bytes(cls, packed: bytes) -> \"ICMPEcho\":\n        _type, code, checksum, id, seq = struct.unpack(\"!BBHHH\", packed[:8])\n        type = ICMPType(_type)\n        data = packed[8:]\n        return ICMPEcho(type, code, id, seq, data, checksum=checksum)\n\n\n\nRawソケットの作成\nTCPやUDPを用いた時と同様，ICMPでもソケットを用いてネットワークプログラミングを行います． しかしながら，ICMPパケットはIPデータグラムのペイロードとするため，IPデータグラムを操作する必要があります．\nIPデータグラムの操作はRawソケットを用いることで実現できます．そこで，ソケットを作成する関数raw_socketを以下のように定義しました． socket.socketの第２引数にはsocket.SOCK_RAWを第３引数にはsocket.IPPROTO_ICMPを指定します．これは，RawソケットをICMPから利用することを表していいます．\n\nimport socket\nfrom contextlib import contextmanager\n\n@contextmanager\ndef raw_socket():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    try:\n        yield sock\n    finally:\n        sock.close()\n\n\n\nIPデータグラムのパース\nRawソケットによって受信したデータはIPデータグラムです．従って，これを適切にパースし，エコー応答をペイロードとして取り出す必要があります． 今回，以下のようにIPヘッダを表現するIPHeaderと，IPデータグラムをパースするparse_ip_datagram関数を実装しました． parse_ip_datagram関数では，受信したデータの先頭２０バイトからIPHeaderインスタンスを作成し，残りのデータをペイロードとします．\n\nfrom typing import Tuple\n\n@dataclass(frozen=True)\nclass IPHeader:\n    v: int\n    hl: int\n    tos: int\n    len: int\n    id: int\n    off: int\n    ttl: int\n    p: int\n    sum: int\n    src: str\n    dst: str\n\n    @staticmethod\n    def from_bytes(packed: bytes) -> \"IPHeader\":\n        v_hl, tos, len, id, off, ttl, p, sum, src, dst = struct.unpack(\n            \"!BBHHHBBHII\", packed\n        )\n        v = v_hl >> 4\n        hl = v_hl & 0x0F\n\n        return IPHeader(\n            v,\n            hl,\n            tos,\n            len,\n            id,\n            off,\n            ttl,\n            p,\n            sum,\n            socket.inet_ntoa(src.to_bytes(4, byteorder=\"big\")),\n            socket.inet_ntoa(dst.to_bytes(4, byteorder=\"big\")),\n        )\n\ndef parse_ip_datagram(data: bytes) -> Tuple[IPHeader, bytes]:\n    ip_header = IPHeader.from_bytes(data[:20])\n    payload = data[20:]\n    return (ip_header, payload)\n\n\n\nエコー要求の送信とエコー応答の受信\nこれまで実装してきた関数とデータ構造を用いて，エコー要求を送信しエコー応答を受信する関数pingを実装しました． 以下に示されるように，エコー要求をソケットに書き込み，ソケットから読み取ったエコー応答とIPヘッダを出力します．\n\ndef print_response(ip_header: IPHeader, echo_reply: ICMPEcho) -> None:\n    print(\n        f\"ping echo reply from {ip_header.src}: icmp_seq={echo_reply.seq} ttl={ip_header.ttl}\"\n    )\n\n\ndef ping(host: str, seq: int) -> None:\n    with raw_socket() as sock:\n        packet = ICMPEcho(ICMPType.ECHO, 0, 0, seq, b\"\\xff\").to_bytes()\n        sock.sendto(packet, (host, 0))\n        ip_header, payload = parse_ip_datagram(sock.recvfrom(4096)[0])\n        echo_reply = ICMPEcho.from_bytes(payload)\n        print_response(ip_header, echo_reply)\n\n\n\n実行結果\n実際に8.8.8.8に対してpingを呼び出した結果を以下に示します． エコー要求に対して適切なエコー応答が帰ってきていることが確認できます．\n\nimport time\nfor i in range(10):\n    ping(\"8.8.8.8\", i)\n    time.sleep(1)\n\nping echo reply from 8.8.8.8: icmp_seq=0 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=1 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=2 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=3 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=4 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=5 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=6 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=7 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=8 ttl=37\nping echo reply from 8.8.8.8: icmp_seq=9 ttl=37"
  },
  {
    "objectID": "posts/2021-08-01-writing-simple-ping-example.html#参考",
    "href": "posts/2021-08-01-writing-simple-ping-example.html#参考",
    "title": "Pythonでpingの実装してみる",
    "section": "参考",
    "text": "参考\n\n\n[1] 村山公保. 2004. 基礎からわかるTCP/IPネットワーク実験プログラミング. オーム社."
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "",
    "text": "多峰性のある分布表現する方法として，ガウス分布の線形結合を用いる混合ガウスモデルが広く知られています． しかしがなら，観測したサンプルから混合ガウスモデルのパラメータを解析的の求めることはできません． そのため，EMアルゴリズム等を用いて数値計算的にパラメータを推定します．\nEMアルゴリズムを用いた混合ガウスモデルのパラメータ推定は多くの資料で解説されています． これらの資料を読み解こうと何度か挑戦しましたが，どうもしっくりと来ませんでした． ですが，参考[1]述べられている，線形結合の重みとしてソフトマックス関数を用いる方法がとても理解しやすかったので，自分なりの理解をまとめました．"
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#やったこと",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#やったこと",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "やったこと",
    "text": "やったこと\n\n線形結合の重みとしてソフトマックス関数を用いた場合における各パラメータの導関数を計算\n勾配法によって混合ガウスモデルのパラメータを推定\nEMアルゴリズムによって混合ガウスモデルのパラメータを推定"
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#混合ガウスモデルについて",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#混合ガウスモデルについて",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "混合ガウスモデルについて",
    "text": "混合ガウスモデルについて\n平均を\\(\\mu\\)，標準偏差を\\(\\sigma\\)としたとき，ガウス分布\\(\\phi\\left(x; \\mu, \\sigma\\right)\\)は以下の様に表されます．\n\\[\n\\begin{aligned}\n\\phi\\left(x; \\mu, \\sigma\\right) & = \\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp{\\left(- \\frac{\\left(x - \\mu\\right)^{2}}{2\\sigma^{2}}\\right)}\n\\end{aligned}\n\\]\nこの時，ガウス分布の線形結合からなる混合ガウスモデル\\(q\\left(x; \\vec{\\theta}\\right)\\)は以下の様に表すことができます．\n\\[\n\\begin{aligned}\nq\\left(x; \\vec{\\theta}\\right) &= \\sum_{l=1}^{m} w_{l}\\phi\\left(x; \\mu_{l}, \\sigma_{l}\\right)\n\\end{aligned}\n\\]\nここで，\\(\\vec{\\theta} = \\left(w_{1}, \\dots, w_{m},\\mu_{1}, \\dots, \\mu_{m}, \\sigma_{1}, \\dots, \\sigma_{m}\\right)\\)であり，\\(w_{l}\\)は線形結合の重みを，\\(\\mu_{l}\\)は各ガウス分布の平均を，\\(\\sigma_{l}\\)は各ガウス分布の標準偏差をそれぞれ表します．\n\\(q\\left(x; \\vec{\\theta}\\right)\\) が分布であるためには，\\(x\\)に対して\n\\[\n\\begin{aligned}\nq\\left(x; \\vec{\\theta}\\right) &\\geq 0 \\\\\n\\int q\\left(x; \\vec{\\theta}\\right) &= 1\n\\end{aligned}\n\\]\nである必要があります．従って，\\(w_{1}, \\dots, w_{m}\\)は以下の条件を満たす必要があります．\n\\[\n\\begin{aligned}\nw_{1} \\dots w_{m} &\\geq 0 \\\\\n\\sum_{l=1}^{m} w_{l} &= 1\n\\end{aligned}\n\\]\n次に最尤推定によってパラメータ\\(\\vec{\\theta}\\)を推定します．ここでは，尤度関数\\(L\\left(\\vec{\\theta}\\right)\\)を以下の様に定義します．\n\\[\n\\begin{aligned}\nL\\left(\\vec{\\theta}\\right) &= \\prod _{i=1}^{n} q\\left(x_{i}; \\vec{\\theta}\\right)\n\\end{aligned}\n\\]\nまた，\\(w_{l}\\)に対する拘束条件を考慮しなくてはなりません．従って，最尤推定量\\(\\vec{\\theta}\\)は以下の様に表されます．\n\\[\n\\begin{aligned}\n\\hat{\\vec{\\theta}} &= \\argmax_{\\vec{\\theta}} L\\left(\\vec{\\theta}\\right) & \\text{subject to } \\begin{cases}\n  w_{1} \\dots w_{m} &\\geq 0\\\\\n\\sum_{l=1}^{m} w_{l} &= 1\n  \\end{cases}\n\\end{aligned}\n\\]\n拘束条件付きの最適化にはラグランジュの未定乗数法が多く用いられていると思います．今回のケースにおいても同様です．\nしかしながら，ラグランジュの未定乗数法を用いる方法はあまりしっくり来きませんでした．（理解できなかった） そこで，ここでは参考[1]にある\\(w_{l}\\)としてソフトマック関数を用いる方法を採用します．従って\\(w_{l}\\)は\\(\\gamma_{l}\\)を用いて\n\\[\n\\begin{aligned}\nw_{l} &= \\frac{\\exp{\\left(\\gamma_{l}\\right)}}{\\sum_{l' = 1}^{m}\\exp{\\left(\\gamma_{l’}\\right)}}\n\\end{aligned}\n\\]\nと表現することにします．ソフトマックス関数は上述の拘束条件を満たすため，拘束条件を考えることなく最適化を行うことができます．また，ここでは１次元の混合ガウスモデルについて述べましたが，多次元の場合も同様です．"
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#勾配法によるパラメータの推定",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#勾配法によるパラメータの推定",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "勾配法によるパラメータの推定",
    "text": "勾配法によるパラメータの推定\nそれでは，対数尤度関数\\(\\log L\\left(\\vec{\\theta}\\right)\\)の各パラメータに対する導関数を計算していきます．まずは，\\(\\gamma_{l}\\)についてです．\n\\[\n\\begin{aligned}\n\\frac{\\partial w_{k}}{\\partial \\gamma_{l}} &= \\frac{\\partial}{\\partial \\gamma_{l}} \\frac{\\exp{\\left(\\gamma_{k}\\right)}}{\\sum_{k'=1}^{m}\\exp{\\left(\\gamma_{k'}\\right)}} \\\\\n&= \\frac{\\exp{\\left(\\gamma_{k}\\right)}}{\\sum_{k'=1}^{m}\\exp{\\left(\\gamma_{k'}\\right)}}\\delta_{k,l} - \\frac{\\exp{\\left(\\gamma_{k}\\right)}\\exp{\\left(\\gamma_{l}\\right)}}{\\left(\\sum_{k'=1}^{m}\\exp{\\left(\\gamma_{k'}\\right)}\\right)^{2}}\\\\\n&= \\frac{\\exp{\\left(\\gamma_{k}\\right)}}{\\sum_{k'=1}^{m}\\exp{\\left(\\gamma_{k'}\\right)}}\\left(\\delta_{k,l} - \\frac{\\exp{\\left(\\gamma_{l}\\right)}}{\\sum_{k'=1}^{m}\\exp{\\left(\\gamma_{k'}\\right)}}\\right)\\\\\n&= w_{k}\\left(\\delta_{k,l} - w_{l}\\right)\\\\\n\\frac{\\partial}{\\partial \\gamma_{l}} \\log L\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\gamma_{l}} \\sum_{i=1}^{n} \\log \\sum_{k}^{m} w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\sum_{k=1}^{m} \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\frac{\\partial w_{k}}{\\partial \\gamma_{l}}\\\\\n&=  \\sum_{i=1}^{n} \\frac{\\sum_{k=1}^{m} w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\delta_{k,l} -w_{l}\\sum_{k=1}^{m} w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\\\\n&=  \\sum_{i=1}^{n} \\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} - w_{l} \\\\\n\\end{aligned}\n\\]\n次に，\\(\\mu_{l}\\)についてです．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\mu_{l}}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) &= \\frac{1}{\\sqrt{2 \\pi \\sigma_{k}^{2}}}\\frac{\\partial}{\\partial \\mu_{l}}  \\exp{\\left(- \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2}}{2\\sigma_{k}^{2}}\\right)} \\\\\n&= \\frac{1}{\\sqrt{2 \\pi \\sigma_{k}^{2}}} \\exp{\\left(- \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2}}{2\\sigma_{k}^{2}}\\right)} \\frac{x_{i} - \\mu_{k}}{\\sigma_{k}^{2}} \\delta_{k,l} \\\\\n&= \\frac{x_{i} - \\mu_{k}}{\\sigma_{k}^{2}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\delta_{k,l}\\\\\n\\frac{\\partial}{\\partial \\mu_{l}} \\log L\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\mu_{l}} \\sum_{i=1}^{n} \\log \\sum_{k}^{m} w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\sum_{k=1}^{m}   w_{k}  \\frac{\\partial}{\\partial \\mu_{l}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\sum_{k=1}^{m}   w_{k} \\frac{x_{i} - \\mu_{k}}{\\sigma_{k}^{2}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\delta_{k,l}\\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)}   w_{l} \\frac{x_{i} - \\mu_{l}}{\\sigma_{l}^{2}}  \\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)\\\\\n&= \\frac{1}{\\sigma_{l}^{2}} \\sum_{i=1}^{n} \\left(x_{i} - \\mu_{l}\\right) \\frac{w_{l} \\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)  }{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)}  \\\\\n\\end{aligned}\n\\]\n最後に，\\(\\sigma_{l}\\)についてです．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\sigma_{l}}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) &= \\frac{1}{\\sqrt{2 \\pi}} \\frac{\\partial}{\\partial \\sigma_{l}}  \\sigma_{k}^{-1} \\exp{\\left(- \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2}}{2\\sigma_{k}^{2}}\\right)} \\\\\n&= -\\frac{1}{\\sqrt{2\\pi}\\sigma_{k}^{2}} \\exp{\\left(- \\frac{\\left(x - \\mu_{k}\\right)^{2}}{2\\sigma_{k}^{2}}\\right)} \\delta_{k,l}  + \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2}}{\\sqrt{2\\pi}\\sigma_{k}^{4}} \\exp{\\left(- \\frac{\\left(x - \\mu_{k}\\right)^{2}}{2\\sigma_{k}^{2}}\\right)} \\delta_{k,l}\\\\\n&= \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2} - \\sigma_{k}^{2}}{\\sigma_{k}^{3}} \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\delta_{k,l}\\\\\n\\frac{\\partial}{\\partial \\sigma_{l}} \\log L\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\sigma_{l}} \\sum_{i=1}^{n} \\log \\sum_{k}^{m} w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\sum_{k=1}^{m}   w_{k}  \\frac{\\partial}{\\partial \\sigma_{l}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\\\\n&= \\sum_{i=1}^{n}\\frac{1}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)} \\sum_{k=1}^{m}   w_{k}  \\frac{\\left(x_{i} - \\mu_{k}\\right)^{2} - \\sigma_{k}^{2}}{\\sigma_{k}^{3}} \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\delta_{k,l}\\\\\n&= \\frac{1}{\\sigma_{l}^{3}}\\sum_{i=1}^{n}  \\left(\\left(x_{i} - \\mu_{l}\\right)^{2} - \\sigma_{l}^{2}\\right) \\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)}  \n\\end{aligned}\n\\]\nここで，\n\\[\n\\begin{aligned}\n\\eta_{i,l} &=  \\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{\\sum_{k'=1}^{m} w_{k'}\\phi\\left(x_{i}; \\mu_{k'}, \\sigma_{k'}\\right)}\n\\end{aligned}\n\\]\nと置きます．すると最終的な導関数は以下の様に表されます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\gamma_{l}} \\log L\\left(\\vec{\\theta}\\right) &= \\sum_{i=1}^{n} \\eta_{i,l} - w_{l} \\\\\n\\frac{\\partial}{\\partial \\mu_{l}} \\log L\\left(\\vec{\\theta}\\right) &= \\frac{1}{\\sigma_{l}^{2}} \\sum_{i=1}^{n} \\left(x_{i} - \\mu_{l}\\right) \\eta_{i,l}\\\\\n\\frac{\\partial}{\\partial \\sigma_{l}} \\log L\\left(\\vec{\\theta}\\right) &=\\frac{1}{\\sigma_{l}^{3}}\\sum_{i=1}^{n}  \\left(\\left(x_{i} - \\mu_{l}\\right)^{2} - \\sigma_{l}^{2}\\right)\\eta_{i,l}\n\\end{aligned}\n\\]\n次に勾配法を用いてパラメータの推定を行っていきます．具体的な手順は以下の通りです．\n\n\\(\\hat{\\gamma_{l}}\\), \\(\\hat{\\mu_{l}}\\), \\(\\hat{\\sigma_{l}}\\)をランダムな値で初期化\n以下に示す様にパラメータを更新\n\\[\n\\begin{aligned}\n\\hat{\\gamma_{l}} &= \\hat{\\gamma_{l}} + \\epsilon \\frac{\\partial}{\\partial \\gamma_{l}} \\log L\\left(\\vec{\\theta}\\right) \\\\\n\\hat{\\mu_{l}} &= \\hat{\\mu_{l}} + \\epsilon \\frac{\\partial}{\\partial \\mu_{l}} \\log L\\left(\\vec{\\theta}\\right) \\\\\n\\hat{\\sigma_{l}} &= \\hat{\\sigma_{l}} + \\epsilon \\frac{\\partial}{\\partial \\sigma_{l}} \\log L\\left(\\vec{\\theta}\\right) \\\\\n\\end{aligned}\n\\]\n一定回数または収束するまで2.を繰り返す\n\n実際にパラメータ推定に関するコードを記述する前に，推定を行うデータを作成します． 今回，\\(\\vec{\\mu} = \\left(3.1, -1.3, 0.5\\right)\\), \\(\\vec{\\sigma} = \\left(0.8, 1.0, 0.5 \\right)\\), \\(\\vec{w} = \\left(0.25, 0.25, 0.5\\right)\\)として，2048個の標本をサンプリングすることで検証用のデータを作成しました．\n\nimport numpy as np\nnp.random.seed(99)\n\nmus =  np.array([3.1, -1.3, 0.5])\nsigmas =  np.array([0.8, 1.0, 0.5])\nns = np.array([512, 512, 1024])\nN = np.sum(ns)\nws = ns / N\n\ndata = [np.random.normal(m, s, n) for n, m, s in zip(ns, mus, sigmas)]\nall_data = np.hstack(data)\n\n勾配法によるパラメータ推定を行います．train_grad が上述したパラメータ推定の根幹になります． ここでは，\\(\\epsilon = 0.0001\\)とし，パラメータの変化量の絶対値和が一定値以下となる場合を収束と判定しています．\n\ndef phi(xs, mus, sigmas):\n    num = np.exp(-0.5 * ((xs - mus[:,np.newaxis]) / sigmas[:,np.newaxis]) ** 2.0)\n    den = np.sqrt(2 * np.pi) * sigmas[:,np.newaxis]\n    return num / den\n\ndef eta(xs, ws, mus, sigmas):\n    num = ws[:, np.newaxis] * phi(xs, mus, sigmas)\n    den = np.sum(num, axis=0)\n    return num / den\n\ndef softmax(gammas):\n    num = np.exp(gammas)\n    den = np.sum(num, axis=0)\n    return num / den\n\ndef grad_gamma(etas, ws):\n    return np.sum(etas, axis=1) - etas.shape[1] * ws\n\ndef grad_mu(xs, etas, mus, sigmas):\n    num = np.sum((xs - mus[:, np.newaxis]) * etas, axis=1)\n    den =sigmas ** 2.0\n    return num / den\n\ndef grad_sigma(xs, etas, mus, sigmas):\n    num = np.sum((((xs - mus[:, np.newaxis]) / sigmas[:,np.newaxis]) ** 2.0 - 1.0) * etas, axis=1)\n    den = sigmas \n    return num / den\n\ndef train_grad(xs):\n    mus_hat = 2 * np.max(np.abs(xs)) * (np.random.rand(3) - 0.5)\n    sigmas_hat = np.random.rand(3)\n    gammas_hat = np.random.rand(3)\n\n    eps = 0.0001\n    loss = float('inf')\n    criteria = 1e-10\n    iter = 0;\n    while iter < 30000:\n        ws_hat = softmax(gammas_hat)\n        etas_hat = eta(xs, ws_hat, mus_hat, sigmas_hat)\n\n        delta_gammas = eps * grad_gamma(etas_hat, ws_hat)\n        delta_mus = eps * grad_mu(xs, etas_hat, mus_hat, sigmas_hat)\n        delta_sigmas = eps * grad_sigma(xs, etas_hat, mus_hat, sigmas_hat)\n\n        gammas_hat += delta_gammas\n        mus_hat += delta_mus\n        sigmas_hat += delta_sigmas\n        loss = np.sum(np.abs(np.hstack([delta_gammas, delta_mus, delta_sigmas])))\n        if loss < criteria:\n            break\n        iter += 1\n\n    ws_hat = softmax(gammas_hat)\n    return loss, iter, (ws_hat, mus_hat, sigmas_hat)\n\nloss, iter, (ws_hat_grad, mus_hat_grad, sigmas_hat_grad) = train_grad(all_data)\nprint(f\"loss: {loss}, iterations: {iter}\")\n\nloss: 9.995055674503072e-08, iterations: 16943\n\n\n最後に推定したパラメータws_hat_grad, mus_hat_grad, sigmas_hat_grad を用いた分布と，訓練データとをプロットして比較します． 勾配法による推定は，パラメータの並びについて曖昧さがあります．これは，\\(\\hat{w_{l}}\\)と\\(w_{l}\\)とが必ずしも対応するとは限らないことを意味します．（他のパラメータも同様）\nそこで，プロットに先立ちws_hat_grad, mus_hat_grad, sigmas_hat_gradとws, mus, sigmasとを比較して，並び順を入れ変えることでこの問題に対応します． この処理はpermute にて行われます．\n\nimport altair as alt\nimport pandas as pd\n\ndef permute(ws, mus, sigmas, ws_hat, mus_hat, sigmas_hat):\n    preds = np.vstack([ws_hat, mus_hat, sigmas_hat])\n    acts = np.vstack([ws, mus, sigmas])\n    corr = preds.T @ acts / (np.linalg.norm(preds, axis=0)[:, np.newaxis] @ np.linalg.norm(acts, axis=0)[np.newaxis,:])\n    perm = np.argmax(corr, axis=0)\n    ws_hat = ws_hat[perm]\n    mus_hat = mus_hat[perm]\n    sigmas_hat = sigmas_hat[perm]\n    return (ws_hat, mus_hat, sigmas_hat)\n\ndef plot(data, ws_hat, mus_hat, sigmas_hat):\n    bins = np.linspace(-6, 6, 128)\n    hists = {f\"Class {i}\": (128 / (12 * N)) * np.histogram(d, bins=bins)[0] for i, d in enumerate(data)}\n\n    bin_centers = (bins[:-1] + bins[1:]) / 2\n    bars = alt.Chart(pd.DataFrame({\n        \"Bin\": bin_centers,\n        **hists,\n    })).transform_fold(\n        fold=[f\"Class {i}\" for i in range(len(data))],\n        as_=[\"Class\", \"Probability\"]\n    ).mark_bar(opacity=0.5).encode(\n        alt.X(\"Bin:Q\"),\n        alt.Y(\"Probability:Q\"),\n        alt.Color('Class:N')\n    )\n\n    envelopes = {f\"Class {i}\": v for i, v in enumerate(ws_hat[:, np.newaxis] * phi(bin_centers, mus_hat, sigmas_hat))}\n    lines = alt.Chart(\n    pd.DataFrame({\n        \"Bin\": bin_centers,\n        **envelopes,\n    })).transform_fold(\n        fold=[f\"Class {i}\" for i in range(len(data))],\n        as_=[\"Class\", \"Probability\"]\n    ).mark_line(size=3).encode(\n        alt.X(\"Bin:Q\"),\n        alt.Y(\"Probability:Q\"),\n        alt.Color('Class:N')\n    )\n\n    return bars + lines\n\nws_hat_grad, mus_hat_grad, sigmas_hat_grad = permute(ws, mus, sigmas, ws_hat_grad, mus_hat_grad, sigmas_hat_grad)\nplot(data, ws_hat_grad, mus_hat_grad, sigmas_hat_grad)\n\n\n\n\n\n\n以上の結果より，適切に推定できていることが確認できました．しかしながら，勾配法による方法は\n\n初期値によっては推定に失敗する場合がある\n\\(\\epsilon\\)の選択によっては推定に失敗する場合がある\n収束が遅い\n\nという問題があります．これらの問題に対応するため，EMアルゴリズムによるパラメータ推定を以下に述べます．"
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#emアルゴリズムによるパラメータの推定",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#emアルゴリズムによるパラメータの推定",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "EMアルゴリズムによるパラメータの推定",
    "text": "EMアルゴリズムによるパラメータの推定\n次にEMアルゴリズムによるパラメータの推定を行います．EMアルゴリズムは混合ガウスモデルのパラメータ推定以外にも利用可能な汎用的なアルゴリズムです．しかしながら，ここではあまり深入りせずに混合ガウスモデルのパラメータ推定方法の一つとして取り扱います．\nEMアルゴリズムはEステップとMステップを交互に繰り返すことで実現します．両ステップについての詳細を以下に述べます．\n\nEステップ\nEステップでは，対数尤度関数\\(\\log L\\left(\\vec{\\theta}\\right)\\)に対して，現在の推定値\\(\\hat{\\vec{\\theta}}\\)で接する下界\\(b\\left(\\vec{\\theta}\\right)\\)を求めます．すなわち，\\(b\\left(\\vec{\\theta}\\right)\\)は以下の関係を満たす必要があります．\n\\[\n\\begin{aligned}\nb\\left(\\vec{\\theta}\\right)  &\\leq \\log L\\left(\\vec{\\theta}\\right) \\\\\nb\\left(\\hat{\\vec{\\theta}}\\right)  &= \\log L\\left(\\hat{\\vec{\\theta}}\\right) \\\\\n\\end{aligned}\n\\]\n下界\\(b\\left(\\vec{\\theta}\\right)\\)を求めると聞くと非常に複雑そうに思えます．しかしながら，混合ガウスモデルのパラメータ推定という用途に限定するとそこまで複雑でもありません．まず，対数尤度関数\\(\\log L\\left(\\vec{\\theta}\\right)\\)に対してイェンセンの不等式を適用し，下界\\(b'\\left(\\vec{\\theta}; \\bf{A}\\right)\\)を求めていきます．ここで，\\(\\bf{A} = \\left\\{a_{i,l}\\right\\}\\)であり，\\(b\\left(\\vec{\\theta}\\right) = b'\\left(\\vec{\\theta}; \\hat{\\bf{A}}\\right)\\)であるとします．\n\\[\n\\begin{aligned}\n\\log L\\left(\\vec{\\theta}\\right) &=  \\sum_{i=1}^{n} \\log \\sum_{l}^{m} w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right) \\\\\n&= \\sum_{i=1}^{n} \\log \\sum_{l}^{m}  a_{i,l}\\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{a_{i,l}} \\\\\n&\\geq \\sum_{i=1}^{n} \\sum_{l}^{m}  a_{i,l} \\log\\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{a_{i,l}} \\\\\n&= b'\\left(\\vec{\\theta}; \\bf{A}\\right)\n\\end{aligned}\n\\]\n次に，\\(b'\\left(\\hat{\\vec{\\theta}}; \\hat{\\bf{A}}\\right) = \\log L\\left(\\hat{\\vec{\\theta}}\\right)\\)となる\\(\\hat{\\bf{A}}\\)を求めます． \\[\n\\begin{aligned}\nb'\\left(\\hat{\\vec{\\theta}}; \\bf{A}\\right)　&=  \\sum_{i=1}^{n} \\sum_{l}^{m}  a_{i,l} \\log\\frac{\\hat{w_{l}}\\phi\\left(x_{i}; \\hat{\\mu_{l}}, \\hat{\\sigma_{l}}\\right)}{a_{i,l}} \\\\\n& \\text{ここで$\\hat{\\vec{\\theta}}$に対する$\\eta_{i,l} $である$\\hat{\\eta}_{i,l}$を考えます} \\\\\n\\hat{\\eta}_{i,l} &=  \\frac{\\hat{w}_{l}\\phi\\left(x_{i}; \\hat{\\mu}_{l}, \\hat{\\sigma}_{l}\\right)}{\\sum_{k'=1}^{m} \\hat{w}_{k'}\\phi\\left(x_{i}; \\hat{\\mu}_{k'}, \\hat{\\sigma}_{k'}\\right)} \\\\\n&  \\text{そして$a_{i,l} = \\hat{\\eta}_{i,l}$とすると} \\\\\nb'\\left(\\hat{\\vec{\\theta}}; \\bf{A}\\right)　&=  \\sum_{i=1}^{n} \\sum_{l}^{m}  \\hat{\\eta}_{i,l} \\log\\frac{\\hat{w_{l}}\\phi\\left(x_{i}; \\hat{\\mu_{l}}, \\hat{\\sigma_{l}}\\right)}{\\hat{\\eta}_{i,l}} \\\\\n&= \\sum_{i=1}^{n} \\sum_{l}^{m}  \\hat{\\eta}_{i,l} \\log \\sum_{l'=1}^{m} \\hat{w}_{l'}\\phi\\left(x_{i}; \\hat{\\mu}_{l'}, \\hat{\\sigma}_{l'}\\right) \\\\\n&=  \\left(\\sum_{l}^{m}  \\hat{\\eta}_{i,l}\\right)\\sum_{i=1}^{n} \\log \\sum_{l'=1}^{m} \\hat{w}_{l'}\\phi\\left(x_{i}; \\hat{\\mu}_{l'}, \\hat{\\sigma}_{l'}\\right) \\\\\n&=  \\sum_{i=1}^{n} \\log \\sum_{l'=1}^{m} \\hat{w}_{l'}\\phi\\left(x_{i}; \\hat{\\mu}_{l'}, \\hat{\\sigma}_{l'}\\right) \\\\\n&= \\log L\\left(\\vec{\\theta}\\right)\n\\end{aligned}\n\\]\n従って，\\(\\hat{\\bf{A}} = \\left\\{\\hat{\\eta}_{i,l}\\right\\}\\)とすると，\n\\[\n\\begin{aligned}\nb\\left(\\vec{\\theta}\\right) &= b'\\left(\\vec{\\theta}; \\hat{\\bf{A}}\\right)\\\\\n&= \\sum_{i=1}^{n} \\sum_{l}^{m}  \\hat{\\eta}_{i,l} \\log\\frac{w_{l}\\phi\\left(x_{i}; \\mu_{l}, \\sigma_{l}\\right)}{\\hat{\\eta}_{i,l}} \\\\\n\\end{aligned}\n\\]\n以上の様に，下界\\(b\\left(\\vec{\\theta}\\right)\\)を求めることは，現在の推定値\\(\\hat{\\vec{\\theta}}\\)を用いて\\(\\hat{\\eta}_{i,l}\\)を求めることで実現します．\n\n\nMステップ\nMステップでは，\\(b\\left(\\vec{\\theta}\\right)\\)が最大となる\\(\\hat{\\theta}'\\)を求めます．\\(\\hat{\\theta}'\\)は\\(b\\left(\\vec{\\theta}\\right)\\)の各パラメータに対する導関数が\\(0\\)となる\\(\\theta\\)を採用します．まずは， \\(\\gamma_{l}\\)についてです\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\gamma_{l}} b\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\gamma_{l}} \\sum_{i=1}^{n} \\sum_{k}^{m}  \\hat{\\eta}_{i,k} \\log\\frac{w_{k}\\phi\\left(x_{i}; \\mu_{k}, {\\sigma_{k}}\\right)}{\\hat{\\eta}_{i,k}} \\\\\n&=  \\sum_{i=1}^{n} \\sum_{k}^{m} \\hat{\\eta}_{i,k} \\frac{\\hat{\\eta}_{i,k}}{w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)} \\frac{\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)}{\\gamma_{l}} \\frac{\\partial w_{k}}{\\partial \\gamma_{l}} \\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m} \\frac{\\hat{\\eta}_{i,k}}{w_{k}} w_{k}\\left(\\delta_{k,l} - w_{l}\\right) \\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m} \\hat{\\eta}_{i,k}\\delta_{k,l} - w_{l}\\hat{\\eta}_{i,k} \\\\\n&= \\sum_{i=1}^{n} \\hat{\\eta}_{i,l} - w_{l}\\left(\\sum_{k}^{m} \\hat{\\eta}_{i,k}\\right) \\\\\n&= \\sum_{i=1}^{n} \\hat{\\eta}_{i,l} - w_{l} \\\\\n& \\text{$\\frac{\\partial}{\\partial \\gamma_{l}} b\\left(\\hat{\\vec{\\theta}}\\right) = 0$より}\\\\\n\\sum_{i=1}^{n} \\hat{w}_{l} &= \\sum_{i=1}^{n} \\hat{\\eta}_{i,l} \\\\\nn\\hat{w}_{l} &= \\sum_{i=1}^{n} \\hat{\\eta}_{i,l} \\\\\n\\hat{w}_{l} &= \\frac{1}{n} \\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\n\\end{aligned}\n\\]\n次に，\\(\\mu_{l}\\)についてです．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\mu_{l}} b\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\mu_{l}} \\sum_{i=1}^{n} \\sum_{k}^{m}  \\hat{\\eta}_{i,k} \\log\\frac{w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)}{\\hat{\\eta}_{i,k}} \\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m} \\hat{\\eta}_{i,k} \\frac{\\hat{\\eta}_{i,k}}{w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)} \\frac{ w_{k}}{\\hat{\\eta}_{i,k} } \\frac{\\partial }{\\partial \\mu_{l}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m}  \\frac{\\hat{\\eta}_{i,k}}{\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)} \\frac{x_{i} - \\mu_{k}}{\\sigma_{k}^{2}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right) \\delta_{k,l}\\\\\n&= \\frac{1}{\\sigma_{l}^{2}} \\sum_{i=1}^{n}  \\hat{\\eta}_{i,l}x_{i} - \\hat{\\eta}_{i,l}\\mu_{l}\\\\\n& \\text{$\\frac{\\partial}{\\partial \\mu_{l}} b\\left(\\hat{\\vec{\\theta}}\\right) = 0$より}\\\\\n\\hat{\\mu}_{l} \\sum_{i=1}^{n}\\hat{\\eta}_{i,l}&=  \\sum_{i=1}^{n}\\hat{\\eta}_{i,l}x_{i}  \\\\\n\\hat{\\mu}_{l} &=  \\frac{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}x_{i}  }{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}\\\\\n\\end{aligned}\n\\]\n最後に，\\(\\sigma_{l}\\)についてです．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\sigma_{l}} b\\left(\\vec{\\theta}\\right) &= \\frac{\\partial}{\\partial \\sigma_{l}} \\sum_{i=1}^{n} \\sum_{k}^{m}  \\hat{\\eta}_{i,k} \\log\\frac{w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)}{\\hat{\\eta}_{i,k}} \\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m} \\hat{\\eta}_{i,k} \\frac{\\hat{\\eta}_{i,k}}{w_{k}\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)} \\frac{ w_{k}}{\\hat{\\eta}_{i,k} } \\frac{\\partial }{\\partial \\sigma_{l}}  \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\\\\n&= \\sum_{i=1}^{n} \\sum_{k}^{m}  \\frac{\\hat{\\eta}_{i,k}}{\\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)}\\frac{\\left(x_{i} - \\mu_{k}\\right)^{2} - \\sigma_{k}^{2}}{\\sigma_{k}^{3}} \\phi\\left(x_{i}; \\mu_{k}, \\sigma_{k}\\right)\\delta_{k,l}\\\\\n&= \\frac{1}{\\sigma_{l}^{3}} \\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\left(x_{i} - \\mu_{l}\\right)^{2} - \\hat{\\eta}_{i,l}\\sigma_{l}^{2} \\\\\n& \\text{$\\frac{\\partial}{\\partial \\mu_{l}} b\\left(\\hat{\\vec{\\theta}}\\right) = 0$より}\\\\\n\\hat{\\sigma}_{l}^{2} \\sum_{i=1}^{n}\\hat{\\eta}_{i,l}&=  \\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\left(x_{i} - \\mu_{l}\\right)^{2} \\\\\n\\hat{\\sigma}_{l}  &= \\sqrt{\\frac{\\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\left(x_{i} - \\mu_{l}\\right)^{2}}{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}}\\\\\n\\end{aligned}\n\\]\nまとめると，Mステップでは以下の様にパラメータを更新します．\n\\[\n\\begin{aligned}\n\\hat{w}_{l} &= \\frac{1}{n} \\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\\\\n\\hat{\\mu}_{l} &=  \\frac{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}x_{i}  }{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}\\\\\n\\hat{\\sigma}_{l}  &= \\sqrt{\\frac{\\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\left(x_{i} - \\mu_{l}\\right)^{2}}{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}}\\\\\n\\end{aligned}\n\\]\n次にEMアルゴリズムを用いてパラメータの推定を行っていきます．具体的な手順は以下の通りです．\n\n\\(\\hat{\\gamma_{l}}\\), \\(\\hat{\\mu_{l}}\\), \\(\\hat{\\sigma_{l}}\\)をランダムな値で初期化\n\\(\\hat{\\eta_{i,l}}\\)を更新し，下界\\(b\\left(\\vec{\\theta}\\right)\\)を求める（Eステップ） \\[\n\\begin{aligned}\n\\hat{\\eta_{i,l}} &= \\frac{\\hat{w}_{l}\\phi\\left(x_{i}; \\hat{\\mu}_{l}, \\hat{\\sigma}_{l}\\right)}{\\sum_{k'=1}^{m} \\hat{w}_{k'}\\phi\\left(x_{i}; \\hat{\\mu}_{k'}, \\hat{\\sigma}_{k'}\\right)}\n\\end{aligned}\n\\]\n下界\\(b\\left(\\vec{\\theta}\\right)\\)を最大化する\\(\\hat{\\vec{\\theta}}'\\)を求める（Mステップ） \\[\n\\begin{aligned}\n\\hat{w}_{l} &= \\frac{1}{n} \\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\\\\n\\hat{\\mu}_{l} &=  \\frac{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}x_{i}  }{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}\\\\\n\\hat{\\sigma}_{l}  &= \\sqrt{\\frac{\\sum_{i=1}^{n} \\hat{\\eta}_{i,l}\\left(x_{i} - \\mu_{l}\\right)^{2}}{\\sum_{i=1}^{n}\\hat{\\eta}_{i,l}}}\\\\\n\\end{aligned}\n\\]\n一定回数または収束するまで2〜3を繰り返す\n\nEMアルゴリズムによるパラメータ推定を行うコードは以下の通りです．勾配法の時と同様にtrain_em が上述したパラメータ推定の根幹になります． そして，全パラメータの変化量の絶対値和が一定値以下となる場合を収束と判定しています．また，入力については勾配法で用いたものを再度使用します．\n\ndef opt_w(etas):\n    return np.average(etas, axis=1)\n\ndef opt_mu(xs, etas):\n    num = np.sum(etas * xs, axis=1)\n    den = np.sum(etas, axis=1)\n    return num / den\n\ndef opt_sigma(xs, etas, mus):\n    num = np.sum((xs - mus[:, np.newaxis]) ** 2 * etas, axis=1)\n    den = np.sum(etas, axis=1)\n    return np.sqrt(num / den)\n\ndef train_em(xs):\n    mus_hat = 2 * np.max(np.abs(xs)) * (np.random.rand(3) - 0.5)\n    sigmas_hat = np.random.rand(3)\n    ws_hat = np.random.rand(3)\n\n    loss = float('inf')\n    criteria = 1e-10\n    iter = 0;\n    while iter < 10000:\n        # E step\n        etas_hat = eta(xs, ws_hat, mus_hat, sigmas_hat)\n\n        # M Step\n        delta_ws = ws_hat\n        delta_mus = mus_hat\n        delta_sigmas = sigmas_hat\n        ws_hat = opt_w(etas_hat)\n        mus_hat = opt_mu(xs, etas_hat)\n        sigmas_hat = opt_sigma(xs, etas_hat, mus_hat)\n        delta_ws -= ws_hat\n        delta_mus -= mus_hat\n        delta_sigmas -= sigmas_hat\n\n        loss = np.sum(np.abs(np.hstack([delta_ws, delta_mus, delta_sigmas])))\n        if loss < criteria:\n            break\n        iter += 1\n\n    return loss, iter, (ws_hat, mus_hat, sigmas_hat)\n\nloss, iter, (ws_hat_em, mus_hat_em, sigmas_hat_em) = train_em(all_data)\nprint(f\"loss: {loss}, iterations: {iter}\")\nprint(ws_hat_em, mus_hat_em, sigmas_hat_em)\n\nloss: 9.965148151103165e-11, iterations: 1254\n[0.47878854 0.27353509 0.24767637] [ 0.51716133 -1.10900049  3.16175044] [0.51084106 1.06776561 0.76372732]\n\n\n勾配法と比較して，イテレーション回数が10分の1程度であることが確認できます． 勾配法の時と同様に訓練データと推定したパラメータによる分布とをプロットして確認します．\n\nws_hat_em, mus_hat_em, sigmas_hat_em = permute(ws, mus, sigmas, ws_hat_em, mus_hat_em, sigmas_hat_em)\nplot(data, ws_hat_em, mus_hat_em, sigmas_hat_em)\n\n\n\n\n\n\n以上の結果より，適切に推定できていることが確認できました．EMアルゴリズムの勾配法に対する利点としては，\n\n\\(\\epsilon\\)を設定する必要がない\n勾配法よりも高速に収束する\n\nという点があげられます．しかしながら，\n\n初期値によっては推定に失敗する場合がある\n\nという問題は継続して存在します．したがって，実用を考えると複数の初期値でパラメータを推定するなどの工夫が必要になるかもしれません．"
  },
  {
    "objectID": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#参考文献",
    "href": "posts/2021-05-30-gaussian-mixture-model-with-softmax.html#参考文献",
    "title": "ソフトマックス関数を用いた混合ガウスモデルの計算",
    "section": "参考文献",
    "text": "参考文献\n\n\n[1] 杉山将. 2009. 統計的機械学習 : 生成モデルに基づくパターン認識. オーム社."
  },
  {
    "objectID": "posts/2022-01-30-cargo-edit-workaround.html",
    "href": "posts/2022-01-30-cargo-edit-workaround.html",
    "title": "cargo-editが上手く動かない時の回避策",
    "section": "",
    "text": "cargo-edit v0.8.0が上手く動かなかったので，その対処法についてのメモです．"
  },
  {
    "objectID": "posts/2022-01-30-cargo-edit-workaround.html#やったこと",
    "href": "posts/2022-01-30-cargo-edit-workaround.html#やったこと",
    "title": "cargo-editが上手く動かない時の回避策",
    "section": "やったこと",
    "text": "やったこと\n\nssh-agentに秘密鍵を登録\nv0.7.0にダウングレード"
  },
  {
    "objectID": "posts/2022-01-30-cargo-edit-workaround.html#error-authenticating-no-auth-sock-variable-classssh-23-でcargo-editをインストールすることができない",
    "href": "posts/2022-01-30-cargo-edit-workaround.html#error-authenticating-no-auth-sock-variable-classssh-23-でcargo-editをインストールすることができない",
    "title": "cargo-editが上手く動かない時の回避策",
    "section": "error authenticating: no auth sock variable; class=Ssh (23) でcargo-editをインストールすることができない",
    "text": "error authenticating: no auth sock variable; class=Ssh (23) でcargo-editをインストールすることができない\n単純に cargo install cargo-edit をすると，以下の様にssh-agentとの連携に失敗してエラーとなりました．\n$ cargo install cargo-edit\n    Updating crates.io index\nerror: failed to fetch `https://github.com/rust-lang/crates.io-index`\n\nCaused by:\n  failed to authenticate when downloading repository: ssh://git@github.com/rust-lang/crates.io-index\n\n  * attempted ssh-agent authentication, but no usernames succeeded: `git`\n\n  if the git CLI succeeds then `net.git-fetch-with-cli` may help here\n  https://doc.rust-lang.org/cargo/reference/config.html#netgit-fetch-with-cli\n\nCaused by:\n  error authenticating: no auth sock variable; class=Ssh (23)\n対処法はエラーメッセージの中に書いてあるので，以下の様にssh-agentの起動と秘密鍵の登録を行います．\n$ eval `ssh-agent -s`\nAgent pid 1756\n$ ssh-add\nIdentity added: <path to home>/.ssh/id_rsa (<mail address>)\n再度，cargo install cargo-edit を実行すると無事にインストールできました．\n$ cargo install cargo-edit\n    Updating crates.io index\n  Downloaded cargo-edit v0.8.0\n  Downloaded 1 crate (61.1 KB) in 0.40s\n  Installing cargo-edit v0.8.0\n\n...\n\n   Compiling crates-index v0.17.0\n   Compiling cargo-edit v0.8.0\n    Finished release [optimized] target(s) in 1m 05s\n  Installing /usr/local/cargo/bin/cargo-add\n  Installing /usr/local/cargo/bin/cargo-rm\n  Installing /usr/local/cargo/bin/cargo-set-version\n  Installing /usr/local/cargo/bin/cargo-upgrade\n   Installed package `cargo-edit v0.8.0` (executables `cargo-add`, `cargo-rm`, `cargo-set-version`, `cargo-upgrade`)"
  },
  {
    "objectID": "posts/2022-01-30-cargo-edit-workaround.html#command-failed-due-to-unhandled-error-authentication-required-but-no-callback-set-classssh-23-codeauth--16-で-cargo-add-できない",
    "href": "posts/2022-01-30-cargo-edit-workaround.html#command-failed-due-to-unhandled-error-authentication-required-but-no-callback-set-classssh-23-codeauth--16-で-cargo-add-できない",
    "title": "cargo-editが上手く動かない時の回避策",
    "section": "Command failed due to unhandled error: authentication required but no callback set; class=Ssh (23); code=Auth (-16) で cargo add できない",
    "text": "Command failed due to unhandled error: authentication required but no callback set; class=Ssh (23); code=Auth (-16) で cargo add できない\ncargo add でクレートを追加しようとすると，以下の様にエラーが発生します．\n$ cargo add anyhow\n    Updating 'https://github.com/rust-lang/crates.io-index' index\nCommand failed due to unhandled error: authentication required but no callback set; class=Ssh (23); code=Auth (-16)\nこちらやこちらなど，同様のエラーに関する報告はちらほら上がっているようです．しかしながら，それらの回避策は私の環境では有効性を発揮しませんでした． 従って，cargo-edit のバージョンを v0.7.0 にダウンロードすることとしました．\n$  cargo install --version 0.7.0 cargo-edit\n  Downloaded cargo-edit v0.7.0\n  Downloaded 1 crate (57.6 KB) in 0.69s\n    Updating crates.io index\n  Installing cargo-edit v0.7.0\n\n...\n\n Replacing /usr/local/cargo/bin/cargo-upgrade\n    Removing executable `/usr/local/cargo/bin/cargo-set-version` from previous version cargo-edit v0.8.0\n    Replaced package `cargo-edit v0.8.0` with `cargo-edit v0.7.0` (executables `cargo-add`, `cargo-rm`, `cargo-upgrade`)\nこの結果，以下の様に cargo add が動作する様になりました．\n$ cargo add anyhow\n    Updating 'https://github.com/rust-lng/crates.io-index' index\n      Adding anyhow v1.0.53 to dependenciesa"
  },
  {
    "objectID": "posts/2022-01-30-cargo-edit-workaround.html#参考",
    "href": "posts/2022-01-30-cargo-edit-workaround.html#参考",
    "title": "cargo-editが上手く動かない時の回避策",
    "section": "参考",
    "text": "参考\n\ncargo add no longer works with Git using SSH in 0.8.0 #515\nSSH support #333"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "",
    "text": "DICOMを取り扱うライブラリの多くは海外製であるため，日本語の取り扱いが得意で無いことが多いです. そこで，DICOMにおいて日本語を正しく扱うために色々と調べたのでまとめます．"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#やったこと",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#やったこと",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "やったこと",
    "text": "やったこと\n\nDICOMで日本語を表現する方法を調査"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#文字コードについて復習",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#文字コードについて復習",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "文字コードについて復習",
    "text": "文字コードについて復習\nDICOMにおける文字コードの取り扱いについて述べる前に，いわゆる”文字コード”と呼ばれているものは何であるかを簡単に復習します．より正しく”文字コード”について理解するためには，（符号化）文字集合と（文字）符号化方式を区別することが重要です．文字集合とは表現する文字の集合（アルファベット全てやひらがな全てなど）です．符号化方式とは文字集合の要素をコンピュータ上で取り扱うことが可能な形式に変換する方法です．従って，同一の文字集合に対して複数の符号化方式が存在します．"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#isoiec-2022-とはなんだろう",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#isoiec-2022-とはなんだろう",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "ISO/IEC 2022 とはなんだろう",
    "text": "ISO/IEC 2022 とはなんだろう\nISO/IEC 2022とは文字集合を７ビット文字または８ビット文字にて表現する符号化方式です．特徴としてはエスケープシーケンスを利用することで，複数の文字集合を同時に取り扱うことが可能である点が挙げられます．日本語においては，このISO/IEC 2022の機構を利用したISO-2022-JPが広く利用されています．ISO-2022-JPは一般的にJISコードと呼ばれます．これには漢字，ひらがな，カタカナ，ラテン文字，ギリシア文字，キリル文字など多くの文字集合が含まれます．（半角カタカナは含まれません）\n上述した通り，ISO/IEC 2022には7ビット文字を利用したものと8ビット文字を利用したものとが存在します．ここでは８ビット文字を利用した場合のみを考慮します．ISO/IEC 2022の符号表は図形文字の領域（GL，GR）と制御文字の領域（CL，CR)からなります．また，４つの仮想的なバッファ(G0, G1, G2,G3)が存在します．ISO/IEC 2022を利用するには，エスケープシーケンスを用いて任意のバッファへ文字集合をロードし，それを図形文字の領域（GL，GR)に呼び出します．呼び出しには永続的に呼び出すロッキングシフトと１文字のみのシングルシフトが存在します．"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#dicomにおけるisoiec-2022",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#dicomにおけるisoiec-2022",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "DICOMにおけるISO/IEC 2022",
    "text": "DICOMにおけるISO/IEC 2022\nDICOMでは符号方式としてISO/IEC 2022のサブセットを用いています．具体的には\n\n8ビット文字をサポート\nデフォルトの文字集合としてISO646を使用\nISO646は必ずGL空間に呼び出される\nISO646以外の文字集合を用いる場合はSpecific Character Set(0008,0005)に指定する\nエスケープを利用した符号拡張を使う(ISO/IEC 2022)場合はSpecific Character Setに二つ以上の文字集合を指定する\nバッファG0はGLに，バッファG1はGRにロードされる\nG2，G3は利用不可\nG0，G1は常に呼び出し状態にあるのでロッキングシフトは不要\n\nという制約があります．"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#実際にdicomで日本語を扱ってみる",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#実際にdicomで日本語を扱ってみる",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "実際にDICOMで日本語を扱ってみる",
    "text": "実際にDICOMで日本語を扱ってみる\nDICOMで日本語を扱うためには，Specific Character Set(0008,0005)に使用する符号方式を設定する必要があります．ここでは，以下の患者名を符号化することを考えます．\nﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう\nこの患者名には，半角かな，漢字，全角ひらがなが含まれています．英数字と半角かなはISO 2022 IR 13で，漢字と全角ひらがなはISO 2022 IR 87で表現が可能です． 従って，Specific Character Set(0008,0005)には以下の値を設定します．\nISO 2022 IR 13\\ISO 2022 IR 87\n前述の通り，ISO/IEC 2022ではエスケープシーケンスを用いて複数の符号方式を切り替えます． 従って，上述の患者名においても適切なタイミングでエスケープする必要があります． エスケープシーケンスを追加した例を以下にしまします．\nﾔﾏﾀﾞ^ﾀﾛｳ= ESC 02/04 04/02 山田 ESC 02/08 04/10 ^ ESC 02/04 04/02 太郎 ESC 02/08 04/10 = ESC 02/04 04/02 やまだ ESC 02/08 04/10 ^ ESC 02/04 04/02 たろう ESC 02/08 04/10\nまた，各エスケープシーケンスの詳細を以下に示します．\n\n\n\nエスケープシーケンス\n処理\n\n\n\n\nESC 02/08 04/10\n英数字(ISO-IR 14)をGLにロード\n\n\nESC 02/04 04/02\n漢字とひらがな(ISO-IR 87)をGLにロード\n\n\n\nこれらを踏まえて，実際にエンコーディングすると以下の値が得られます．\n13/04 12/15 12/00 13/14 05/14 12/00 13/11 11/03 03/13 01/11 02/04 04/02 03/11 03/03 04/05 04/04 01/11 02/08 04/10 05/14 01/11 02/04 04/02 04/02 04/00 04/15 03/10 01/11 02/08 04/10 03/13 01/11 02/04 04/02 02/04 06/04 02/04 05/14 02/04 04/00 01/11 02/08 04/10 05/14 01/11 02/04 04/02 02/04 03/15 02/04 06/13 02/04 02/06 01/11 02/08 04/10"
  },
  {
    "objectID": "posts/2020-10-12-character-encodings-in-dicom.html#参考",
    "href": "posts/2020-10-12-character-encodings-in-dicom.html#参考",
    "title": "DICOMにおける文字コードの取り扱い",
    "section": "参考",
    "text": "参考\n\nJIS漢字コード\nISO/IEC 2022\nJIS X 0201\n２０１１ ST講座 入門講座 DICOM規格 初級 –DICOMをうまく使いこなす–\nDICOMの日本語エンコーディング処理実装\nDICOM に慣れる － 現場で DICOM 接続に慌てないための知識 （２） 文字系の通信 －\nH.3 Example of Person Name Value Representation in the Japanese Language"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html",
    "title": "lab_note",
    "section": "",
    "text": "---\naliases:\n- /ImageProcessing/Rust/2021/09/30/simple-guided-filter-rs\ncategories:\n- Rust\n- 画像処理\ndate: '2021-09-30'\noutput-file: 2021-09-30-simple-guided-filter-rs.html\ntitle: \"Rust\\u306B\\u3088\\u308B\\u30B7\\u30F3\\u30D7\\u30EB\\u306AGuidedFilter\\u306E\\u5B9F\\\n  \\u88C5\"\ntoc: true\nimage: /assets/img/2021-09-30-simple-guided-filter-rs/media/output.jpg\n---"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#はじめに",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#はじめに",
    "title": "lab_note",
    "section": "はじめに",
    "text": "はじめに\n高速なエッジ保持平滑化フィルタとしてGuidedFilter[1]が広く知られています．この記事では輝度信号に限定したシンプルな実装を紹介します．なお，実装にはRustとimageクレートを用いました．"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#やったこと",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#やったこと",
    "title": "lab_note",
    "section": "やったこと",
    "text": "やったこと\n\nGuidedFilterを用いたエッジ保持平滑化フィルタを実装"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#guidedfilterについて",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#guidedfilterについて",
    "title": "lab_note",
    "section": "GuidedFilterについて",
    "text": "GuidedFilterについて\nGuidedFilterはガイド信号\\(\\bf{I}\\)の１次式で入力信号\\(\\bf{p}\\)を近似することで出力信号\\(\\bf{q}\\)を得ます．また，このガイド信号の選択により様々な応用が考案されています．今回紹介するエッジ保持平滑化フィルタはその中の一つです．\nそれでは，実際に出力信号を得るための方法について述べていきます．まず，\\(\\bf{q}\\)と\\(\\bf{I}\\)との関係を以下のように定義します．\n\\[\n\\begin{aligned}\nq_{i} & = a_{k} I_{i} + b_{k} \\ ,\\forall i \\in \\omega_{k} \\\\\n\\end{aligned}\n\\]\nここで，\\(i\\)は画素のインデックスを，\\(k\\)はウィンドウ中心画素のインデックスを，\\(\\omega_{k}\\)はウィンドウをそれぞれ表します．\n次に，\\(p\\)と\\(q\\)との関係について考えます．ここでノイズ\\(n\\)を用いると以下のように表現することができます．\n\\[\n\\begin{aligned}\nq_{i} & = p_{i} - n_{i} \\\\\n   & = a_{k} I_{i} + b_{k}\n\\end{aligned}\n\\]\nそして，\\(q\\)で\\(p\\)をより良く近似するため，以下の評価関数の最小化を考えます．\n\\[\n\\begin{aligned}\nE\\left(a_{k}, b_{k}\\right) & = \\sum_{i \\in \\omega_{k}} \\left(\\left(a_{k}I_{i} + b_{k} - p_{i}\\right)^{2} + \\epsilon a_{k}^{2}\\right) \\\\\n\\end{aligned}\n\\]\nこの式において，\\(\\epsilon a_{k}^{2}\\)で表される項は，\\(a_{k}\\)の正則化を目的としたものです．この項はリッジ回帰に用いられる正則化項と同様のモチベーションで導入されています．\nそれでは，\\(E\\left(a_{k}, b_{k}\\right)\\)を\\(a_{k}\\)および\\(b_{k}\\)で偏微分して最適な\\(a_{k}\\)と\\(b_{k}\\)を求めていきます．最初に\\(b_{k}\\)について考えます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial b_{k}} E\\left(a_{k}, b_{k}\\right) & = 2\\sum_{i \\in \\omega_{k}} \\left(a_{k}I_{i} + b_{k} - p_{i}\\right) \\\\\n&= 0 \\\\\nb_{k} &= \\frac{1}{\\left| \\omega_{k} \\right|} \\sum_{i \\in \\omega_{k}} p_{i} - \\frac{a_{k}}{\\left| \\omega_{k} \\right|}\\sum_{i \\in \\omega_{k}} I_{i}\\\\\n\\end{aligned}\n\\]\nここで，\\(\\bar{p_{k}} = \\frac{1}{\\left| \\omega_{k} \\right|} \\sum_{i \\in \\omega_{k}} p_{i}\\), \\(\\mu_{k} = \\frac{1}{\\left| \\omega_{k} \\right|}\\sum_{i \\in \\omega_{k}} I_{i}\\) とすると，\n\\[\n\\begin{aligned}\nb_{k} &= \\bar{p_{k}} - a_{k} \\mu_{k}\n\\end{aligned}\n\\]\n次に\\(a_{k}\\)について考えます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial a_{k}} E\\left(a_{k}, b_{k}\\right) & = \\frac{\\partial}{\\partial a_{k}} \\sum_{i \\in \\omega_{k}} \\left(\\left(a_{k}I_{i} + b_{k} - p_{i}\\right)^{2} + \\epsilon a_{k}^{2}\\right)\\\\\n&=   \\frac{\\partial}{\\partial a_{k}} \\sum_{i \\in \\omega_{k}} \\left(\\left(a_{k}I_{i} + \\bar{p_{k}} - a_{k} \\mu_{k}  - p_{i}\\right)^{2} + \\epsilon a_{k}^{2}\\right)\\\\\n&=   \\frac{\\partial}{\\partial a_{k}} \\sum_{i \\in \\omega_{k}} \\left(\\left(a_{k} \\left( I_{i}  -\\mu_{k}\\right) + \\bar{p_{k}} - p_{i}\\right)^{2} + \\epsilon a_{k}^{2}\\right)\\\\\n&= 2\\sum_{i \\in \\omega_{k}} \\left(\\left(a_{k} \\left( I_{i}  -\\mu_{k}\\right) + \\bar{p_{k}} - p_{i}\\right)\\left( I_{i}  -\\mu_{k}\\right) + \\epsilon a_{k}\\right)\\\\\n&= 2a_{k} \\sum_{i \\in \\omega_{k}} \\left( I_{i}  -\\mu_{k}\\right)^{2}   - 2 \\sum_{i \\in \\omega_{k}} p_{i}I_{i} + 2 \\mu_{k} \\sum_{i \\in \\omega_{k}} p_{i} + 2 \\bar{p_{k}} \\sum_{i \\in \\omega_{k}} I_{i} -2 \\bar{p_{k}} \\mu_{k} \\left|\\omega_{k}\\right| + 2 \\epsilon a_{k} \\left| \\omega_{k} \\right| \\\\\n&= 2a_{k} \\sigma_{k}^{2} \\left|\\omega_{k}\\right|  - 2 \\sum_{i \\in \\omega_{k}} p_{i}I_{i} + 2 \\mu_{k}\\bar{p_{k}}\\left|\\omega_{k}\\right|   + 2 \\bar{p_{k}} \\mu_{k}\\left|\\omega_{k}\\right| -2 \\bar{p_{k}} \\mu_{k} \\left|\\omega_{k}\\right| + 2 \\epsilon a_{k} \\left| \\omega_{k} \\right| \\\\\n&= 0 \\\\\na_{k} &= \\frac{ \\frac{1}{\\left|\\omega_{k}\\right|} \\sum_{i \\in \\omega_{k}} p_{i}I_{i} - \\bar{p_{k}} \\mu_{k} }{\\sigma_{k}^{2} + \\epsilon }\n\\end{aligned}\n\\]\nここで，再度\\(q_{i}\\)について考えます．\\(q_{i}\\)は\\(a_{k}\\)及び\\(b_{k}\\)に依存していますが，これらの値はウィンドウ\\(\\omega_{k}\\)の中心座標\\(k\\)に対して変化します．従って，\\(q_{i}\\)を一意に定めることはできません．そこで，\\(q_{i}\\)に影響を及ぼす\\(\\omega_{k}\\)対して平均値を計算します．\n\\[\n\\begin{aligned}\nq_{i} & = \\frac{1}{\\left|\\omega_{i}\\right|} \\sum_{k \\in \\omega_{i}} \\left(a_{k} I_{i} + b_{k}\\right) \\\\\n&= \\left(\\frac{1}{\\left| \\omega_{i} \\right|} \\sum_{k \\in \\omega_{i}}a_{k} \\right)I_{i} + \\frac{1}{\\left| \\omega_{i} \\right|} \\sum_{k \\in \\omega_{i}}b_{k} \\\\\n&= \\bar{a_{i}} I_{I} + \\bar{b_{i}}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#rustによる実装",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#rustによる実装",
    "title": "lab_note",
    "section": "Rustによる実装",
    "text": "Rustによる実装\nそれでは，実際にRustでGuidedFilterを実装していきます．今回，以下のクレートを使用します．\n\nimage\nnum-traits\nbase64\n\nimage は画像の読み書き及びデータ表現に，num-traits は画像データ型から計算用のデータ型への変換に，base64はNotebook上への画像出力にそれぞれ用いました．\nまず初めに必要なクレートを導入します．\n\n:dep image \n:dep num-traits\n:dep base64\n//above line is magic for adding crate\n\nuse image::{GenericImageView, ImageBuffer, Luma, Pixel, Primitive};\nuse num_traits::NumCast;\n\n次にNotebook上への画像出力機能を実装します．詳細は以前の記事を参考にしてください．\n\nextern crate image;\nextern crate base64;\npub trait EvcxrResult {fn evcxr_display(&self);}\nimpl EvcxrResult for ImageBuffer<Luma<u8>, Vec<u8>> {\n    fn evcxr_display(&self) {\n        let mut buffer = Vec::new();\n        image::codecs::jpeg::JpegEncoder::new(&mut buffer).encode(&**self, self.width(), self.height(),\n            image::ColorType::L8).unwrap();\n        let img = base64::encode(&buffer);\n        println!(\"EVCXR_BEGIN_CONTENT image/png\\n{}\\nEVCXR_END_CONTENT\", img);        \n    }\n}\n\n次にあると便利な雑多な関数を実装します．ここでは，所望のデータ型をSubpixelとしたPixel型を取得するcast_subpixel と スケールを調整した\\(\\epsilon\\) を計算するcalc_eps を実装します．論文中では画像データを\\(0 \\sim 1\\)に正規化した状態で取り扱っています．今回の実装では，画像データを\\(0 \\sim 255\\) の範囲で取り扱うため，calc_eps で\\(\\epsilon\\)の値を適切にスケーリングします．\n\nfn cast_subpixel<S, T>(pixel: &Luma<S>) -> Luma<T>\nwhere\n    S: Primitive,\n    T: Primitive,\n{\n    let Luma([data]) = *pixel;\n    Luma([NumCast::from(data).unwrap(); 1])\n}\n\n\nfn cals_eps(eps: f64) -> f64 {\n    let eps = 255.0 * eps;\n    eps * eps\n}\n\n次に２次元平滑化処理を行うmean2d を実装します．2次元平滑化処理は\n\nx方向移動平均フィルタ\n転置\nx方向移動平均フィルタ\n転置\n\nという処理で実現しています．\n\nfn mean2d<I, S>(image: &I, r: u32) -> ImageBuffer<Luma<f64>, Vec<f64>>\nwhere\n    I: GenericImageView<Pixel = Luma<S>>,\n    S: Primitive + 'static,\n{\n    fn get_luma_as_f64<I, S>(image: &I, x: u32, y: u32) -> f64\n    where\n        I: GenericImageView<Pixel = Luma<S>>,\n        S: Primitive + 'static,\n    {\n        let Luma(data) = image.get_pixel(x, y);\n        NumCast::from(data[0]).unwrap()\n    }\n\n    fn calc_mean(head_value: f64, tail_value: f64, r: u32) -> f64 {\n        let den = 2.0 * r as f64 + 1.0;\n        let num = head_value - tail_value;\n        num / den\n    }\n\n    fn meand2d_tr<I, S>(image: &I, r: u32) -> ImageBuffer<Luma<f64>, Vec<f64>>\n    where\n        I: GenericImageView<Pixel = Luma<S>>,\n        S: Primitive + 'static,\n    {\n        let (width, height) = image.dimensions();\n        let mut result = ImageBuffer::new(height, width);\n\n        for y in 0..height {\n            let mut head_x: u32 = 0;\n            let mut mid_x: u32 = 0;\n            let mut tail_x: u32 = 0;\n            let mut acc_head_x: f64 = 0.0;\n            let mut acc_tail_x: f64 = 0.0;\n\n            while mid_x < width {\n                if head_x < width {\n                    acc_head_x += get_luma_as_f64(image, head_x, y);\n                    head_x += 1;\n                }\n                if r < mid_x {\n                    acc_tail_x += get_luma_as_f64(image, tail_x, y);\n                    tail_x += 1;\n                }\n                if r <= head_x {\n                    let pixel = Luma([calc_mean(acc_head_x, acc_tail_x, r); 1]);\n                    result.put_pixel(y, mid_x, pixel);\n                    mid_x += 1;\n                }\n            }\n        }\n\n        result\n    }\n\n    meand2d_tr(&meand2d_tr(image, r), r)\n}\n\n実際にGuidedFilterの処理を行う関数guided_filterです．今回はエッジ保持平滑化フィルタのみを対象としているため，\\(I = p\\)（ガイド信号は入力信号と等しい）としています．また，rはウィンドウ領域の半径を，epsは\\(\\epsilon\\)をそれぞれ表します．\n\nfn guided_filter<I, S>(image: &I, r: u32, eps: f64) -> ImageBuffer<Luma<u8>, Vec<u8>>\nwhere\n    I: GenericImageView<Pixel = Luma<S>>,\n    S: Primitive + 'static,\n{\n    let eps = cals_eps(eps);\n    let i = image;\n    let mean_i = mean2d(i, r);\n\n    let (w, h) = i.dimensions();\n    let ii = ImageBuffer::from_fn(w, h, |x, y| {\n        cast_subpixel(&i.get_pixel(x, y)).map(|v: f64| v * v)\n    });\n    let corr_i = mean2d(&ii, r);\n\n    let var_i = ImageBuffer::from_fn(w, h, |x, y| {\n        mean_i\n            .get_pixel(x, y)\n            .map2(corr_i.get_pixel(x, y), |m, c| c - m * m)\n    });\n\n    let a = ImageBuffer::from_fn(w, h, |x, y| {\n        var_i.get_pixel(x, y).map_without_alpha(|v| v / (v + eps))\n    });\n\n    let b = ImageBuffer::from_fn(w, h, |x, y| {\n        mean_i\n            .get_pixel(x, y)\n            .map2(a.get_pixel(x, y), |m, a| (1.0 - a) * m)\n    });\n\n    let mean_a = mean2d(&a, r);\n    let mean_b = mean2d(&b, r);\n\n    let q = ImageBuffer::from_fn(w, h, |x, y| {\n        let i_v: f64 = {\n            let Luma([data]) = i.get_pixel(x, y);\n            NumCast::from(data).unwrap()\n        };\n\n        mean_a\n            .get_pixel(x, y)\n            .map2(mean_b.get_pixel(x, y), |a, b| a * i_v + b)\n    });\n    \n    ImageBuffer::from_fn(w, h, |x, y| -> Luma<u8> {\n        cast_subpixel(q.get_pixel(x, y))\n    })\n}"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#実行結果",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#実行結果",
    "title": "lab_note",
    "section": "実行結果",
    "text": "実行結果\n入力信号は以下のとおりです．\n\nlet img = image::open(\"/assets/img/2021-09-30-simple-guided-filter-rs/media/input.jpg\").unwrap().to_luma8();\nimg\n\n\n\n\n\nr=18, eps=0.1^2\n\nguided_filter(&img, 18, 0.1)\n\n\n\n\n\n\nr=18, eps=0.4^2\n\nguided_filter(&img, 18, 0.4)\n\n\n\n\n\n\nr=18, eps=0.8^2\n\nguided_filter(&img, 18, 0.8)"
  },
  {
    "objectID": "posts/2021-09-30-simple-guided-filter-rs.html#参考",
    "href": "posts/2021-09-30-simple-guided-filter-rs.html#参考",
    "title": "lab_note",
    "section": "参考",
    "text": "参考\n\n\n[1] He, K. et al. 2012. Guided image filtering. IEEE transactions on pattern analysis and machine intelligence. 35, 6 (2012), 1397–1409."
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html",
    "title": "Goによるdot積のベンチマーク",
    "section": "",
    "text": "Goにて類似ベクトル検索を実装したところ、dot積の速度がパフォーマンスの律速となりました。 そこで、Goにてドット積のベンチマークを行い、各種実装方法の速度を比較してみました。"
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html#やったこと",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html#やったこと",
    "title": "Goによるdot積のベンチマーク",
    "section": "やったこと",
    "text": "やったこと\n\nGoでベクトルのdot積を計算する関数を実装\n各種実装方法のベンチマークを取得"
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html#対象コード",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html#対象コード",
    "title": "Goによるdot積のベンチマーク",
    "section": "対象コード",
    "text": "対象コード\n単純なループによる実装\n\nfunc CalcDot(a, b []float64, size int) float64 {\n    dot := 0.0\n    for i := 0; i < size; i++ {\n        dot += a[i] * b[i]\n    }\n    return dot\n}\n\nループアンロールによる実装（N=2）\n\nfunc CalcDotUnroll2(a, b []float64, size int) float64 {\n    const N = 2\n    dot := 0.0\n\n    i := 0\n    for ; i < size % N; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        dot += mul0 + mul1\n    }\n\n    return dot\n}\n\nループアンロールによる実装（N=4）\n\nfunc CalcDotUnroll4(a, b []float64, size int) float64 {\n    const N = 4\n    dot := 0.0\n\n    i := 0\n    for ; i < size % N; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        mul2 := a[i+2] * b[i+2]\n        mul3 := a[i+3] * b[i+3]\n        dot += mul0 + mul1 + mul2 + mul3\n    }\n\n    return dot\n}\n\nループアンロールによる実装（N=8）\n\nfunc CalcDotUnroll8(a, b []float64, size int) float64 {\n    const N = 8\n    dot := 0.0\n\n    i := 0\n    for ; i < size % N; i++ {\n        dot += a[i] * b[i]\n    }\n\n    for ; i < size; i += N {\n        mul0 := a[i+0] * b[i+0]\n        mul1 := a[i+1] * b[i+1]\n        mul2 := a[i+2] * b[i+2]\n        mul3 := a[i+3] * b[i+3]\n        mul4 := a[i+4] * b[i+4]\n        mul5 := a[i+5] * b[i+5]\n        mul6 := a[i+6] * b[i+6]\n        mul7 := a[i+7] * b[i+7]\n        dot += mul0 + mul1 + mul2 + mul3 + mul4 + mul5 + mul6 + mul7 \n    }\n\n    return dot\n}\n\nGonumによる実装\n\nimport (\n    \"gonum.org/v1/gonum/mat\"\n)\n\nfunc CalcDotByGonum(a, b []float64, size int) float64 {\n    av := mat.NewVecDense(size, a[:size])\n    bv := mat.NewVecDense(size, b[:size])\n    return mat.Dot(av, bv)\n}\n\nGonumによる実装（blas）\n\nimport (\n    \"gonum.org/v1/gonum/blas/blas64\"\n)\n\nfunc CalcDotByGonumBlas(a, b []float64, size int) float64 {\n    av := blas64.Vector{\n        N: size,\n        Inc:  1,\n        Data: a,\n    }\n    bv := blas64.Vector{\n        N: size,\n        Inc:  1,\n        Data: b,\n    }\n    return blas64.Dot(av, bv)\n}"
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html#ベンチマーク",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html#ベンチマーク",
    "title": "Goによるdot積のベンチマーク",
    "section": "ベンチマーク",
    "text": "ベンチマーク\n実行環境\n\n$lscpu\n\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nAddress sizes:                   43 bits physical, 48 bits virtual\nCPU(s):                          32\nOn-line CPU(s) list:             0-31\nThread(s) per core:              2\nCore(s) per socket:              16\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       AuthenticAMD\nCPU family:                      23\nModel:                           113\nModel name:                      AMD Ryzen 9 3950X 16-Core Processor\nStepping:                        0\nFrequency boost:                 enabled\nCPU MHz:                         3500.000\nCPU max MHz:                     4761.2300\nCPU min MHz:                     2200.0000\nBogoMIPS:                        6986.90\nVirtualization:                  AMD-V\nL1d cache:                       512 KiB\nL1i cache:                       512 KiB\nL2 cache:                        8 MiB\nL3 cache:                        64 MiB\nNUMA node0 CPU(s):               0-31\nVulnerability Itlb multihit:     Not affected\nVulnerability L1tf:              Not affected\nVulnerability Mds:               Not affected\nVulnerability Meltdown:          Not affected\nVulnerability Mmio stale data:   Not affected\nVulnerability Retbleed:          Mitigation; untrained return thunk; SMT enabled with STIBP protection\nVulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl and seccomp\nVulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization\nVulnerability Spectre v2:        Mitigation; Retpolines, IBPB conditional, STIBP always-on, RSB filling\nVulnerability Srbds:             Not affected\nVulnerability Tsx async abort:   Not affected\nFlags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba ibpb stibp vmmcall fsgsbase bmi1 avx2 smep bmi2 cqm rdt_a rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local clzero irperf xsaveerptr rdpru wbnoinvd arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif v_spec_ctrl umip rdpid overflow_recov succor smca sme sev sev_es\n\n\n検証用データ生成\n\nimport (\n    \"math/rand\"\n)\n\nN := 2048\nveca := make([]float64, N)\nvecb := make([]float64, N)\nfor i := 0; i < N; i++ {\n    veca[i] = rand.Float64()\n    vecb[i] = rand.Float64()\n}\n\nベンチマークコード\n\nimport (\n    \"testing\"\n    \"reflect\"\n    \"runtime\"\n)\n\nfunc bench(f func(a, b []float64, size int) float64, size int) func(b *testing.B) {\n    return func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            f(veca, vecb, size)\n        }\n    }\n}\n\ntype Result struct {\n    Size int\n    Benchmark map[string]testing.BenchmarkResult\n}\n\nresults := []Result{}\nfor _, size := range []int{32, 256, 2048} {\n    type BenchmarkFunc struct {\n        Name string\n        Func func(a, b []float64, size int) float64\n    }\n\n    bs := map[string]testing.BenchmarkResult{}\n    for _, e := range []BenchmarkFunc{\n        {Name: \"CalcDot\",            Func: CalcDot},\n        {Name: \"CalcDotUnroll2\",     Func: CalcDotUnroll2},\n        {Name: \"CalcDotUnroll4\",     Func: CalcDotUnroll4},\n        {Name: \"CalcDotUnroll8\",     Func: CalcDotUnroll8},\n        {Name: \"CalcDotByGonum\",     Func: CalcDotByGonum},\n        {Name: \"CalcDotByGonumBlas\", Func: CalcDotByGonumBlas},\n    } {\n        bs[e.Name] = testing.Benchmark(bench(e.Func, size))\n    }\n    results = append(results, Result{Size: size, Benchmark: bs})\n}\n\nベンチマーク結果\n\n\nCode\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc calcNsPerOp(b *testing.BenchmarkResult) uint64 {\n    return uint64(b.T) / uint64(b.N)\n}\n\nfunc makeRow(funcName string, benchmark *testing.BenchmarkResult) string {\n    nsPerOp := calcNsPerOp(benchmark)\n    return fmt.Sprintf(\"<tr><td>%s</td><td>%d</td><td>%d</td><td>%d</td></tr>\", funcName,  benchmark.N, benchmark.T, nsPerOp)\n}\n\nfunc makeTable(results map[string]testing.BenchmarkResult, size int) string {\n    var rows []string\n    for name, result := range results {\n        rows = append(rows, makeRow(name, &result))\n    }\n    sort.Strings(rows)\n    return fmt.Sprintf(`<table class=\"dataframe\"><caption>size=%d</caption><tr><th>関数名</th><th>回数</th><th>時間[ns]</th><th>1回あたりの時間[ns]</th></tr>%s</table>`, size, strings.Join(rows, \"\\n\"))\n}\n\ntables := []string{}\nfor _, r := range results {\n    tables = append(tables, makeTable(r.Benchmark, r.Size))\n}\ndisplay.HTML(strings.Join(tables, \"\\n\"))\n\n\n\nsize=32関数名回数時間[ns]1回あたりの時間[ns]CalcDot25715011729602354561\nCalcDotByGonum15455212621896398166\nCalcDotByGonumBlas18623210317730815540\nCalcDotUnroll225237212476097584943\nCalcDotUnroll426986312468906844620\nCalcDotUnroll826423212204928004619\nsize=256関数名回数時間[ns]1回あたりの時間[ns]CalcDot75538112826582914936\nCalcDotByGonum13613810916191368018\nCalcDotByGonumBlas19764811632844075885\nCalcDotUnroll260063114320440519033\nCalcDotUnroll470314104170168814814\nCalcDotUnroll873861112081255815174\nsize=2048関数名回数時間[ns]1回あたりの時間[ns]CalcDot12385122313758598759\nCalcDotByGonum13495512211322989048\nCalcDotByGonumBlas31903219857531116224\nCalcDotUnroll287141126122663129231\nCalcDotUnroll4112451151313155102384\nCalcDotUnroll812462114890271392192\n\n\n\n\nCode\nimport (\n    \"math\"\n    \"bytes\"\n    \"gonum.org/v1/plot\"\n    \"gonum.org/v1/plot/plotter\"\n    \"gonum.org/v1/plot/plotutil\"\n    \"gonum.org/v1/plot/vg\"\n    \"gonum.org/v1/plot/vg/draw\"\n)\n\nfunc displayPlot(p *plot.Plot) {\n    var buf bytes.Buffer\n    c, err := p.WriterTo(6*vg.Inch, 6*vg.Inch, \"png\")\n    if err != nil {\n        panic(err)\n    }\n    if _, err := c.WriteTo(&buf); err != nil {\n        panic(err)\n    }\n    Display(display.PNG(buf.Bytes()))\n}\n\n\np := plot.New()\np.Title.Text = \"Benchmark of dot product\"\np.X.Label.Text = \"Function\"\np.Y.Label.Text = \"Duration per op[ns]\"\np.X.Tick.Label.Rotation = math.Pi / 2.5\np.X.Tick.Label.XAlign = draw.XRight\np.Legend.Top = true\n\nnames := []string{}\nfor name, _ := range results[0].Benchmark {\n    names = append(names, name)\n}\nsort.Strings(names)\np.NominalX(names...)\n\n\nfor i, r := range results {\n    var values plotter.Values\n    for _, name := range names {\n        b := r.Benchmark[name]\n        values = append(values, float64(calcNsPerOp(&b)))\n    }\n    bar, _ := plotter.NewBarChart(values, vg.Points(20))\n    bar.LineStyle.Width = vg.Length(0)\n    bar.Color = plotutil.Color(i)\n    bar.Offset = vg.Points(float64(i - 1) * 20)\n    p.Add(bar)\n    p.Legend.Add(fmt.Sprintf(\"size=%d\", r.Size), bar)\n}\n\ndisplayPlot(p)"
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html#まとめ",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html#まとめ",
    "title": "Goによるdot積のベンチマーク",
    "section": "まとめ",
    "text": "まとめ\nベクトルが小さい場合(size=32)は単純にループして計算するのが一番速い。しかしながら、ベクトルが一定サイス(size=128)を超えるとgonumを使用したほうが高速となる。 ループのアンローリングは効果がない。gonumを使用する場合は、blasを使用するとより高速になる。"
  },
  {
    "objectID": "posts/2022-11-08-dot-benchmark-in-go.html#参考",
    "href": "posts/2022-11-08-dot-benchmark-in-go.html#参考",
    "title": "Goによるdot積のベンチマーク",
    "section": "参考",
    "text": "参考\n\n\n[1] Tokyo, W.W.G. 2021. Go言語を楽しむ5つのレシピ: コタツと蜜柑とゴーファーとわたし. インプレスR&D."
  },
  {
    "objectID": "posts/2020-06-27-linear-algebra-in-3d-coordinates.html",
    "href": "posts/2020-06-27-linear-algebra-in-3d-coordinates.html",
    "title": "三次元空間における行列演算の復習",
    "section": "",
    "text": "ぱっと思いつかなかったのでメモ．\n\n任意の単位ベクトルへの射影行列\n任意の単位ベクトルを\\(\\vec{n}\\)とすると，\\(\\vec{n}\\)への射影行列\\(P_{p}\\)は以下の様に表されます．\n\\[\nP_{p} = \\vec{n}\\vec{n}^{T}\n\\]\n\n\n法線ベクトルに直交する平面への射影行列\n法線ベクトルへの射影を元のベクトルから引くことで，法線ベクトルと直交する平面への射影が可能となります． そのため，法線ベクトルと直交する平面への射影行列\\(P_{o}\\)は以下のように表されます．\n\\[\n\\begin{aligned}\nP_{o} &= I - P_{p} \\\\\n      &= I - \\vec{n}\\vec{n}^{T}\n\\end{aligned}\n\\]\n\n\n任意の単位ベクトルを回転軸とした回転行列\n任意の単位ベクトル\\(\\vec{n}\\)を以下のように定義します． \\[\n\\vec{n} = \\left(n_x, n_y, n_z \\right)\n\\]\nここで，Z軸方向の単位ベクトル\\(\\vec{e_{z}}\\)を\\(\\vec{n}\\)に変換する行列\\(P\\)を考えます．\\(P\\)はY軸回転\\(R_{y}\\)とZ軸回転\\(R_{z}\\)の積で以下のように表現できます． \\[\n\\begin{aligned}\nc_{\\theta} &= \\frac{n_{x}}{\\sqrt{n_{x}^{2} + n_{y}^{2}}} \\\\\\\\\ns_{\\theta} &= \\frac{n_{y}}{\\sqrt{n_{x}^{2} + n_{y}^{2}}} \\\\\\\\\nc_{\\phi} &= \\frac{n_{z}}{\\sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} \\\\\\\\\ns_{\\phi} &= \\frac{\\sqrt{n_{x}^{2} + n_{y}^{2}}}{\\sqrt{n_{x}^{2} + n_{y}^{2} + n_{z}^{2}}} \\\\\\\\\nR_{xz} &= \\left(\\begin{array}{rrr}\nc_{\\phi} & 0 & s_{\\phi} \\\\\\\\\n0 & 1 & 0 \\\\\\\\\n-s_{\\phi}& 0 & c_{\\phi}\n\\end{array}\\right)\\\\\\\\\nR_{xy} &= \\left(\\begin{array}{rrr}\nc_{\\theta} & -s_{\\theta} & 0 \\\\\\\\\ns_{\\theta} & c_{\\theta} & 0 \\\\\\\\\n0 & 0 & 1\n\\end{array}\\right)\\\\\\\\\nP &= R_{xy} * R_{xz}\n\\end{aligned}\n\\]\n\\(P\\)によって変換されたZ軸を\\(\\vec{e_{z}'}(=\\vec{n})\\)とすると，所望の任意の単位ベクトルを回転軸とする回転行列は以下の３つの変換の合成で表すことができます．\n\n\\(\\vec{e_{z}}\\)を\\(\\vec{e_{z}}'\\)に変換する\\(P\\)\n\\(\\vec{e_{z}}\\)を回転軸とする回転\\(R_{a}\\)\n\\(\\vec{e_{z}}'\\)を\\(\\vec{e_{z}}\\)に変換する\\(P^{T}\\)\n\nしたがって，最終的な回転行列\\(R\\)は以下のように表されます．\n\\[\n\\begin{aligned}\nR_{a} &= \\left(\\begin{array}{rrr}\n\\cos\\left(a\\right) & -\\sin\\left(a\\right) & 0 \\\\\\\\\n\\sin\\left(a\\right) & \\cos\\left(a\\right) & 0 \\\\\\\\\n0 & 0 & 1\n\\end{array}\\right) \\\\\\\\\nR &= P * R_{a} * P^{T} \\\\\\\\\n&= \\left(\\begin{array}{rrr}\n\\mathit{n_{x}}^{2} + {\\left(\\mathit{n_{y}}^{2} + \\mathit{n_{z}}^{2}\\right)} \\cos\\left(a\\right) & -\\mathit{n_{x}} \\mathit{n_{y}} \\cos\\left(a\\right) + \\mathit{n_{x}} \\mathit{n_{y}} - {\\left(\\mathit{n_{z}}^{3} + {\\left(\\mathit{n_{x}}^{2} + \\mathit{n_{y}}^{2}\\right)} \\mathit{n_{z}}\\right)} \\sin\\left(a\\right) & -\\mathit{n_{x}} \\mathit{n_{z}} \\cos\\left(a\\right) + \\mathit{n_{x}} \\mathit{n_{z}} + \\mathit{n_{y}} \\sin\\left(a\\right) \\\\\\\\\n-\\mathit{n_{x}} \\mathit{n_{y}} \\cos\\left(a\\right) + \\mathit{n_{x}} \\mathit{n_{y}} + {\\left(\\mathit{n_{z}}^{3} + {\\left(\\mathit{n_{x}}^{2} + \\mathit{n_{y}}^{2}\\right)} \\mathit{n_{z}}\\right)} \\sin\\left(a\\right) & \\mathit{n_{y}}^{2} + {\\left(\\mathit{n_{x}}^{2} + \\mathit{n_{z}}^{2}\\right)} \\cos\\left(a\\right) & -\\mathit{n_{y}} \\mathit{n_{z}} \\cos\\left(a\\right) + \\mathit{n_{y}} \\mathit{n_{z}} - \\mathit{n_{x}} \\sin\\left(a\\right) \\\\\\\\\n-\\mathit{n_{x}} \\mathit{n_{z}} \\cos\\left(a\\right) + \\mathit{n_{x}} \\mathit{n_{z}} - {\\left(\\mathit{n_{x}}^{2} \\mathit{n_{y}} + \\mathit{n_{y}}^{3} + \\mathit{n_{y}} \\mathit{n_{z}}^{2}\\right)} \\sin\\left(a\\right) & -\\mathit{n_{y}} \\mathit{n_{z}} \\cos\\left(a\\right) + \\mathit{n_{y}} \\mathit{n_{z}} + {\\left(\\mathit{n_{x}}^{3} + \\mathit{n_{x}} \\mathit{n_{y}}^{2} + \\mathit{n_{x}} \\mathit{n_{z}}^{2}\\right)} \\sin\\left(a\\right) & \\mathit{n_{z}}^{2} + {\\left(\\mathit{n_{x}}^{2} + \\mathit{n_{y}}^{2}\\right)} \\cos\\left(a\\right)\n\\end{array}\\right) \\\\\\\\\n&= \\left(\\begin{array}{rrr}\n\\cos\\left(a\\right) + \\mathit{n_{x}}^{2} \\left(1-\\cos\\left(a\\right)\\right) & \\mathit{n_{x}} \\mathit{n_{y}} \\left(1 - \\cos\\left(a\\right) \\right) - \\mathit{n_{z}}\\sin\\left(a\\right) & \\mathit{n_{x}} \\mathit{n_{z}} \\left( 1 -  \\cos\\left(a\\right) \\right) + \\mathit{n_{y}} \\sin\\left(a\\right) \\\\\\\\\n\\mathit{n_{x}} \\mathit{n_{y}}\\left( 1 -  \\cos\\left(a\\right) \\right) + \\mathit{n_{z}} \\sin\\left(a\\right) & \\cos\\left(a\\right) + \\mathit{n_{y}}^{2}\\left( 1-  \\cos\\left(a\\right)\\right) & \\mathit{n_{y}} \\mathit{n_{z}}\n\\left( 1- \\cos\\left(a\\right) \\right) - \\mathit{n_{x}} \\sin\\left(a\\right) \\\\\\\\\n\\mathit{n_{x}} \\mathit{n_{z}}\\left(1- \\cos\\left(a\\right) \\right) - \\mathit{n_{y}}\\sin\\left(a\\right) & \\mathit{n_{y}} \\mathit{n_{z}} \\left(1- \\cos\\left(a\\right) \\right) + \\mathit{n_{x}}\\sin\\left(a\\right) & \\cos\\left(a\\right) + \\mathit{n_{z}}^{2} \\left( 1-\\cos\\left(a\\right) \\right)\n\\end{array}\\right)\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html",
    "href": "posts/2020-08-09-automated-update-github-pages.html",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "",
    "text": "GitHubPages + GitHub Actions でコンテンツを自動的に更新するWebサイトをつくってみました．GitHub Trending に登場したリポジトリに付与されていた topics を一覧表示するサイトです．言語ごとの用途がざっくりとした感じでみることができます．\nTopics in GitHub Trending - GitHub\n今回，勉強も兼ねてフロントエンドとデータのクローリング処理共に Elm で記述しました．"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html#github-actions-によるバッチ処理の定刻実行",
    "href": "posts/2020-08-09-automated-update-github-pages.html#github-actions-によるバッチ処理の定刻実行",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "GitHub Actions によるバッチ処理の定刻実行",
    "text": "GitHub Actions によるバッチ処理の定刻実行\nGitHub Actionsによって定刻実行されるバッチ処理はは以下の3つのジョブからなります．\n\nbuild\ncrawl\npush\n\nそれぞれ，クローリングスクリプトのビルド，データのクローリング，データのリポジトリへのプッシュを行います．設定の詳細はこちらを参考にしてください．"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html#cliプログラムを-elm-で書く",
    "href": "posts/2020-08-09-automated-update-github-pages.html#cliプログラムを-elm-で書く",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "CLIプログラムを Elm で書く",
    "text": "CLIプログラムを Elm で書く\ncrawlジョブではElmで記述されたCLIプログラムを実行してデータの取得を行います．ElmはWebフロントエンドを記述することに特化している言語です．そのため，CLIプログラムの開発に必要な，コマンドライン引数の処理といった機能がサポートされいません．そこで，今回は以下のパッケージを持ちました．\npdillonkearns/elm-cli-options-parser\nこちらのパッケージを用いると，Flagを用いてコマンドライン引数へのアクセスが可能となります．今回のプログラムでは，以下の様にgithubToken と language と dataRange とを引数から受け取っています．\ninit : Flags -> TrendingApiOptions -> ( Model, Cmd Msg )\ninit { githubToken } { language, dateRange } =\n    ( { githubToken = githubToken }\n    , attemptApi TrendingApiResponse (fetchTrending githubToken language dateRange)\n    )\nまた，GitHub Tredingsの取得は以下のAPIを利用させていただきました．\ngithub-trending-api"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html#クローリング結果の保存",
    "href": "posts/2020-08-09-automated-update-github-pages.html#クローリング結果の保存",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "クローリング結果の保存",
    "text": "クローリング結果の保存\n今回，GitHub PagesのみでWebサイトをホスティングするため，データベースを使用することはできません．そのため，クローリング結果はJSONに整形されたのちに，直接GitHub Pagesのリポジトリにプッシュされます．\ntopics\nこの，JSONをフロントエンドから取得することで動的なコンテンツ更新を実現します．"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html#elmによるフロントエンド開発",
    "href": "posts/2020-08-09-automated-update-github-pages.html#elmによるフロントエンド開発",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "Elmによるフロントエンド開発",
    "text": "Elmによるフロントエンド開発\n特筆すべきことはありません．Elmは本当に書きやすい言語でした．"
  },
  {
    "objectID": "posts/2020-08-09-automated-update-github-pages.html#所感",
    "href": "posts/2020-08-09-automated-update-github-pages.html#所感",
    "title": "GitHub ActionsでWebサイトを自動更新する",
    "section": "所感",
    "text": "所感\nElmの勉強としてはちょうど良い分量でした．GitHub PagesとGitHub Actionsで結構なことができる印象なので，また何かチャレンジしたいですね．"
  },
  {
    "objectID": "posts/2020-05-31-poisson-blending-in-5-lines.html",
    "href": "posts/2020-05-31-poisson-blending-in-5-lines.html",
    "title": "5行で書くポアソンブレンディング",
    "section": "",
    "text": "画像の滑らかな合成アルゴリズムにポアソンブレンディング(Poisson Image Editting)があります．これは，ポアソン方程式を解くことで元の勾配を保ちながら，境界部分が連続となる合成画像を推定するというものです． ネットを調べると，ポアソン方程式の計算にはSOR法やマルチグリッド法などを実装した高速な連立方程式ソルバを利用することが多いようです．しかしながら，外部のソルバを利用するとプロジェクトの規模が大きくなってしまいます．また，外部のソルバを利用せず，上述のアルゴリズムを自前で実装することは非常に困難な作業です．そこで，ヤコビ法をラプラシアンフィルタで記述し実装を簡略化しました．"
  },
  {
    "objectID": "posts/2020-05-31-poisson-blending-in-5-lines.html#やったこと",
    "href": "posts/2020-05-31-poisson-blending-in-5-lines.html#やったこと",
    "title": "5行で書くポアソンブレンディング",
    "section": "やったこと",
    "text": "やったこと\n\nラプラシアンフィルタを使用してヤコビ法を記述\nポアソンブレンディングを５行で実装\nプロジェクトをGithubに作成"
  },
  {
    "objectID": "posts/2020-05-31-poisson-blending-in-5-lines.html#ポアソン方程式をラプラシアンフィルタで記述する",
    "href": "posts/2020-05-31-poisson-blending-in-5-lines.html#ポアソン方程式をラプラシアンフィルタで記述する",
    "title": "5行で書くポアソンブレンディング",
    "section": "ポアソン方程式をラプラシアンフィルタで記述する",
    "text": "ポアソン方程式をラプラシアンフィルタで記述する\n参考記事によると，座標\\(p\\)における画素値\\(f_p\\)は以下の式で求められます．\n\\[\nf_p = \\frac{\\sum_{q \\in N} f_q + 4 g_{q} - \\sum_{q \\in N} g_q}{4}\n\\]\nここで，ヤコビ法によって\\(f_p\\)を求めます．\\(k\\)回目のイテレーションにおける座標\\(p\\)における画素値を\\(f_{p}^{k}\\)とします．すると，\\(f_{p}^{k}\\)は以下のように表記することができます．\n\\[\n\\begin{aligned}\nf_{p}^{k+1} &=  \\frac{\\sum_{q \\in N} f_{q}^{k} + 4 g_{p} - \\sum_{q \\in N} g_{q}}{4} \\\\\\\\\n&= \\frac{4f_{p}^{k} -4 f_{p}^{k}  + \\sum_{q \\in N} f_{q}^{k} + 4 g_{p} - \\sum_{q \\in N} g_q}{4} \\\\\\\\\n&= f_{p}^{k} + \\frac{-4 (f_{p}^{k} - g_{p})  + \\sum_{q \\in N} f_{q}^{k}  - g_q}{4} \\\\\\\\\n&= f_{p}^{k} + \\frac{1}{4} \\Delta_{p} \\left(f - g\\right)\n\\end{aligned}\n\\]\n以上の結果より，注目領域に\\(\\frac{1}{4} \\Delta_{p} \\left(f - g\\right)\\)を加算していくことで合成を行います． \\(\\Delta_{p}\\)は座標\\(p\\)におけるラプラシアンを表します．以下にscipyを用いで実装したコードを示します．関数の引数はそれぞれ，target_imgが合成先画像，src_imgが合成元画像, mask_imgが合成領域マスク, iterが反復処理の回数をそれぞれ表します．コードサイズを5行に抑えるため，省いた処理（入力のバリデーション，反復処理の打ち切り）や冗長な処理（target_imgとsrc_imgとの差分を毎ループ計算している）がありますが，アルゴリズムのエッセンスは十分表現できていると思います．"
  },
  {
    "objectID": "posts/2020-05-31-poisson-blending-in-5-lines.html#行で実装",
    "href": "posts/2020-05-31-poisson-blending-in-5-lines.html#行で実装",
    "title": "5行で書くポアソンブレンディング",
    "section": "5行で実装",
    "text": "5行で実装\nfrom scipy.ndimage import laplace\ndef poisson_blend(target_img, src_img, mask_img, iter: int = 1024):\n    for _ in range(iter):\n        target_img = target_img + 0.25 * mask_img * laplace(target_img - src_img)\n    return target_img.clip(0, 1)\npoisson_blendの入力と出力との関係を以下の図に示します．以下の図は，左側から合成元画像(src_img)，合成領域マスク(mask_img)，合成先画像(target_img)，合成画像を表します．境界領域が滑らかに合成されていることが確認できます．\n\n\n\noutput\n\n\n上記の関数に加え，結果確認用のノートブックなどを追加したリポジトリを作成しました．よろしければ，こちらも参考にしてください."
  },
  {
    "objectID": "posts/2020-05-31-poisson-blending-in-5-lines.html#参考",
    "href": "posts/2020-05-31-poisson-blending-in-5-lines.html#参考",
    "title": "5行で書くポアソンブレンディング",
    "section": "参考",
    "text": "参考\n\n\n[1] Poisson image editing. https://ja.wikipedia.org/wiki/Poisson_Image_Editing.\n\n\n[2] Poisson-blending-in-5lines. GitHub repository. https://github.com/ar90n/poisson-blending-in-5lines; GitHub."
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "",
    "text": "拡大と回転と並進とによって実現する幾何学変換に相似変換があります．これは，画像間の位置合わせ等に用いられます． 具体的には，互いに対応する点\\({x_{i}}\\)と\\(y_{i}\\left(i = 1, 2, \\dots n \\right)\\)が与えられた時，それらの間に存在する相似変換を推定するといったものです．\nこれを実現アルゴリズムにS.Umeyamaによって提案された手法があります．古典的な手法ではありますが，実用的なアルゴリズムであると思います．scikit-imageにおけるSimilalityTransformでも使用されています．"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#やったこと",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#やったこと",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "やったこと",
    "text": "やったこと\n\nLeast-Squares Estimation of Transformation Parameters Between Two Point Patternsによる提案手法を読む\nPythonによる簡易的な実装"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#行列の性質復習",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#行列の性質復習",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "行列の性質復習",
    "text": "行列の性質復習\n以下にこれから利用する行列の性質を示します．ここで，\\(\\mathbf A = \\left(a_{i,j}\\right)\\)及び\\(\\mathbf B = \\left(b_{i,j}\\right)\\)は行列を，\\(\\left<\\cdot, \\cdot\\right>\\)は行列の内積を表します．\n\\[\n\\begin{aligned}\n\\mathrm {tr} \\mathbf A &= \\mathrm {tr} \\mathbf A^{\\mathrm T}  \\\\\n\\mathrm {tr} \\mathbf A \\mathbf B \\mathbf C &= \\mathrm {tr} \\mathbf B \\mathbf C \\mathbf A \\\\\n\\mathrm {tr} \\mathbf A^{\\mathrm T} \\mathbf B &= \\left<\\mathbf A, \\mathbf B \\right> \\\\\n&= \\left\\|\\mathbf A \\mathbf B \\right\\|^{2} \\\\\n\\frac{\\partial}{\\partial \\mathbf A} \\mathrm {tr} \\left(\\mathbf A \\mathbf B\\right) &= \\mathbf B^{T} \\\\\n\\frac{\\partial}{\\partial \\mathbf A} \\mathrm {tr} \\left(\\mathbf A^{\\mathrm T} \\mathbf B\\right) &= \\mathbf B \\\\\n\\frac{\\partial}{\\partial \\mathbf A} \\mathrm {tr} \\left(f\\left(\\mathbf A\\right) g\\left(\\mathbf A\\right)\\right) &= \\frac{\\partial}{\\partial \\mathbf A_{1}} \\mathrm {tr} \\left(f\\left(\\mathbf A_{1}\\right) g\\left(\\mathbf A\\right)\\right) + \\frac{\\partial}{\\partial \\mathbf A_{2}} \\mathrm {tr} \\left(f\\left(\\mathbf A\\right) g\\left(\\mathbf A_{2}\\right)\\right)  \\\\\n\\left<\\mathbf A, \\mathbf B \\right> &= \\mathrm {tr} \\mathbf A^{\\mathrm T} B \\\\\n&= \\sum_{i,j} a_{j,i}b_{i,j}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#相似変換について",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#相似変換について",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "相似変換について",
    "text": "相似変換について\n上述したとおり，相似変換とは拡大と回転と並進とによって実現する幾何学的変換です．従って，変換元を\\(\\mathbf x\\)，変換先を\\(\\mathbf x'\\)，拡大率，回転行列，並進ベクトルをそれぞれ\\(\\left(c, \\mathbf R, \\mathbf t \\right)\\)とすると\n\\[\n\\begin{aligned}\n\\mathbf x' &= c\\mathbf R \\mathbf x  + \\mathbf t\n\\end{aligned}\n\\]\nと表されます．\nここで，特徴点\\(\\mathbf x_{i}\\)と，その相似変換による変換\\(\\mathbf y_{i}\\ \\left(i = 1, 2, \\dots , n \\right)\\)を観測した場合を考えます．この時，以下の\\(e\\left(c, \\mathbf R, \\mathbf t\\right)\\)を最小化することで，\\(\\mathbf x_{i}\\)と\\(\\mathbf y_{i}\\)から相似変換のパラメータ\\(\\left(c, \\mathbf R, \\mathbf t \\right)\\)を推定することができます．\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t\\right) &= \\frac{1}{n} \\sum_{i=1}^{n} \\left| \\mathbf y_{i} - \\left(c\\mathbf R \\mathbf x_{i} + \\mathbf t\\right)\\right|^{2}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#回転行列の推定",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#回転行列の推定",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "回転行列の推定",
    "text": "回転行列の推定\n相似変換に推定の先立ち，まずは以下の式を最小化する\\(\\mathbf R\\)を推定することを考えます．ここで，\\(\\mathbf A\\)及び\\(\\mathbf B\\)は\\(m \\times n\\)の行列を，\\(\\mathbf R\\)は\\(m \\times m\\)の行列を表します．\n\\[\n\\begin{alignedat}{4}\n\\text{minimize}  & \\ \\ \\ \\ \\  &  \\left\\| \\mathbf A - \\mathbf R \\mathbf B\\right\\|^{2}  & \\\\\n\\text{subject to} &\\ &\\left|\\mathbf R \\right| &= 1& \\\\\n                   &\\ & \\mathbf R\\mathbf R^{\\mathrm T} &= \\mathbf I\n\\end{alignedat}\n\\]\n\\(\\mathbf R\\)を適切に推定するためには，与えられた束縛条件の元で目的関数を最小化する必要があります．従って，ラグランジュの未定乗数法を用います．ここでは，ラグランジュ関数\\(F\\)は以下の様に表されます．なお，\\(l_{i,j}\\)及び\\(g\\)はラグランジュ乗数となります．\n\\[\n\\begin{aligned}\nF &= \\left\\|\\mathbf A - \\mathbf R \\mathbf B \\right\\|^{2} + \\sum_{i=1}^{m} \\sum_{j=1}^{m} l_{i,j} \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)_{i,j} + g\\left(\\left|\\mathbf R \\right| - 1 \\right)\n\\end{aligned}\n\\]\n上式において，\\(\\mathbf R^{\\mathrm T}\\mathbf R\\)と\\(\\mathbf I\\)は対象行列です．従って，それらの差である$ (R^{T}R - I )\\(も対象行列となります．\\) (R^{T}R - I )$が対象行列であるならば，対象な成分に対応するラグランジュ乗数も同様に等しくなります．すなわち，\n\\[\n\\begin{aligned}\nl_{i,j} &= l_{j,i}\n\\end{aligned}\n\\]\nとなります．従って，ラグランジュ関数の第2項は以下の様に表現することが可能です．\n\\[\n\\begin{aligned}\n\\sum_{i=1}^{m} \\sum_{j=1}^{m} l_{i,j} \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)_{i,j}　&= \\left< \\left(l_{i,j}\\right), \\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I  \\right>\\\\\n&= \\mathrm{tr} \\left(\\left(l_{j,i}\\right) \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)\\right)\\\\\n&= \\mathrm{tr} \\left(\\left(l_{i,j}\\right) \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)\\right)\\\\\n\\end{aligned}\n\\]\nここで，\n\\[\n\\begin{aligned}\n\\mathbf L &= \\left(l_{i,j} \\right)\n\\end{aligned}\n\\]\nと置くと，\n\\[\n\\begin{aligned}\n\\mathrm{tr} \\left(\\left(l_{i,j}\\right) \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)\\right)　&= \\mathrm{tr}\\left( \\mathbf L \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)\\right)\\\\\n\\end{aligned}\n\\]\nと表すことができます．従って，ラグランジュ関数\\(F\\)は以下の様に表現されます．\n\\[\n\\begin{aligned}\nF &= \\left\\|\\mathbf A - \\mathbf R \\mathbf B \\right\\|^{2} + \\mathrm{tr} \\left(\\mathbf L \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)  \\right) + g\\left(\\left|\\mathbf R \\right| - 1 \\right) \\\\\n\\end{aligned}\n\\]\n\\(F\\)を最小化する\\(\\mathbf R\\)を求めるためには，以下の式を\\(\\mathbf R\\)について解く必要があります．\n\\[\n\\begin{aligned}\n\\frac{\\partial F}{\\partial \\mathbf R} &= \\frac{\\partial}{\\partial \\mathbf R} \\left\\|\\mathbf A - \\mathbf R \\mathbf B \\right\\|^{2} + \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf L \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)  \\right) +\\frac{\\partial}{\\partial \\mathbf R}  g\\left(\\left|\\mathbf R \\right| - 1 \\right) \\\\\n&= 0\n\\end{aligned}\n\\]\nまずは，右辺第１項について考えます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\mathbf R} \\left\\|\\mathbf A - \\mathbf R \\mathbf B \\right\\|^{2} &=  \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\left(\\mathbf A - \\mathbf R \\mathbf B \\right)^{\\mathrm T}\\left(\\mathbf A - \\mathbf R \\mathbf B \\right)\\right) \\\\\n&=  \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf A^{\\mathrm T} \\mathbf A - \\mathbf A^{\\mathrm T}\\mathbf R \\mathbf B - \\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf A + \\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf R \\mathbf B\\right) \\\\\n&=  \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf A^{\\mathrm T} \\mathbf A\\right) - \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf A^{\\mathrm T}\\mathbf R \\mathbf B\\right) + \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf A \\right) +\\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf R \\mathbf B\\right) \\\\\n&=  - \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf B \\mathbf A^{\\mathrm T}\\mathbf R\\right) - \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf A\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right) +\\frac{\\partial}{\\partial \\mathbf R_{1}} \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T}\\mathbf R_{1}^{\\mathrm T} \\mathbf R \\mathbf B\\right)  +\\frac{\\partial}{\\partial \\mathbf R_{2}} \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf R_{2} \\mathbf B\\right) \\\\ \\\\\n&=  - \\mathbf A \\mathbf B^{\\mathrm T} - \\mathbf A\\mathbf B^{\\mathrm T} + \\frac{\\partial}{\\partial \\mathbf R_{1}} \\mathrm{tr} \\left(\\mathbf R_{1}^{\\mathrm T} \\mathbf R \\mathbf B\\mathbf B^{\\mathrm T}\\right)  +\\frac{\\partial}{\\partial \\mathbf R_{2}} \\mathrm{tr} \\left(\\mathbf B\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf R_{2}\\right) \\\\ \\\\\n&= -2 \\mathbf A \\mathbf B^{\\mathrm T} + \\mathbf R \\mathbf B \\mathbf B^{\\mathrm T} + \\left(\\mathbf B \\mathbf B^{\\mathrm T} \\mathbf R^{\\mathrm T} \\right)^{\\mathrm T} \\\\\n&= -2 \\mathbf A \\mathbf B^{\\mathrm T} + \\mathbf R \\mathbf B \\mathbf B^{\\mathrm T} + \\mathbf R \\mathbf B \\mathbf B^{\\mathrm T}  \\\\\n&= -2 \\mathbf A \\mathbf B^{\\mathrm T} + 2\\mathbf R \\mathbf B \\mathbf B^{\\mathrm T}\n\\end{aligned}\n\\]\n次に，右辺第２項について考えます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf L \\left(\\mathbf R^{\\mathrm T}\\mathbf R - \\mathbf I \\right)  \\right) &= \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf L \\mathbf R^{\\mathrm T}\\mathbf R \\right) - \\frac{\\partial}{\\partial \\mathbf R} \\mathrm{tr} \\left(\\mathbf L\\right) \\\\\n&= \\frac{\\partial}{\\partial \\mathbf R_{1}}  \\mathrm {tr} \\left(\\mathbf L \\mathbf R_{1}^{\\mathrm T} \\mathbf R \\right) + \\frac{\\partial}{\\partial \\mathbf R_{2}}  \\mathrm {tr} \\left(\\mathbf L \\mathbf R^{\\mathrm T} \\mathbf R_{2} \\right)  \\\\\n&= \\frac{\\partial}{\\partial \\mathbf R_{1}}  \\mathrm {tr} \\left(\\mathbf R \\mathbf L \\mathbf R_{1}^{\\mathrm T}\\right) + \\left(\\mathbf L \\mathbf R^{\\mathrm T}\\right)^{\\mathrm T}  \\\\\n&= \\mathbf R \\mathbf L  + \\mathbf R \\mathbf L^{\\mathrm T}\\\\\n&= \\mathbf R \\mathbf L  + \\mathbf R \\mathbf L\\\\\n&= 2\\mathbf R \\mathbf L \\\\\n\\end{aligned}\n\\]\n最後に，右辺第３項について考えます．\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial \\mathbf R}  g\\left(\\left|\\mathbf R \\right| - 1 \\right) &= g \\frac{\\partial}{\\partial \\mathbf R} \\left|\\mathbf R \\right|\\\\\n&= g \\mathbf{R}\\\\\n\\end{aligned}\n\\]\n以上の結果より，\n\\[\n\\begin{aligned}\n\\frac{\\partial F}{\\partial \\mathbf R}  &= -2 \\mathbf A \\mathbf B^{\\mathrm T} + 2\\mathbf R \\mathbf B \\mathbf B^{\\mathrm T} + 2\\mathbf R \\mathbf L +g \\mathbf{R}  \\\\\n&= 0\\\\\n\\end{aligned}\n\\]\nと表現することができます．上式を整理すると，\n\\[\n\\begin{aligned}\n2\\mathbf R \\mathbf B \\mathbf B^{\\mathrm T} + 2\\mathbf R \\mathbf L +g \\mathbf{R}  &=2 \\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\mathbf R\\left(\\mathbf B \\mathbf B^{\\mathrm T} + \\mathbf L + \\frac{1}{2}g \\mathbf I \\right)  &= \\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nと表すことができます．ここで，\n\\[\n\\begin{aligned}\n\\mathbf L'  &= \\mathbf B \\mathbf B^{\\mathrm T} + \\mathbf L + \\frac{1}{2}g \\mathbf I\n\\end{aligned}\n\\]\nと置きます．すると，\n\\[\n\\begin{aligned}\n\\mathbf R\\mathbf L'  &= \\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\mathbf L'^{\\mathrm T}\\mathbf R^{\\mathrm T}  &= \\mathbf B \\mathbf A^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nとなります．\\(\\mathbf B \\mathbf B^{\\mathrm T}\\)，\\(\\mathbf L\\)及び\\(\\mathbf I\\)は全て対象行列です．従って，\n\\[\n\\begin{aligned}\n\\mathbf L'  &= \\mathbf L'^{\\mathrm T}\n\\end{aligned}\n\\]\nという関係が成立します．従って，\n\\[\n\\begin{aligned}\n\\mathbf L'\\mathbf R^{\\mathrm T}  &= \\mathbf B \\mathbf A^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nとなります．ここで，両辺にそれぞれ自身の転置を掛けると，\n\\[\n\\begin{aligned}\n\\mathbf L'\\mathbf R^{\\mathrm T} \\left(\\mathbf L'\\mathbf R^{\\mathrm T} \\right)^{\\mathrm T} &= \\mathbf L'\\mathbf R^{\\mathrm T} \\mathbf R \\mathbf L'^{\\mathrm T}\\\\\n&= \\mathbf L'\\mathbf L'^{\\mathrm T} \\\\\n&= \\mathbf L'^{2}\\\\\n&= \\mathbf B \\mathbf A^{\\mathrm T} \\left(\\mathbf B \\mathbf A^{\\mathrm T} \\right)^{\\mathrm T}  \\\\\n\\end{aligned}\n\\]\nとなります．また，\\(\\mathbf A\\mathbf B^{\\mathrm T}\\)の特異値分解を以下の様に置きます．\n\\[\n\\begin{aligned}\n\\mathbf A\\mathbf B^{\\mathrm T} &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\n\\end{aligned}\n\\]\nすると，\n\\[\n\\begin{aligned}\n\\mathbf L'^{2} &= \\left(\\mathbf U \\mathbf D \\mathbf V^{\\mathrm T} \\right)^{\\mathrm T} \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T} \\\\\n&= \\mathbf V \\mathbf D \\mathbf U^{\\mathrm T}\\mathbf U \\mathbf D \\mathbf V^{\\mathrm T} \\\\\n&= \\mathbf V \\mathbf D^{2} \\mathbf V^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nであり，\n\\[\n\\begin{aligned}\n\\mathbf L' &= \\mathbf V \\sqrt{\\mathbf D^{2}} \\mathbf V^{\\mathrm T} \\\\\n&=  \\mathbf V  \\begin{pmatrix}\n\\ddots & & \\\\\n& \\sqrt{d_{i}^{2}}& \\\\\n& & \\ddots\\\\\n\\end{pmatrix}\n\\mathbf V^{\\mathrm T} \\\\\n&=  \\mathbf V  \\begin{pmatrix}\n\\ddots & & \\\\\n& d_{i}s_{i}& \\\\\n& & \\ddots\\\\\n\\end{pmatrix}\n\\mathbf V^{\\mathrm T} \\\\\n&=  \\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T}\n\\end{aligned}\n\\]\nと表すことができます．なお，\\(\\mathbf S = \\mathop{\\rm diag}s_{i}\\ \\left(s_{i} = \\pm1\\right)\\)となります．\n次に，上式の両辺に対して行列式を考えます．すると，\n\\[\n\\begin{aligned}\n\\left| \\mathbf L' \\right| &= \\left| \\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T} \\right| \\\\\n&= \\left| \\mathbf V \\right| \\cdot \\left| \\mathbf D\\right|  \\cdot \\left| \\mathbf S\\right|  \\cdot \\left| \\mathbf V^{\\mathrm T} \\right| \\\\\n\\end{aligned}\n\\]\nであり，\\(\\left|\\mathbf V\\right| = \\left|\\mathbf V^{\\mathrm T}\\right| = 1\\)より，\n\\[\n\\begin{aligned}\n&= \\left| \\mathbf D\\right|  \\cdot \\left| \\mathbf S\\right| \\\\\n\\end{aligned}\n\\]\nまた，\n\\[\n\\begin{aligned}\n\\mathbf R\\mathbf L'  &= \\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\mathbf R^{\\mathrm T}\\mathbf R\\mathbf L'  &= \\mathbf R^{\\mathrm T}\\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\mathbf L'  &= \\mathbf R^{\\mathrm T}\\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nであることから，\n\\[\n\\begin{aligned}\n\\left| \\mathbf L' \\right|  &= \\left| \\mathbf R^{\\mathrm T} \\right| \\cdot \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\\\\n&= \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\\\\n\\end{aligned}\n\\]\nとなります．従って， \\[\n\\begin{aligned}\n\\left| \\mathbf D\\right|  \\cdot \\left| \\mathbf S\\right| &=   \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\\\\n\\end{aligned}\n\\]\nと表すことができます．また，特異値の性質より，\\(d_{i} \\geq 0\\)であるため，\n\\[\n\\begin{aligned}\n\\left| \\mathbf D\\right|  &\\geq 0 \\\\\n\\end{aligned}\n\\]\nとなります．従って，\n\\[\n\\begin{aligned}\n  \\left| \\mathbf S\\right|&= \\begin{cases}\n    1 & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right|  \\geq 0 \\\\\n    -1 &\\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\leq 0\n  \\end{cases}\n\\end{aligned}\n\\]\nとなります．ここで，\\(\\left| \\mathbf A - \\mathbf R \\mathbf B\\right|^{2}\\)の最小化について考えます．以上の結果より\\(\\left| \\mathbf A - \\mathbf R \\mathbf B\\right|^{2}\\)は，\n\\[\n\\begin{aligned}\n\\left\\| \\mathbf A - \\mathbf R \\mathbf B\\right\\|^{2} &= \\mathrm{tr} \\left(\\left(\\mathbf A - \\mathbf R \\mathbf B\\right)^{\\mathrm T} \\left(\\mathbf A - \\mathbf R \\mathbf B\\right)  \\right) \\\\\n&= \\mathrm{tr}\\left(\\mathbf A^{\\mathrm T}\\mathbf A\\right) - \\mathrm{tr} \\left(\\mathbf A^{\\mathrm T}\\mathbf R \\mathbf B\\right)\n- \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right) + \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf R \\mathbf B\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} - \\mathrm{tr} \\left(\\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right)^{\\mathrm T}\\right) - \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right)  + \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T} \\mathbf R^{\\mathrm T}\\mathbf R \\mathbf B\\right)\\\\\n&=  \\left\\|\\mathbf A\\right\\|^{2} - \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right) - \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right)  + \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T} \\mathbf B\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} - 2 \\mathrm{tr} \\left(\\left(\\mathbf R \\mathbf B\\right)^{\\mathrm T}\\mathbf A\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} - 2 \\mathrm{tr} \\left(\\mathbf B^{\\mathrm T}\\mathbf R^{\\mathrm T} \\mathbf A\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} - 2 \\mathrm{tr} \\left(\\mathbf R^{\\mathrm T} \\mathbf A\\mathbf B^{\\mathrm T}\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} - 2 \\mathrm{tr} \\left(\\mathbf L'\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} -2 \\mathrm{tr} \\left(\\mathbf V\\mathbf D\\mathbf S\\mathbf V^{\\mathrm T}\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} -2 \\mathrm{tr} \\left(\\mathbf D\\mathbf S\\mathbf V^{\\mathrm T}\\mathbf V\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} -2 \\mathrm{tr} \\left(\\mathbf D\\mathbf S\\right)\\\\\n&= \\left\\|\\mathbf A\\right\\|^{2} + \\left\\|\\mathbf B\\right\\|^{2} -2 \\left(d_{1}s_{1} + d_{2}s_{2} + \\cdots + d_{m}s_{m} \\right)\\\\\n\\end{aligned}\n\\]\nと表すことができます．ここで，\\(\\mathbf A\\)，\\(\\mathbf B\\)，\\(d_{i}\\)が問題より与えられており，\\(\\left\\|\\mathbf A\\right\\|^{2} \\ge 0\\)，\\(\\left\\|\\mathbf B\\right\\|^{2} \\ge 0\\)となります．従って，\\(\\text{minimize}\\ \\left\\| \\mathbf A - \\mathbf R \\mathbf B\\right\\|^{2}\\)は以下の様に書き換えることができます．\n\\[\n\\begin{alignedat}{4}\n\\text{maximize}  & \\ \\ \\ \\ \\  &  d_{1}s_{1} + d_{2}s_{2} + \\cdots + d_{m}s_{m}  & \\\\\n\\text{subject to} &\\ & s_{1}s_{2} \\cdots s_{m} &=  \\begin{cases}\n    1 & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right|  \\geq 0 \\\\\n    -1 & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\leq 0\n  \\end{cases}& \\\\\n                   &\\ & \\left| s_{i} \\right|  &= 1\n\\end{alignedat}\n\\]\nまず，\\(\\left| \\mathbf A \\mathbf B^{\\mathrm T} \\right| \\geq 0\\)の場合について考えます．この時，\\(s_{i}=1\\)で目的関数が最大化することは明らかです．次に，$ | A B^{T} | \\(の場合について考えます．\\)d_{1} d_{2} d_{m}\\(であるため，\\)s_{1} = s_{2} = = s_{m-1} = 1\\(，\\)s_{m} = -1$で目的関数が最大化します．\n最後に，以上の結果を元に実際に\\(\\mathbf R\\)を求めていきます．まず，\\(\\mathrm{rank}\\left(\\mathbf A \\mathbf B^{\\mathrm T}\\right) = m\\)である場合を考えます．この時，\\(\\mathbf L'\\)は正則行列となります．よって，\n\\[\n\\begin{aligned}\n    \\mathbf L'^{-1} &= \\left(\\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T}\\right)^{-1} \\\\\n    &= \\left( \\mathbf V^{\\mathrm T} \\right)^{-1} \\mathbf S^{-1} \\mathbf D^{-1} \\mathbf V^{-1} \\\\\n    &= \\mathbf V \\mathbf S \\mathbf D^{-1} \\mathbf V^{\\mathrm T} \\\\\n    &= \\mathbf V \\mathbf D^{-1}\\mathbf S \\mathbf V^{\\mathrm T}\n\\end{aligned}\n\\]\nとなります．従って，\n\\[\n\\begin{aligned}\n    \\mathbf R &= \\mathbf A \\mathbf B^{\\mathrm T} \\mathbf L'^{-1} \\\\\n   &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T} \\mathbf V \\mathbf D^{-1} \\mathbf S \\mathbf V^{\\mathrm T}\\\\\n   &= \\mathbf U \\mathbf S \\mathbf V^{\\mathrm T}\n\\end{aligned}\n\\]\nとなります．次に，\\(\\mathrm{rank}\\left(\\mathbf A \\mathbf B^{\\mathrm T}\\right) = m-1\\)である場合を考えます．\n\\[\n\\begin{aligned}\n\\mathbf A \\mathbf B^{\\mathrm T} &=\\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\\\\\n\\mathbf L' &= \\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T} \\\\\n  \\mathbf R\\mathbf L'  &= \\mathbf A \\mathbf B^{\\mathrm T} \\\\\n\\end{aligned}\n\\]\nであるため， \\[\n\\begin{aligned}\n  \\mathbf R\\mathbf L'  &= \\mathbf A \\mathbf B^{\\mathrm T}\\\\\n  \\mathbf R\\left(\\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T} \\right) &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\\\\\n  \\mathbf R\\mathbf V \\mathbf D \\mathbf S \\mathbf V^{\\mathrm T} \\mathbf V &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\\mathbf V\\\\\n  \\mathbf R\\mathbf V \\mathbf D \\mathbf S &= \\mathbf U \\mathbf D \\\\\n\\end{aligned}\n\\]\nここで，\\(\\mathrm{rank}\\left(\\mathbf A \\mathbf B^{\\mathrm T}\\right) = m-1\\)であるため，\\(d_{m} = 0\\)となります．また，\\(s_{1} = s_{2} = \\cdots = s_{m} = 1\\)であるため，\n\\[\n\\begin{aligned}\n  \\mathbf D\\mathbf S  &= \\mathbf D\\\\\n\\end{aligned}\n\\]\nとなります．よって，\n\\[\n\\begin{aligned}\n  \\mathbf R\\mathbf V \\mathbf D &= \\mathbf U \\mathbf D \\\\\n\\end{aligned}\n\\]\nここで， \\[\n\\begin{aligned}\n\\mathbf Q &=  \\mathbf U^{\\mathrm T} \\mathbf R\\mathbf V \\\\\n\\left| \\mathbf Q \\right| &= \\left|  \\mathbf U^{\\mathrm T} \\mathbf R\\mathbf V \\right|\\\\\n&= \\left| \\mathbf U^{\\mathrm T}\\right|\\left| \\mathbf R\\right| \\left|\\mathbf V \\right|\\\\\n&= \\left| \\mathbf U\\right|\\left|\\mathbf V \\right|\n\\end{aligned}\n\\]\nと置くと，\n\\[\n\\begin{aligned}\n\\mathbf U^{\\mathrm T}   \\mathbf R\\mathbf V \\mathbf D &=\\mathbf U^{\\mathrm T}  \\mathbf U \\mathbf D \\\\\n\\mathbf Q\\mathbf D &= \\mathbf D \\\\\n\\end{aligned}\n\\]\nと表すことができます．さらに\n\\[\n\\begin{aligned}\n\\mathbf Q &= \\left(\\mathbf q_{1} \\mathbf q_{2} \\cdots \\mathbf q_{m} \\right)\\\\\n\\mathbf e_{i} &= \\left(e_{i,1}, e_{i,2}, \\cdots, e_{i,m}\\right)^{\\mathrm T} \\\\\ne_{i,j} &= \\begin{cases}\n    0 & \\ \\ \\  \\text{otherwise} \\\\\n    1 & \\ \\ \\  \\text{if}\\ \\ i=j\n  \\end{cases}\n\\end{aligned}\n\\]\nと置くと，\n\\[\n\\begin{aligned}\nd_{i} \\mathbf q_{i} &= d_{i}\\mathbf e_{i} \\\\\n\\mathbf q_{i} &= \\mathbf e_{i} \\ \\left( 1 \\leq i \\leq m - 1\\right)\n\\end{aligned}\n\\]\nとなります．また，\\(\\mathbf U\\), \\(\\mathbf R\\), \\(\\mathbf V\\)は全て直交行列です．従って\\(\\mathbf Q\\)も同様に直交行列となります．そのため，\\(\\mathbf q_{m}\\)は\\(\\mathbf q_{1} \\cdots \\mathbf q_{m-1}\\)と直交します．従って，\n\\[\n\\begin{aligned}\n\\mathbf q_{m} = \\begin{cases}\n    \\mathbf e_{m}   & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = 1\\\\\n     -\\mathbf e_{m} & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = -1\n  \\end{cases}\n\\end{aligned}\n\\]\nとなります．以上の結果より，\n\\[\n\\begin{aligned}\n\\mathrm{svd} \\left(\\mathbf A\\mathbf B^{\\mathrm T}\\right) &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\\\\\n\\mathbf S &= \\begin{cases}\n    \\mathbf I   & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = 1\\\\\n    \\mathrm{diag} \\ \\left(1, 1, \\cdots, 1, -1\\right) & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = -1\n  \\end{cases}\\\\\n\\mathbf R &= \\mathbf U \\mathbf Q \\mathbf V^{\\mathrm T}\\\\\n&=  \\mathbf U \\mathbf S \\mathbf V^{\\mathrm T}\\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#相似変換の推定",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#相似変換の推定",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "相似変換の推定",
    "text": "相似変換の推定\n前述した通り，相似変換は以下の\\(e^{2}\\left(c, \\mathbf R, \\mathbf t\\right)\\)を最小化する\\(c, \\mathbf R, \\mathbf t\\)を求めることによって与えられます．\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t\\right) &= \\frac{1}{n} \\sum_{i=1}^{n} \\left| \\mathbf y_{i} - \\left(c\\mathbf R \\mathbf x_{i} + \\mathbf t\\right)\\right|^{2}\n\\end{aligned}\n\\]\nここで，\\(\\mathbf X= \\left(\\mathbf x_{1}, \\mathbf x_{2}, \\cdots, \\mathbf x_{n}\\right)\\)，\\(\\mathbf Y= \\left(\\mathbf y_{1}, \\mathbf y_{2}, \\cdots, \\mathbf y_{n}\\right)\\)，\\(\\mathbf h = \\left(1, 1, \\cdots, 1\\right)^{\\mathrm T}\\)と置くと，\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t\\right) &= \\frac{1}{n} \\left\\| \\mathbf Y - c \\mathbf R \\mathbf X -\\mathbf t \\mathbf h^{\\mathrm T}  \\right\\|^{\\mathrm 2}\n\\end{aligned}\n\\]\nと表現することができます．また，\n\\[\n\\begin{aligned}\n\\mathbf K &= \\mathbf I - \\frac{1}{n} \\mathbf h \\mathbf h^{\\mathrm T} \\\\\n\\mathbf K &= \\mathbf K^{\\mathrm T}\\\\\n\\mathbf K \\mathbf K^{\\mathrm T} &= \\mathbf K\n\\end{aligned}\n\\]\nとすると，\n\\[\n\\begin{aligned}\n\\mathbf X\\mathbf K &= \\mathbf X\\left(\\mathbf I - \\frac{1}{n} \\mathbf h \\mathbf h^{\\mathrm T} \\right)\\\\\n&= \\mathbf X - \\frac{1}{n}\\mathbf X\\mathbf h \\mathbf h^{\\mathrm T}\\\\\n\\mathbf X &= \\mathbf X\\mathbf K + \\frac{1}{n}\\mathbf X \\mathbf h \\mathbf h^{\\mathrm T}\n\\end{aligned}\n\\]\nであり，同様に，\n\\[\n\\begin{aligned}\n\\mathbf Y &= \\mathbf Y\\mathbf K + \\frac{1}{n}\\mathbf Y \\mathbf h \\mathbf h^{\\mathrm T}\n\\end{aligned}\n\\]\nこれらを用いて，\\(e^{2}\\left(c, \\mathbf R, \\mathbf t\\right)\\)を表すと，\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t\\right) &= \\frac{1}{n} \\left\\|  \\mathbf Y\\mathbf K + \\frac{1}{n}\\mathbf Y \\mathbf h \\mathbf h^{\\mathrm T} - c \\mathbf R \\left(\\mathbf X\\mathbf K + \\frac{1}{n}\\mathbf X \\mathbf h \\mathbf h^{\\mathrm T}\\right) -\\mathbf t \\mathbf h^{\\mathrm T}  \\right\\|^{\\mathrm 2}\\\\\n&= \\frac{1}{n} \\left\\|  \\mathbf Y\\mathbf K + \\frac{1}{n}\\mathbf Y \\mathbf h \\mathbf h^{\\mathrm T} - c \\mathbf R \\mathbf X\\mathbf K -\\frac{c}{n}\\mathbf R\\mathbf X \\mathbf h \\mathbf h^{\\mathrm T} -\\mathbf t \\mathbf h^{\\mathrm T}  \\right\\|^{\\mathrm 2}\\\\\n&= \\frac{1}{n} \\left\\|  \\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K + \\left(\\frac{1}{n}\\mathbf Y \\mathbf h -\\frac{c}{n}\\mathbf R\\mathbf X \\mathbf h  -\\mathbf t\\right) \\mathbf h^{\\mathrm T}  \\right\\|^{\\mathrm 2}\\\\\n&= \\frac{1}{n} \\left\\|  \\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K - \\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{\\mathrm 2}\\\\\n&=  \\frac{1}{n} \\mathrm{tr}\\left(\\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K - \\mathbf t' \\mathbf h^{\\mathrm T} \\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K - \\mathbf t' \\mathbf h^{\\mathrm T} \\right) \\right)\\\\\n&= \\frac{1}{n} \\mathrm{tr}\\left(\\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right) - \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n-\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K\\right)\n+\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T} \\right)\n\\right)\\\\\n&= \\frac{1}{n}\\left\\{\n\\mathrm{tr}\\left(\n     \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)\n  \\right)\n     -\\mathrm{tr}\\left(\n         \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n         -\\mathrm{tr}\\left(\n\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K\\right)\\right)+\\mathrm{tr}\\left(\n\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T} \\right)\n  \\right)\n\\right\\}\\\\\n&= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -\\mathrm{tr}\\left(\n         \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n         -\\mathrm{tr}\\left(\\left(\n\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)^{\\mathrm T}\\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K\\right)\n  \\right)^{\\mathrm T}\\right)\n  \\right\\}\\\\\n&= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -\\mathrm{tr}\\left(\n         \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n         -\\mathrm{tr}\\left(\n         \\left(\\mathbf Y\\mathbf K  - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\n\\left(\\mathbf t' \\mathbf h^{\\mathrm T}\\right)\n\\right)\n  \\right\\}\\\\\n   &= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -2\\mathrm{tr}\\left(\n         \\left(\\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right)^{\\mathrm T}\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n  \\right\\}\\\\\n     &= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -2\\mathrm{tr}\\left(\n         \\left(\\mathbf K^{\\mathrm T}\\mathbf Y^{\\mathrm T} - c \\mathbf K^{\\mathrm T} \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n  \\right\\}\\\\\n      &= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -2\\mathrm{tr}\\left(\\mathbf K^{\\mathrm T}\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n  \\right\\}\\\\\n        &= \\frac{1}{n}\\left\\{\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} + \\left\\|\\mathbf t' \\mathbf h^{\\mathrm T}  \\right\\|^{2}\n      -2\\mathrm{tr}\\left(\\mathbf K\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\left(\\mathbf t' \\mathbf h^{\\mathrm T}  \\right)\n         \\right)\n  \\right\\}\\\\\n\\end{aligned}\n\\]\nなお，\n\\[\n\\begin{aligned}\n\\mathbf t' &= -\\frac{1}{n}\\mathbf Y \\mathbf h +\\frac{c}{n}\\mathbf R\\mathbf X \\mathbf h  +\\mathbf t\n\\end{aligned}\n\\]\nと置いています．ここで，右辺第３項について考えます． \\[\n\\begin{aligned}\n\\mathrm{tr}\\left(\\mathbf K\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\mathbf t' \\mathbf h^{\\mathrm T}\n         \\right) &=\\mathrm{tr}\\left(\\mathbf h^{\\mathrm T}  \\mathbf K\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\mathbf t'\n         \\right) \\\\\n         &= \\mathrm{tr}\\left(\\mathbf h^{\\mathrm T}  \\left( \\mathbf I - \\frac{1}{n} \\mathbf h \\mathbf h^{\\mathrm T} \\right)\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\mathbf t'\n         \\right) \\\\\n         &= \\mathrm{tr}\\left( \\left( \\mathbf h^{\\mathrm T} - \\frac{1}{n} \\mathbf h^{\\mathrm T}\\mathbf h \\mathbf h^{\\mathrm T} \\right)\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\mathbf t'\n         \\right) \\\\\n                  &= \\mathrm{tr}\\left( \\left( \\mathbf h^{\\mathrm T} - \\mathbf h^{\\mathrm T} \\right)\n         \\left(\\mathbf Y^{\\mathrm T} - c \\mathbf X^{\\mathrm T}\\mathbf R^{\\mathrm T}\\right)\\mathbf t'\n         \\right) \\\\\n         &= 0\n\\end{aligned}\n\\]\n次に右辺第２項について考えます． \\[\n\\begin{aligned}\n\\left\\|\\mathbf t'\\mathbf h^{\\mathrm T} \\right\\|^{2}&= n\\left\\| \\mathbf t'\\right\\|^{2}\n\\end{aligned}\n\\]\n以上の結果より，\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t\\right) &= \\frac{1}{n}\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2}\n+ \\left\\| \\mathbf t'\\right\\|^{2}\n\\end{aligned}\n\\]\nと表されます．\\(e^{2}\\left(c, \\mathbf R, \\mathbf t\\right)\\)を最小化するために，\\(\\mathbf t'=0\\)と置くと，\n\\[\n\\begin{aligned}\n\\mathbf t' &= -\\frac{1}{n}\\mathbf Y \\mathbf h +\\frac{c}{n}\\mathbf R\\mathbf X \\mathbf h  +\\mathbf t\\\\\n&= 0\\\\\n\\end{aligned}\n\\]\n従って，\n\\[\n\\begin{aligned}\n\\mathbf t &= \\frac{1}{n}\\mathbf Y \\mathbf h - \\frac{c}{n}\\mathbf R\\mathbf X \\mathbf h\n\\end{aligned}\n\\]\nここで， \\[   \n\\begin{aligned}\n\\mathbf{\\mu_{y}} &= \\frac{1}{n}\\mathbf Y \\mathbf h\\\\\n\\mathbf{\\mu_{x}} &= \\frac{1}{n}\\mathbf X \\mathbf h\n\\end{aligned}\n\\]\nと置くと， \\[   \n\\begin{aligned}\n\\mathbf t &=  \\mathbf{\\mu_{y}} - c\\mathbf R\\mathbf{\\mu_{x}}\n\\end{aligned}\n\\]\n並進成分が求まったので，再度評価関数\\(e^{2}\\)を書き下すと，\n\\[\n\\begin{aligned}\ne^{2}\\left(c, \\mathbf R, \\mathbf t = \\mathbf{\\mu_{y}} - c\\mathbf R\\mathbf{\\mu_{x}}\\right) &= \\frac{1}{n}\n\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2}\n\\end{aligned}\n\\]\nここで，\\(\\frac{1}{n}\\mathbf Y \\mathbf K \\mathbf X^{\\mathrm T}\\)の特異値分解を以下の様に置きます． \\[\n\\begin{aligned}\n\\frac{1}{n}\\mathbf Y \\mathbf K \\mathbf X^{\\mathrm T} &= \\mathbf U \\mathbf D \\mathbf V^{\\mathrm T}\n\\end{aligned}\n\\]\nすると，\n\\[\n\\begin{aligned}\n\\left(\\mathbf Y \\mathbf K\\right)\\left(c\\mathbf X \\mathbf K\\right)^{\\mathrm T} &= c\\mathbf Y \\mathbf K \\mathbf K^{\\mathrm T}\\mathbf X^{\\mathrm T}\\\\\n&= c \\mathbf Y \\mathbf K\\mathbf X^{\\mathrm T}\\\\\n&= cn\\mathbf U \\mathbf D\\mathbf V^{\\mathrm T}\\\\\n\\end{aligned}\n\\]\nまた，回転行列の推定の結果より， \\[\n\\begin{aligned}\n\\frac{1}{n}\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2} &= \\frac{1}{n} \\left\\{\n\\left\\|\\mathbf Y \\mathbf K\\right\\|^{2} + c^{2}\\left\\|\\mathbf X \\mathbf K\\right\\|^{2} - 2\\mathrm{tr} \\left(cn\\mathbf U \\mathbf D\\mathbf V^{\\mathrm T}\\right)\n\\right\\}\n\\end{aligned}\n\\]\n上式を\\(c\\)について最小化すると，\n\\[\n\\begin{aligned}\n\\frac{\\partial}{\\partial c} \\frac{1}{n}\\left\\| \\mathbf Y\\mathbf K - c \\mathbf R \\mathbf X\\mathbf K\\right\\|^{2}&= \\frac{1}{n} \\left\\{2 c\\left\\|\\mathbf X \\mathbf K\\right\\|^{2} - 2n\\mathrm{tr} \\left(\\mathbf U \\mathbf D\\mathbf V^{\\mathrm T}\\right)\n\\right\\}\\\\\n&= 0\\\\\nc &= \\frac{\\mathrm{tr} \\left(\\mathbf D\\mathbf S\\right)}{\\frac{1}{n}\\left\\|\\mathbf X\\mathbf K\\right\\|^{2}}\n\\end{aligned}\n\\]\nここで，\n\\[\n\\begin{aligned}\n\\sigma_{x}^{2}&= \\frac{1}{n}\\left\\|\\mathbf X\\mathbf K\\right\\|^{2}\n\\end{aligned}\n\\]\nとおくと，\n\\[\n\\begin{aligned}\nc &= \\frac{\\mathrm{tr} \\left(\\mathbf D\\mathbf S\\right)}{\\sigma_{x}^{2}}\n\\end{aligned}\n\\]\nまた，回転行列\\(\\mathbf R\\)についても同様に\n\\[\n\\begin{aligned}\n\\mathbf R &=  \\mathbf U \\mathbf S \\mathbf V^{\\mathrm T}\\\\\n\\mathbf S &= \\begin{cases}\n    \\mathbf I   & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = 1\\\\\n    \\mathrm{diag} \\ \\left(1, 1, \\cdots, 1, -1\\right) & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = -1\n  \\end{cases}\\\\\n\\end{aligned}\n\\]\n以上の結果をまとめると， \\[\n\\begin{aligned}\nc &= \\frac{\\mathrm{tr} \\left(\\mathbf D\\mathbf S\\right)}{\\sigma_{x}^{2}}\\\\\n\\mathbf R &=  \\mathbf U \\mathbf S \\mathbf V^{\\mathrm T}\\\\\n\\mathbf S &= \\begin{cases}\n    \\mathbf I   & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = 1\\\\\n    \\mathrm{diag} \\ \\left(1, 1, \\cdots, 1, -1\\right) & \\ \\ \\  \\text{if}\\ \\ \\left| \\mathbf U\\right|\\left|\\mathbf V \\right| = -1\n  \\end{cases}\\\\\n  \\mathbf t &=  \\mathbf{\\mu_{y}} - c\\mathbf R\\mathbf{\\mu_{x}}\\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#pythonによる実装",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#pythonによる実装",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "Pythonによる実装",
    "text": "Pythonによる実装\n上述の方法をPythonで実装しました．青色の点が\\(\\mathbf X\\)を，橙色の点が\\(\\mathbf Y\\)を，緑色の点が\\(c\\mathbf R\\mathbf X\\)をそれぞれ表しています．橙色の点ど緑色の点が重なっていることから，パラメータの推定が適切に行われていることを確認できます．\n\nimport numpy as np\nfrom random import random\nimport math\nimport matplotlib.pyplot as plt\n\nn = 64\nc = random() + 0.5\ntheta = math.pi * random()\ncs, ss = math.cos(theta), math.sin(theta)\nR = np.array([[cs, -ss], [ss, cs]])\nt = np.random.rand(2, 1)\n\nnoise = 0.0 * np.random.rand(2, n)\nX = np.random.rand(2, n)\nY = c * R @ X + t + noise\nh = np.ones((n, 1))\nK = np.eye(n) - 1 / n * h @ h.T\n\nU, D, V = np.linalg.svd(Y @ K @ X.T / n) \nS = np.diag([1,np.linalg.det(U) * np.linalg.det(V) ])\nR_pred = U @ S @ V.T\nc_pred = n * np.trace(np.diag(D) @ S) / np.trace(X @ K @ X.T)\nt_pred = ((Y @ h) - c_pred * R_pred @ X @ h) / n\nY_pred = c_pred * R_pred @ X + t_pred\n\nax = plt.gca()\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nplt.scatter(x = X[0,:], y =X[1,:], label=\"X\", color=\"tab:blue\", alpha=0.3)\nplt.scatter(x = Y[0,:], y =Y[1,:], label=\"Y\", color=\"tab:orange\", alpha=0.3)\nplt.scatter(x = Y_pred[0,:], y =Y_pred[1,:], label=\"Y_pred\", color=\"tab:green\", alpha=0.3)\nax.legend()\nplt.show()"
  },
  {
    "objectID": "posts/2020-11-08-read-umeyama-1991-paper.html#参考",
    "href": "posts/2020-11-08-read-umeyama-1991-paper.html#参考",
    "title": "Least-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解",
    "section": "参考",
    "text": "参考\n\n\n[1] Petersen, K.B. et al. 2008. The matrix cookbook. Technical University of Denmark. 7, 15 (2008), 510.\n\n\n[2] Umeyama, S. 1991. Least-squares estimation of transformation parameters between two point patterns. IEEE Transactions on Pattern Analysis & Machine Intelligence. 13, 04 (1991), 376–380."
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html",
    "href": "posts/2022-01-03-aws-amplify-tips.html",
    "title": "AWS Amplifyのメモ",
    "section": "",
    "text": "AWS Amplifyを使ってみて個人的にハマったことのメモです．"
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html#やったこと",
    "href": "posts/2022-01-03-aws-amplify-tips.html#やったこと",
    "title": "AWS Amplifyのメモ",
    "section": "やったこと",
    "text": "やったこと\n\nコンテナ（Fargate）に対して，環境に応じた環境変数を設定する\nロールに対して任意のポリシーを追加する\nコンテナが配置されたVPCにリソースを配置する"
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html#コンテナfargateに対して環境に応じた環境変数を設定する",
    "href": "posts/2022-01-03-aws-amplify-tips.html#コンテナfargateに対して環境に応じた環境変数を設定する",
    "title": "AWS Amplifyのメモ",
    "section": "コンテナ（Fargate）に対して，環境に応じた環境変数を設定する",
    "text": "コンテナ（Fargate）に対して，環境に応じた環境変数を設定する\nAWS AmplifyではAPIを実装するリソースとしてコンテナ（Fargate）がサポートされています．ですが，現状ではデプロイ環境（devやprodなど）に応じた環境変数を設定することができないようです．（少なくとも，私には見つけることができませんでした）\n最初は，CloudFormationの定義ファイルを手動で書き換えることで実現できると考えていました．ですが，実際に作業を進めるとこのファイルはamplify pushのたびにdocker-compose.yamlから生成されることが判明しました．そこで，\n\ndev環境向けにdocker-compose.yaml.devを，prod環境向けにdocker-compose.yaml.prodをそれぞれ作成\nコマンドフックを利用して，amplify pushのタイミングでdocker-compose.yaml.devまたはdocker-compose.yaml.prodをdocker-compose.yamlにコピー\n\nという対応を採用しました．"
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html#ロールに対して任意のポリシーを追加する",
    "href": "posts/2022-01-03-aws-amplify-tips.html#ロールに対して任意のポリシーを追加する",
    "title": "AWS Amplifyのメモ",
    "section": "ロールに対して任意のポリシーを追加する",
    "text": "ロールに対して任意のポリシーを追加する\nカスタムリソースを追加した場合など，Lambdaに任意のポリシーを追加したい場合があると思います．そのような場合は，custom-policies.jsonを利用するのが楽です． 一応，ここやここなど，AWSの公式ドキュメントにも記載されているようですが，目立つところには記載されていないため気がつくまでに時間がかかりました．"
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html#コンテナが配置されたvpcにリソースを配置する",
    "href": "posts/2022-01-03-aws-amplify-tips.html#コンテナが配置されたvpcにリソースを配置する",
    "title": "AWS Amplifyのメモ",
    "section": "コンテナが配置されたVPCにリソースを配置する",
    "text": "コンテナが配置されたVPCにリソースを配置する\nコンテナの配置されるVPCは, amplify/backend/backend-config.json中に記述されているNetworkStackというリソースによって作成されれます．NetworkStackは\n\nCloudMapNamespaceId\nClusterName\nIgw\nSubnetIds\nVpcCidrBlock\nVpcId\nVpcLinkId\n\nを出力します．必要なパラメータはリソースによって異なると思いますが，SubnetIdsやVpcIdなどを参照することでコンテナと同じVPC内にリソースを配置することができると思います．\n上記パラメータを参照するためには，\n\namplify/backend/backend-config.jsonにおいて，上記パラメータを参照するリソースのdependsOnにNetworkStackを追加\n...\n\n  \"dependsOn\": [\n    {\n      \"category\": \"\",\n      \"resourceName\": \"NetworkStack\",\n      \"attributes\": [\n        \"VpcId\",\n        \"SubnetIds\"\n      ]\n    }\n  ]\n\n...\n上述のリソースのCloudFormationの設定ファイルにパラメータの設定を追加.この際，パラメータ名はNetworkStack<Attribute名>となります\n...\n\n\"Parameters\": {\n  ...\n\n  \"NetworkStackVpcId\": {\n    \"Type\": \"String\"\n  },\n  \"NetworkStackSubnetIds\": {\n    \"Type\": \"CommaDelimitedList\"\n  },\n\n  ...\n}, \n...\namplify env checkout <env>を実行して環境のチェックアウトを行う"
  },
  {
    "objectID": "posts/2022-01-03-aws-amplify-tips.html#参考",
    "href": "posts/2022-01-03-aws-amplify-tips.html#参考",
    "title": "AWS Amplifyのメモ",
    "section": "参考",
    "text": "参考\n\nAWS CDKまたはCloudFormationを使用し、カスタムAWSリソースでAmplifyバックエンドを拡張する新機能「カスタム」のご紹介\nAmplify Docs"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "",
    "text": "最も単純なローパスフィルタとして，移動平均フィルタが広く知られています． しかしながら，その詳細な性質を確認する機会はあまり無いのではと思います． そこで，移動平均フィルタの伝達関数，複素平面における零点の分布，周波数特性を示します． そして，ローパスフィルタとしての特性を再確認します．"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html#やったこと",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html#やったこと",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "やったこと",
    "text": "やったこと\n\n移動平均フィルタについて複素平面上で零点の分布をプロット\n移動平均フィルタについて周波数特性をプロット\n移動平均フィルタがローパスフィルタであり，直線位相であること確認"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html#移動平均フィルタについて",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html#移動平均フィルタについて",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "移動平均フィルタについて",
    "text": "移動平均フィルタについて\n移動平均フィルタとは， \\(n\\) サンプル目の入力を\\(x_{n}\\)，出力を\\(y_{n}\\)，フィルタ長を\\(N\\)とすると以下のように表すことができます． \\[y_{n} = \\frac{1}{N}\\sum_{m = 0}^{N} x_{n + m}\\] これは，連続する\\(N\\)サンプルの平均を出力とすることを意味しています． 今回は，零点と周波数特性の関係を調べたいので，上式にZ変換を行い周波数領域に持っていきます．\n\\[\n\\begin{aligned}\n\\mathcal{Z}(x_{n+m}) & = z^{-m}X(z) \\\\\\\\\n\\mathcal{Z}(y_{n}) & = Y(z) \\\\\\\\\n                   & = H(z)X(z) \\\\\\\\\n                   & = \\frac{1}{N} \\left( \\sum_{m = 0}^{N} z^{-m} \\right) X(z) \\\\\\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html#複素平面上で零点を求める",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html#複素平面上で零点を求める",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "複素平面上で零点を求める",
    "text": "複素平面上で零点を求める\n前述の伝達関数\\(H(z)\\)の根を求めることで，零点が複素平面上でどのように分布しているかを知ることができます．ここでは，\\(H(z)\\)の求根にはコンパニオン行列の固有値を計算する方法を用います． 求根方法の詳細についていかに述べます．\nまず初めに問題を定義します．\\(H(z)\\)の根を求めることとは，以下の式を満たす\\(z\\)を求めることになります．\n\\[\n\\begin{aligned}\n                  H(z)  & = \\frac{1}{N} \\sum_{m = 0}^{N} z^{-m}\\\\\\\\\n                  &= 0\n\\end{aligned}\n\\]\nここで，両辺を\\(N\\)倍して以下の式を得ます \\[\n\\begin{aligned}\n                  H'(z)  & = \\sum_{m = 0}^{N} z^{-m} \\\\\\\\\n                  &= 0\n\\end{aligned}\n\\]\nこの時，\\(H'(z)\\)に対するコンパニオン行列\\(C(H'(Z))\\)は以下のように求まります．\n\\[\n\\begin{aligned}\n                  C\\left(H'(z)\\right)  & =\n                  \\begin{pmatrix}\n                      0 & 0 & \\cdots & 0 & -1 \\\\\n                      1 & 0 & \\cdots & 0 & -1 \\\\\n                      0 & 1 & \\cdots & 0 & -1 \\\\\n                      \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n                      0 & 0 & \\cdots & 1 & -1 \\\\\n                  \\end{pmatrix}\n\\end{aligned}\n\\]\nコンパニオン行列\\(C\\left(H'(z)\\right)\\)には，以下の様な面白い性質があります．\n\\[\n\\begin{aligned}\n    \\left| zI = C\\left(H'(z)\\right) \\right| &= H'(z)\n\\end{aligned}\n\\] ここで，左辺は\\(H'(z)\\)の固有多項式を表します．従って，\n\\[\n\\begin{aligned}\n    \\left| zI = C\\left(H'(z)\\right) \\right| &= H'(z) \\\\\n    &= 0\n\\end{aligned}\n\\]\nと置くと，\\(z\\)は\\(C\\left(H'(z)\\right)\\)の固有値に等しいことが解ります．\n以下に零点のプロットを示します．この結果より，以下を確認できます． * 零点は単位円上にのみ存在する * \\(z=-1\\)以外の零点は全て複素共役になっている\n\nimport numpy as np\nimport altair as alt\n\ndef  companion(n: int):\n    return np.hstack([np.vstack([np.zeros(n-1), np.eye(n-1,n-1)] ), -np.ones(n).reshape(-1,1)])\n\ndef zeros(n):\n    return np.linalg.eig(companion(n))[0]\n\ndef plot_zeros(n):\n    source =  alt.Data(values=sum([[{\n        'Real Part' : pt.real,\n        'Imaginary Part': pt.imag,\n        \"n\": i\n    } for pt in zeros(i)] for i in range(1, n + 1)], []))\n\n    slider = alt.binding_range(min=1, max=n, step=1,name=\"n\", )\n    select_order = alt.selection_single(fields=['n'], bind=slider, init={'n': 1})\n    return alt.Chart(source).mark_circle().encode(x=alt.X(\"Real Part:Q\", scale=alt.Scale(domain=[-1.2, 1.2])), y=alt.Y(\"Imaginary Part:Q\", scale=alt.Scale(domain=[-1.2, 1.2]))).add_selection(select_order).transform_filter(select_order).interactive()\n\nplot_zeros(32)"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html#周波数特性を求める",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html#周波数特性を求める",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "周波数特性を求める",
    "text": "周波数特性を求める\n同様に周波数特性を求めます．周波数特性は\\(H(z)\\)に対して\\(z \\rightarrow \\exp^{-i\\omega}\\)と置換して\\(\\left|H(z)\\right|\\)，\\(\\angle H(z)\\)を計算することで得られます．\n\nimport math\n\ndef response(n):\n    freq = np.linspace(0, 1.0, 257, endpoint=True)\n    resp = np.sum(np.vander(np.exp(freq * 2 * np.pi * 1j), n), axis=1) / n\n    return resp, freq\n\ndef plot_freq_feature(n):\n    source = alt.Data(values = sum([[{\n        'Normalized frequency': f,\n        'gain': 20 * math.log10(abs(r)),\n        'phase': math.atan2(r.imag, r.real),\n        'n': i\n    } for r, f in zip(*response(i))] for i in range(1, n+1)], []))\n\n    base = alt.Chart(source).encode(\n        alt.X('Normalized frequency:Q', axis=alt.Axis(title=None))\n    )\n\n    amp = base.mark_line(stroke='#57A44C', interpolate='monotone').encode(\n        alt.Y('gain:Q', scale=alt.Scale(domain=[-50, 0], clamp=True), axis=alt.Axis(title='Gain(dB)', titleColor='#57A44C')),\n    )\n    \n    phase = base.mark_line(stroke='#5276A7', interpolate='monotone').encode(\n        alt.Y('phase:Q', scale=alt.Scale(domain=[-math.pi, math.pi]), axis=alt.Axis(title='Phase(rad)', titleColor='#5276A7')),\n    )\n    \n    slider = alt.binding_range(min=1, max=n, step=1,name=\"n\", )\n    select_order = alt.selection_single(fields=['n'], bind=slider, init={'n': 1})\n    return alt.layer(amp, phase).resolve_scale(\n        y = 'independent'\n    ).add_selection(select_order).transform_filter(select_order).interactive()\n\nplot_freq_feature(32)\n\n\n\n\n\n\n上図より以下のことが確認できます． - 低周波を通し，高周波をカットするローパスフィスタになっている - 複素平面上で零点の存在する周波数は利得が小さい（カットされている） - 直線位相となっている"
  },
  {
    "objectID": "posts/2020-10-10-analysis-of-moving-average-filter.html#参考",
    "href": "posts/2020-10-10-analysis-of-moving-average-filter.html#参考",
    "title": "移動平均フィルタの零点と周波数特性",
    "section": "参考",
    "text": "参考\n\n\n[1] Eigenvalue-polynomials. http://web.mit.edu/18.06/www/Spring17/Eigenvalue-Polynomials.pdf."
  },
  {
    "objectID": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html",
    "href": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html",
    "title": "XG-C100Cを追加してオンボードNICとブリッジ接続する",
    "section": "",
    "text": "Ubuntu 22.04で運用している開発用マシンにXG-C100Cを追加した記録です。 最終的に以下のような環境を構築します。\n┌───────────────┐                     ┌──────────────┐              ┌────────────────┐\n│               │                     │              │              │                │\n│               │ 10.0.0.100/24       │              │ Dynamic      │                │\n│  MacBook Pro  ├─────────────────────┤  Dev Server  ├──────────────┤  Home Network  │\n│               │                     │              │              │                │\n│               │                     │              │              │                │\n└───────────────┘                     └──────────────┘              └────────────────┘"
  },
  {
    "objectID": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#やったこと",
    "href": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#やったこと",
    "title": "XG-C100Cを追加してオンボードNICとブリッジ接続する",
    "section": "やったこと",
    "text": "やったこと\n\nUbuntu22.04にXG-C100Cを導入\n既存のNIC（オンボード）とXG-C100Cとの間をブリッジ接続"
  },
  {
    "objectID": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#xg-c100cの導入",
    "href": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#xg-c100cの導入",
    "title": "XG-C100Cを追加してオンボードNICとブリッジ接続する",
    "section": "XG-C100Cの導入",
    "text": "XG-C100Cの導入\nASUSのサイトにあるドライバはバージョンが古い（5.0.3.3）ため私の環境（kernel 5.15.0-43）でコンパイルすることができませんでした。 そこで、 MarvellのダウンロードページからAQC107Cを選択してドライバを取得します。\nダウンロード完了後、以下のように指示通り作業を行うとドライバを導入します。\n$ unzip Marvell_Linux_2.5.5.zip\nArchive:  Marvell_Linux_2.5.5.zip\n   creating: 05-23-22_Marvell_Linux_2.5.5/\n  inflating: 05-23-22_Marvell_Linux_2.5.5/atlantic-2.5.5.0-1.noarch.rpm\n extracting: 05-23-22_Marvell_Linux_2.5.5/atlantic.tar.gz\n  inflating: 05-23-22_Marvell_Linux_2.5.5/README.txt\n  inflating: 05-23-22_Marvell_Linux_2.5.5/Release_Notes_Linux_2.5.5.txt\n$ cd 05-23-22_Marvell_Linux_2.5.5\n$ tar -zxf atlantic.tar.gz\n$ sudo ./dkms.sh install\n追加したNICの名称を確認します。正しい方法がわからないので、dmesg からそれっぽいものを持ってきます。 今回追加したNICはenp4s0という名称が付けられているようです。\n$ sudo dmesg| grep atlantic\n[    2.502420] atlantic 0000:04:00.0: enabling device (0000 -> 0002)\n[    2.540366] atlantic: Detect ATL2FW 1030012\n[    5.859800] atlantic 0000:04:00.0 enp4s0: renamed from eth1\n[   17.700034] atlantic 0000:04:00.0 enp4s0: atlantic: link change old 0 new 1000"
  },
  {
    "objectID": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#nic間のブリッジ接続",
    "href": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#nic間のブリッジ接続",
    "title": "XG-C100Cを追加してオンボードNICとブリッジ接続する",
    "section": "NIC間のブリッジ接続",
    "text": "NIC間のブリッジ接続\n’/etc/netplan/00-installer-config.yaml’を修正して既存のNIC(eno1)とブリッジ接続します。\n$ cat /etc/netplan/00-installer-config.yaml\n# This is the network config written by 'subiquity'\nnetwork:\n  ethernets:\n    eno1: {}\n    enp4s0: {}\n  bridges:\n    br0:\n      interfaces:\n        - eno1\n        - enp4s0\n      dhcp4: true\n  version: 2\nMacBook Pro <-> Home Network間の通信を透過的に行うためufwを設定します。\n$ sudo ufw allow from 10.0.0.0/24\n/etc/default/ufw ufw.orgも以下のように修正します。\n$ diff /etc/default/ufw ufw.org\n19c19\n< DEFAULT_FORWARD_POLICY=\"ACCEPT\"\n---\n> DEFAULT_FORWARD_POLICY=\"DROP\""
  },
  {
    "objectID": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#参考",
    "href": "posts/2022-08-12-xg-c100c-in-ubuntu-server.html#参考",
    "title": "XG-C100Cを追加してオンボードNICとブリッジ接続する",
    "section": "参考",
    "text": "参考\n\nMarvell Drivers\nNetplan reference"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html",
    "title": "Goで類似ベクトルを検索する",
    "section": "",
    "text": "類似ベクトル検索を実現する代表的な実装にAnnoyがあります． 今回，Goの修練としてAnnoyの一部機能をGoで再実装しました．\ncountrymaam"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html#やったこと",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html#やったこと",
    "title": "Goで類似ベクトルを検索する",
    "section": "やったこと",
    "text": "やったこと\n\nkd-treeベースの探索アルゴリズムを実装\nrandom projection treeベースの探索アルゴリズムを実装\nann-benchmarksにてベンチマークを測定"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html#annoyの詳細",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html#annoyの詳細",
    "title": "Goで類似ベクトルを検索する",
    "section": "Annoyの詳細",
    "text": "Annoyの詳細\nAnnoyの詳細については以下のページが大変勉強になりました．\nannoy-explanation\n個人的には探索時のノードの取り扱い方が特に面白いと思ったので，そこの部分について少しだけ補足をしたいと思います．\n上記ページでも解説されている通り，探索時はD::pq_distanceの結果を優先度として優先度付きキューにノードを追加します． 以下に実際にこの処理を行う箇所のコードを示します．\n} else {\n  T margin = D::margin(nd, v, _f);\n  q.push(make_pair(D::pq_distance(d, margin, 1), static_cast<S>(nd->children[1])));\n  q.push(make_pair(D::pq_distance(d, margin, 0), static_cast<S>(nd->children[0])));\n}\nここで，各変数と関数の詳細は以下の通りです．\n\nD: ベクトル間のメトリック\nD::margin: クエリvから際（上述の解説ページに倣います）までの符号付き距離を計算\nD::pq_distance: 探索するノードの優先度を計算\nd: 根ノードから現在のノードに至るまでの最悪の優先度\nq: 探索するノードを決定するための優先度付きキュー\nnd: 現在のノード\n\n従って，ここではD::pq_distance(d, margin, 1)という優先度でnd->children[1]を，D::pq_distance(d, margin, 0)という優先度でnd->children[0]を，優先度キューに追加していることがわかります．\n次に，DをEuclideanとしてD::pq_distanceの詳細を示します．Euclideanにはpq_distanceが実装されていないため，実際にはMinkowskiの実装となります．\n  template<typename T>\n  static inline T pq_distance(T distance, T margin, int child_nr) {\n    if (child_nr == 0)\n      margin = -margin;\n    return std::min(distance, margin);\n  }\n上記実装では，child_nr==0が成立する場合，marginの符号を反転しています． この処理の具体例を以下の図に示します． 子ノードとしてchildren[1]を選択した場合を考えます．この時，query1に対するマージンはmargin1，query2に対するマージンは-margin2となります． 同様に子ノードとしてchildren[0]を選択した場合を考えます．この時，query1に対するマージンは-marign1, query2に対するマージンはmargin2となります．\n\n\n\ncutplane\n\n\nその結果，子ノードの優先度は当該ノードが存在する側を正とした符号付き距離となります．\ndistanceは前述のd（現在のノードに至るまでの最悪の優先度）が割り当てられています． 従って，pq_distanceは優先度が悪化した場合にその値を更新する振る舞いとなっていることが解ります．\nこの性質によって，クエリが存在する側（優先度が正）のノードの探索が完了すると，クエリが存在しない側（優先度が負）のノードの探索に取り掛かります． この様に, 場合分け等を行うことなく適切に次に探索すべきノードを選択できている点が非常に面白い実装だと思いました．"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html#実装詳細",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html#実装詳細",
    "title": "Goで類似ベクトルを検索する",
    "section": "実装詳細",
    "text": "実装詳細\n今回実装した主要なインターフェースと実装の関係を以下に示します．\n\n\n\nclass\n\n\n上図の各要素の詳細は詳細は以下のとおりです．\n\nIndex: 類似ベクトル検索のインターフェース．このインターフェースを用いてデータの登録や検索を実施\nCandidate: 検索結果を表現する構造体\nflatIndex: 線形探索による類似ベクトル検索の実装\nbspTreeIndex: バイナリ空間分割木による類似ベクトル検索の実装\nCutPlane: 際のインターフェース．このインターフェースを用いて空間を分割\nkdCutPlane: Kd-Treeを実現するための際の実装\nrpCutPlane: Random Projection Treeを実現するための際の実装\n\nKd-TreeとRandom Projection Treeとは際をどの様に計算するかの違いしかありません． そこで，bspTreeIndexとCutPlaneの組み合わせで表現することとしました． 従って，Kd-Treeは\nbspTreeIndex[T, U, kdCutPlane[T, U]]\nと表現することができます．また，Random Projection Treeは\nbspTreeIndex[T, U, rpCutPlane[T, U]]\nと表現することができます．"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html#ベンチマーク",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html#ベンチマーク",
    "title": "Goで類似ベクトルを検索する",
    "section": "ベンチマーク",
    "text": "ベンチマーク\n類似ベクトル検索のベンチマークにann-benchmarksがあります． 今回の実装をこのベンチマークに対応させることで，既存の実装とパフォーマンスを比較しました．\n\nann-benchmarksへアルゴリズムを追加する\nann-benchmarksへ新規にアルゴリズムを追加するためには，以下の作業が必要となります． また，これらの修正結果はこちらから取得可能です．\n\nアルゴリズムが動作するイメージのDockerfileを追加\nann-benchmarks/install/Dockefile.<algorithm name>というファイルに追加するアルゴリズムが動作するイメージの定義を記述します． ベンチマークを実施するための共通処理はann-benchmarksというイメージに実装されています． 従って，このイメージを継承して不足分を追記することになります．\n今回はGoでアルゴリズムを実装しました． 従って，以下のように\n\n実行ファイルをビルド\nベンチマーク用イメージにコピー\n\nという手順を踏むこととしました．\nFROM golang:1.18-rc as builder\n\nRUN go install github.com/ar90n/countrymaam/cmd/countrymaam@latest\n\nFROM ann-benchmarks\nCOPY --from=builder /go/bin/countrymaam /usr/local/bin\n\n\n類似ベクトル検索を行うプログラムを追加\nann-benchmarks/ann_benchmarks/algorithms/<algorithm name>.pyというファイルに類似ベクトル検索を行うプログラムを記述します． 拡張子からも明らかですが，ベンチマークはPythonによって実装されています． 従って，類似ベクトル検索アルゴリズムもPythonから呼び出す必要があります． 具体的には，BaseANNを継承し以下のメソッドを実装します．\n\nfit: インデックスを作成します．引数として，サイズが(サンプル数,次元)のnumpy.arrayが渡されます\nset_query_arguments: テストセットに対する検索を行う前に一度だけ呼び出されます．検索に対するパラメータの設定を行います\nquery: 類似ベクトル検索を行います．引数としてクエリと求める類似ベクトルの数が渡されます\n__init__: 引数として渡されたパラメータをもとにアルゴリズムの初期化します\n__str__: 現在のパラメータとクラス名を文字列として返します\n\n今回の実装ではPythonインターフェースを実装していません． 従って，実行ファイルをサブプロセスとして起動し，パイプを経由してデータの入出力を行います． 作成したクラスを以下に示します．\nclass Countrymaam(BaseANN):\n    def __init__(self, metric, params):\n        self._metric = metric\n        self._index = params.get(\"index\", \"kd-tree\")\n        self._n_trees = params.get(\"n_trees\", 8)\n        self._leaf_size = params.get(\"leaf_size\", 8)\n\n    def fit(self, X):\n        X = X.astype(np.float64)\n        suffix = \"\".join(random.choices(string.ascii_lowercase, k=16))\n        index_file_path = f\"index_{suffix}_{os.getpid()}.bin\"\n\n        # インデックスを作成し，ファイルに書き出す\n        p = subprocess.Popen([\n            \"countrymaam\",\n            \"train\",\n            \"--dim\", str(len(X[0])),\n            \"--index\", self._index,\n            \"--leaf-size\", str(self._leaf_size),\n            \"--tree-num\", str(self._n_trees),\n            \"--output\", index_file_path\n        ], stdin=subprocess.PIPE)\n\n        p.stdin.write(struct.pack(f\"={X.size}d\", *np.ravel(X)))\n        p.communicate()\n        p.stdin.close()\n\n        # インデックスを読み，クエリの入力を待機する\n        self._pipe = subprocess.Popen([\n            \"countrymaam\",\n            \"predict\",\n            \"--dim\", str(len(X[0])),\n            \"--index\", self._index,\n            \"--input\", index_file_path\n        ], stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n\n    def set_query_arguments(self, search_k):\n        self._search_k = search_k # 探索ノード数を設定\n\n    def query(self, v, n):\n        v = v.astype(np.float64)\n        self._pipe.stdin.write(struct.pack(f\"=i\", self._search_k)) # 探索ノード数\n        self._pipe.stdin.write(struct.pack(f\"=i\", n)) # 検索する類似ベクトル数\n        self._pipe.stdin.write(struct.pack(f\"={v.size}d\", *v)) # クエリベクトル\n        self._pipe.stdin.flush()\n\n        rn = struct.unpack(\"=i\", self._pipe.stdout.read(4))[0]\n        ret = [0] * rn\n        for i in range(rn):\n            ret[i] = struct.unpack(\"=i\", self._pipe.stdout.read(4))[0]\n        return np.array(ret)\n\n    def __str__(self):\n        return f\"Countrymaam(index={self._index}, leaf_size={self._leaf_size} n_trees={self._n_trees}, search_k={self._search_k})\"\n\n\nベンチマークの設定ファイルにアルゴリズムの設定を追加\nベンチマークに関する設定はann-benchmarks/algos.yamlというファイルに追記します． このファイルはデータ型 -> メトリック -> アルゴリズム という階層構造になっています． 従って，各アルゴリズムがサポートしているデータ型とメトリックに応じて，適切な位置に設定を記述する必要があります．\nデータ型とメトリックの組み合わせは以下の通りです．\n\nfloat\n\nany\neuclidean\nangular\n\nbit\n\nhamming\njaccard\n\n\n今回実装したアルゴリズムはユークリッド距離にのみ対応しているためeuclideanに追記します．\nアルゴリズムの階層に記述するパラメータは以下の通りです．\n\ndocker-tag: 使用するDockerイメージのタグ\nmodule: アルゴリズムが実装されているモジュール\nconstructor: アルゴリズムの実装クラス\nbase-args: 全計測に渡ってconstructorに渡される引数の共通部分\nrun-groups: constructorとset_query_arguments渡される引数の可変部分\n\n最終的な差分は以下の様になりました．\ndiff --git a/algos.yaml b/algos.yaml\nindex 7c1ebe6..f170633 100644\n--- a/algos.yaml\n+++ b/algos.yaml\n@@ -391,6 +391,28 @@ float:\n           query-args: [[0.6, 0.8, 0.9, 1.0, 1.02, 1.05, 1.1, 1.2]]\n \n   euclidean:\n+    countrymaam-kd:\n+      docker-tag: ann-benchmarks-countrymaam\n+      module: ann_benchmarks.algorithms.countrymaam\n+      constructor: Countrymaam\n+      base-args: [\"@metric\"]\n+      run-groups:\n+        kd:\n+          arg-groups:\n+            - {\"index\": [\"rkd-tree\"], \"n_trees\": [8, 16, 32, 64],\n+               \"leaf_size\":[8, 16, 32, 64]}\n+          query-args: [[16, 32, 64, 128, 256, 512, 1024, 2048]]\n+    countrymaam-rp:\n+      docker-tag: ann-benchmarks-countrymaam\n+      module: ann_benchmarks.algorithms.countrymaam\n+      constructor: Countrymaam\n+      base-args: [\"@metric\"]\n+      run-groups:\n+        rp:\n+          arg-groups:\n+            - {\"index\": [\"rrp-tree\"], \"n_trees\": [8, 16, 32, 64],\n+               \"leaf_size\":[8, 16, 32, 64]}\n+          query-args: [[16, 32, 64, 128, 256, 512, 1024, 2048]]\n     vamana(diskann):\n       docker-tag: ann-benchmarks-diskann\n       module: ann_benchmarks.algorithms.diskann\nrun-groupsにおけるarg-groupsが__init__に渡されるパラメータを，query-argsがset_query_argumentsに渡されるパラメータを表します． arg-groupsの様に複数の属性からなるパラメータは各属性の直積が渡されます．\n\n\n\nベンチマークの実行\nベンチマークは以下のコマンドで実行します．install.pyはコンテナの作成を，run.pyはベンチマークを実行します． <algorithm name>と<dataset name>は省略可能です．省略した場合，適用可能な全てのアルゴリズムまたはデータセットに対して処理を適用します．\n$ python install.py --algorithm <algorithm name>\n$ python run.py --algorithm <algorithm name> --dataset <dataset name>\n\n\n結果\n以下の結果は，fashion-mnist [3] に対するベンチマークです．図中のflannとannoyはann-benchmarksのデフォルト設定を用いています．\n\n\n\nresult\n\n\n\nCPU: AMD Ryzen 9 3950X\nMemory: 64GB"
  },
  {
    "objectID": "posts/2022-02-01-mimic-annoy-wiht-go.html#参考",
    "href": "posts/2022-02-01-mimic-annoy-wiht-go.html#参考",
    "title": "Goで類似ベクトルを検索する",
    "section": "参考",
    "text": "参考\n\n\n[1] Ann-benchmarks. GitHub repository. https://github.com/erikbern/ann-benchmarks; GitHub.\n\n\n[2] Annoy. GitHub repository. https://github.com/spotify/annoy; GitHub.\n\n\n[3] Fashion-MNIST: A novel image dataset for benchmarking machine learning algorithms: 2017. https://arxiv.org/abs/cs.LG/1708.07747."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "lab_note",
    "section": "",
    "text": "ほとんどPythonで作るWebアプリケーション\n\n\n\n\n\n\n\nPython\n\n\nWeb\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2022\n\n\n\n\n\n\n  \n\n\n\n\n続・Goによるdot積のベンチマーク\n\n\n\n\n\n\n\nGo\n\n\n線形代数\n\n\n\n\n\n\n\n\n\n\n\nNov 16, 2022\n\n\n\n\n\n\n  \n\n\n\n\nGoによるdot積のベンチマーク\n\n\n\n\n\n\n\nGo\n\n\n線形代数\n\n\n\n\n\n\n\n\n\n\n\nNov 8, 2022\n\n\n\n\n\n\n  \n\n\n\n\nOctoPrintのプラグインを作ってみる\n\n\n\n\n\n\n\nPython\n\n\n3Dプリンタ\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2022\n\n\n\n\n\n\n  \n\n\n\n\nARモデルによるシンプルなボイスチェンジャ\n\n\n\n\n\n\n\nPython\n\n\n信号処理\n\n\n\n\n\n\n\n\n\n\n\nOct 24, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nXG-C100Cを追加してオンボードNICとブリッジ接続する\n\n\n\n\n\n\n\nUbuntu\n\n\n\n\n\n\n\n\n\n\n\nAug 12, 2022\n\n\n\n\n\n\n  \n\n\n\n\nKD木と次元の呪い\n\n\n\n\n\n\n\n機械学習\n\n\n数学\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nFeb 16, 2022\n\n\n\n\n\n\n  \n\n\n\n\nGoで類似ベクトルを検索する\n\n\n\n\n\n\n\nGo\n\n\nアルゴリズム\n\n\n機械学習\n\n\n類似ベクトル検索\n\n\n\n\n\n\n\n\n\n\n\nFeb 1, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncargo-editが上手く動かない時の回避策\n\n\n\n\n\n\n\nRust\n\n\n\n\n\n\n\n\n\n\n\nJan 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAWS Amplifyのメモ\n\n\n\n\n\n\n\nAWS\n\n\nWeb\n\n\nクラウド\n\n\nAmplify\n\n\n\n\n\n\n\n\n\n\n\nJan 3, 2022\n\n\n\n\n\n\n  \n\n\n\n\nUSB to TTLx4ケーブルの作成\n\n\n\n\n\n\n\nハードウェア\n\n\n\n\n\n\n\n\n\n\n\nAug 26, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nk3sクラスタ on Raspberry Pi 4\n\n\n\n\n\n\n\nKubernetes\n\n\n\n\n\n\n\n\n\n\n\nAug 21, 2021\n\n\n\n\n\n\n  \n\n\n\n\nPythonでpingの実装してみる\n\n\n\n\n\n\n\nPython\n\n\nネットワーク\n\n\n\n\n\n\n\n\n\n\n\nAug 1, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npaaaaathによる統一的なファイルアクセス\n\n\n\n\n\n\n\nクラウド\n\n\nPython\n\n\nAWS\n\n\nGCP\n\n\n\n\n\n\n\n\n\n\n\nJun 6, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nソフトマックス関数を用いた混合ガウスモデルの計算\n\n\n\n\n\n\n\n機械学習\n\n\n信号処理\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nMay 30, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUbuntu 20.04をシリアルコンソール経由で操作する\n\n\n\n\n\n\n\nUbuntu\n\n\n\n\n\n\n\n\n\n\n\nMay 26, 2021\n\n\n\n\n\n\n  \n\n\n\n\nRustでレイトレーシングをしてみる\n\n\n\n\n\n\n\nRust\n\n\nコンピュータグラフィックス\n\n\n\n\n\n\n\n\n\n\n\nMar 30, 2021\n\n\n\n\n\n\n  \n\n\n\n\nglutinに入門してみる\n\n\n\n\n\n\n\nRust\n\n\nglutin\n\n\nOpenGL\n\n\nコンピュータグラフィックス\n\n\n\n\n\n\n\n\n\n\n\nFeb 1, 2021\n\n\n\n\n\n\n  \n\n\n\n\nstarshipの導入\n\n\n\n\n\n\n\n開発環境\n\n\n\n\n\n\n\n\n\n\n\nJan 6, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n型レベル整数ライブラリtypenumの紹介\n\n\n\n\n\n\n\nRust\n\n\n\n\n\n\n\n\n\n\n\nDec 13, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nevcxr_jupyter - Rust on Notebook\n\n\n\n\n\n\n\nRust\n\n\nJupyter\n\n\n\n\n\n\n\n\n\n\n\nNov 15, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeast-Squares Estimation of Transformation Parameters Between Two Point Patterns の読解\n\n\n\n\n\n\n\n画像処理\n\n\n線形代数\n\n\n\n\n\n\n\n\n\n\n\nNov 8, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsmart_openによる統一的なファイルアクセス\n\n\n\n\n\n\n\nクラウド\n\n\nPython\n\n\nAWS\n\n\nGCP\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUbuntu 20.04 LTS Server でUSB-NICを使う\n\n\n\n\n\n\n\nUbuntu\n\n\n\n\n\n\n\n\n\n\n\nOct 17, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDICOMにおける文字コードの取り扱い\n\n\n\n\n\n\n\nDICOM\n\n\n\n\n\n\n\n\n\n\n\nOct 12, 2020\n\n\n\n\n\n\n  \n\n\n\n\n移動平均フィルタの零点と周波数特性\n\n\n\n\n\n\n\n信号処理\n\n\nJupyter\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGitHub ActionsでWebサイトを自動更新する\n\n\n\n\n\n\n\nElm\n\n\nWeb\n\n\n\n\n\n\n\n\n\n\n\nAug 9, 2020\n\n\n\n\n\n\n  \n\n\n\n\n純粋なバイナリヒープ\n\n\n\n\n\n\n\nアルゴリズム\n\n\n\n\n\n\n\n\n\n\n\nJun 27, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三次元空間における行列演算の復習\n\n\n\n\n\n\n\n数学\n\n\n線形代数\n\n\n\n\n\n\n\n\n\n\n\nJun 27, 2020\n\n\n\n\n\n\n  \n\n\n\n\n5行で書くポアソンブレンディング\n\n\n\n\n\n\n\n画像処理\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nMay 31, 2020\n\n\n\n\n\n\n  \n\n\n\n\nRaspberry Pi 4 + k3s + Rayで分散処理を試す\n\n\n\n\n\n\n\nKubernetes\n\n\nRay\n\n\nPython\n\n\n分散システム\n\n\n\n\n\n\n\n\n\n\n\nMay 25, 2020\n\n\n\n\n\n\nNo matching items"
  }
]